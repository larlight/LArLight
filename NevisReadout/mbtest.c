/************************************************************************
*  File: pcie_diag.c
*
*  Sample user-mode diagnostics application for accessing PCIE
*  devices using WinDriver's API.
*  Code was generated by DriverWizard v10.21.
*
*  Jungo Confidential. Copyright (c) 2011 Jungo Ltd.  http://www.jungo.com
*************************************************************************/

#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <unistd.h>
#include "wdc_defs.h"
#include "wdc_lib.h" 
#include "utils.h"
#include "status_strings.h"
#include "samples/shared/diag_lib.h"
#include "samples/shared/wdc_diag_lib.h"
#include "samples/shared/pci_regs.h"
#include "pcie_lib.h"

/*************************************************************
  General definitions
 *************************************************************/
/* Error messages display */
#define PCIE_ERR printf

/*************************************************************
  Global variables
 *************************************************************/
/* User's input command */
static CHAR gsInput[256];

/* --------------------------------------------------
    PCIE configuration registers information
   -------------------------------------------------- */
/* Configuration registers information array */
const WDC_REG gPCIE_CfgRegs[] = {
    { WDC_AD_CFG_SPACE, PCI_VID, WDC_SIZE_16, WDC_READ_WRITE, "VID", "Vendor ID" },
    { WDC_AD_CFG_SPACE, PCI_DID, WDC_SIZE_16, WDC_READ_WRITE, "DID", "Device ID" },
    { WDC_AD_CFG_SPACE, PCI_CR, WDC_SIZE_16, WDC_READ_WRITE, "CMD", "Command" },
    { WDC_AD_CFG_SPACE, PCI_SR, WDC_SIZE_16, WDC_READ_WRITE, "STS", "Status" },
    { WDC_AD_CFG_SPACE, PCI_REV, WDC_SIZE_32, WDC_READ_WRITE, "RID_CLCD", "Revision ID & Class Code" },
    { WDC_AD_CFG_SPACE, PCI_CCSC, WDC_SIZE_8, WDC_READ_WRITE, "SCC", "Sub Class Code" },
    { WDC_AD_CFG_SPACE, PCI_CCBC, WDC_SIZE_8, WDC_READ_WRITE, "BCC", "Base Class Code" },
    { WDC_AD_CFG_SPACE, PCI_CLSR, WDC_SIZE_8, WDC_READ_WRITE, "CALN", "Cache Line Size" },
    { WDC_AD_CFG_SPACE, PCI_LTR, WDC_SIZE_8, WDC_READ_WRITE, "LAT", "Latency Timer" },
    { WDC_AD_CFG_SPACE, PCI_HDR, WDC_SIZE_8, WDC_READ_WRITE, "HDR", "Header Type" },
    { WDC_AD_CFG_SPACE, PCI_BISTR, WDC_SIZE_8, WDC_READ_WRITE, "BIST", "Built-in Self Test" },
    { WDC_AD_CFG_SPACE, PCI_BAR0, WDC_SIZE_32, WDC_READ_WRITE, "BADDR0", "Base Address 0" },
    { WDC_AD_CFG_SPACE, PCI_BAR1, WDC_SIZE_32, WDC_READ_WRITE, "BADDR1", "Base Address 1" },
    { WDC_AD_CFG_SPACE, PCI_BAR2, WDC_SIZE_32, WDC_READ_WRITE, "BADDR2", "Base Address 2" },
    { WDC_AD_CFG_SPACE, PCI_BAR3, WDC_SIZE_32, WDC_READ_WRITE, "BADDR3", "Base Address 3" },
    { WDC_AD_CFG_SPACE, PCI_BAR4, WDC_SIZE_32, WDC_READ_WRITE, "BADDR4", "Base Address 4" },
    { WDC_AD_CFG_SPACE, PCI_BAR5, WDC_SIZE_32, WDC_READ_WRITE, "BADDR5", "Base Address 5" },
    { WDC_AD_CFG_SPACE, PCI_CIS, WDC_SIZE_32, WDC_READ_WRITE, "CIS", "CardBus CIS Pointer" },
    { WDC_AD_CFG_SPACE, PCI_SVID, WDC_SIZE_16, WDC_READ_WRITE, "SVID", "Sub-system Vendor ID" },
    { WDC_AD_CFG_SPACE, PCI_SDID, WDC_SIZE_16, WDC_READ_WRITE, "SDID", "Sub-system Device ID" },
    { WDC_AD_CFG_SPACE, PCI_EROM, WDC_SIZE_32, WDC_READ_WRITE, "EROM", "Expansion ROM Base Address" },
    { WDC_AD_CFG_SPACE, PCI_CAP, WDC_SIZE_8, WDC_READ_WRITE, "NEW_CAP", "New Capabilities Pointer" },
    { WDC_AD_CFG_SPACE, PCI_ILR, WDC_SIZE_32, WDC_READ_WRITE, "INTLN", "Interrupt Line" },
    { WDC_AD_CFG_SPACE, PCI_IPR, WDC_SIZE_32, WDC_READ_WRITE, "INTPIN", "Interrupt Pin" },
    { WDC_AD_CFG_SPACE, PCI_MGR, WDC_SIZE_32, WDC_READ_WRITE, "MINGNT", "Minimum Required Burst Period" },
    { WDC_AD_CFG_SPACE, PCI_MLR, WDC_SIZE_32, WDC_READ_WRITE, "MAXLAT", "Maximum Latency" },
    };
#define PCIE_CFG_REGS_NUM sizeof(gPCIE_CfgRegs) / sizeof(WDC_REG)
/* TODO: For read-only or write-only registers, change the direction field of
         the relevant registers in gPCIE_CfgRegs to WDC_READ or WDC_WRITE. */
/* NOTE: You can define additional configuration registers in gPCIE_CfgRegs. */
const WDC_REG *gpPCIE_CfgRegs = gPCIE_CfgRegs;

/* -----------------------------------------------
    PCIE run-time registers information
   ----------------------------------------------- */
/* Run-time registers information array */
/* const WDC_REG gPCIE_Regs[]; */
const WDC_REG *gpPCIE_Regs = NULL;
/* TODO: You can remove the comment from the gPCIE_Regs array declaration and
         fill the array with run-time registers information for your device,
         in which case be sure to set gpPCIE_Regs to point to gPCIE_Regs. */
#define PCIE_REGS_NUM 0

/*************************************************************
  Static functions prototypes
 *************************************************************/
/* -----------------------------------------------
    Main diagnostics menu
   ----------------------------------------------- */
static void MenuMain(WDC_DEVICE_HANDLE *phDev, WDC_DEVICE_HANDLE *phDev2);

/* -----------------------------------------------
    Device find, open and close
   ----------------------------------------------- */
static WDC_DEVICE_HANDLE DeviceFindAndOpen(DWORD dwVendorId, DWORD dwDeviceId);
static BOOL DeviceFind(DWORD dwVendorId, DWORD dwDeviceId, WD_PCI_SLOT *pSlot);
static WDC_DEVICE_HANDLE DeviceOpen(const WD_PCI_SLOT *pSlot);
static void DeviceClose(WDC_DEVICE_HANDLE hDev);

/* -----------------------------------------------
    Read/write memory and I/O addresses
   ----------------------------------------------- */
static void MenuReadWriteAddr(WDC_DEVICE_HANDLE hDev);
static void SetAddrSpace(WDC_DEVICE_HANDLE hDev, PDWORD pdwAddrSpace);

/* -----------------------------------------------
    Read/write the configuration space
   ----------------------------------------------- */
static void MenuReadWriteCfgSpace(WDC_DEVICE_HANDLE hDev);

/* -----------------------------------------------
    Read/write the run-time registers
   ----------------------------------------------- */
static void MenuReadWriteRegs(WDC_DEVICE_HANDLE hDev);

/* -----------------------------------------------
    Interrupt handling
   ----------------------------------------------- */
static void MenuInterrupts(WDC_DEVICE_HANDLE hDev);
static void DiagIntHandler(WDC_DEVICE_HANDLE hDev, PCIE_INT_RESULT *pIntResult);

/* ----------------------------------------------------
    Plug-and-play and power management events handling
   ---------------------------------------------------- */
static void MenuEvents(WDC_DEVICE_HANDLE hDev);
static void DiagEventHandler(WDC_DEVICE_HANDLE hDev, DWORD dwAction);
static void Menujsebii_test(WDC_DEVICE_HANDLE hDev);
static void MenuMBtest(WDC_DEVICE_HANDLE hDev, WDC_DEVICE_HANDLE hDev2);
static int pcie_send(WDC_DEVICE_HANDLE hDev, int mode, int nword, UINT32 *buff_send);
static int pcie_send_6_1(WDC_DEVICE_HANDLE hDev, int mode, int nword, UINT32 *buff_send);
static int pcie_send_1(WDC_DEVICE_HANDLE hDev, int mode, int nword, UINT32 *buff_send);
static int pcie_rec_16b(WDC_DEVICE_HANDLE hDev, int mode, int istart, int nword, int ipr_status, UINT32 *buff_rec);
static int pcie_rec(WDC_DEVICE_HANDLE hDev, int mode, int istart, int nword, int ipr_status, UINT32 *buff_rec);
static int pcie_rec_2(WDC_DEVICE_HANDLE hDev, int mode, int istart, int nword, int ipr_status, UINT32 *buff_rec);
static int pcie_rec_6_1(WDC_DEVICE_HANDLE hDev, int mode, int istart, int nword, int ipr_status, UINT32 *buff_rec);
static int pcie_rec_6_2(WDC_DEVICE_HANDLE hDev, int mode, int istart, int nword, int ipr_status, UINT32 *buff_rec);
static int xmit_boot(WDC_DEVICE_HANDLE hDev, int imod_xmit);
static int fem_boot(WDC_DEVICE_HANDLE hDev, int imod_fem);


/*************************************************************
  Functions implementation
 *************************************************************/
int main(void)
{

  struct timeval start;
  gettimeofday(&start,NULL);

  long seconds, useconds;
  seconds = start.tv_sec;
  useconds = start.tv_usec;
      
  printf("\nStart time of program: %ld sec %ld usec\n",seconds,useconds);


    WDC_DEVICE_HANDLE hDev = NULL;
    WDC_DEVICE_HANDLE hDev1 = NULL;
    WDC_DEVICE_HANDLE hDev2 = NULL;

    DWORD dwStatus;

    printf("\n");
    printf("PCIE diagnostic utility.\n");
    printf("Application accesses hardware using " WD_PROD_NAME ".\n");

    /* Initialize the PCIE library */
    dwStatus = PCIE_LibInit();
    if (WD_STATUS_SUCCESS != dwStatus)
    {
        PCIE_ERR("pcie_diag: Failed to initialize the PCIE library: %s",
            PCIE_GetLastErr());
        return dwStatus;
    }

    /* Find and open a PCIE device (by default ID) */
    if (PCIE_DEFAULT_VENDOR_ID)
        hDev = DeviceFindAndOpen(PCIE_DEFAULT_VENDOR_ID, PCIE_DEFAULT_DEVICE_ID);
    if (PCIE_DEFAULT_VENDOR_ID)
        hDev1 = DeviceFindAndOpen(PCIE_DEFAULT_VENDOR_ID, PCIE_DEFAULT_DEVICE_ID);
    //if (PCIE_DEFAULT_VENDOR_ID)
    //  hDev2 = DeviceFindAndOpen(PCIE_DEFAULT_VENDOR_ID, PCIE_DEFAULT_DEVICE_ID+2);

    /* Display main diagnostics menu for communicating with the device */
    MenuMain(&hDev, &hDev2);

    /* Perform necessary cleanup before exiting the program */
    if (hDev)
        DeviceClose(hDev);
        DeviceClose(hDev1);
        //DeviceClose(hDev2);

    dwStatus = PCIE_LibUninit();
    if (WD_STATUS_SUCCESS != dwStatus)
        PCIE_ERR("pcie_diag: Failed to uninit the PCIE library: %s", PCIE_GetLastErr());
    
    return dwStatus;
}

/* -----------------------------------------------
    Main diagnostics menu
   ----------------------------------------------- */
/* Main menu options */
enum {
    MENU_MAIN_SCAN_PCI_BUS = 1,
    MENU_MAIN_FIND_AND_OPEN,
    MENU_MAIN_RW_ADDR,
    MENU_MAIN_RW_CFG_SPACE,
    MENU_MAIN_RW_REGS,
    MENU_MAIN_ENABLE_DISABLE_INT,
    MENU_MAIN_EVENTS,
    MENU_MAIN_MB_TEST, /* add new route for testing */
    MENU_MAIN_JSEBII_TEST, /* add new route for testing */
    MENU_MAIN_EXIT = DIAG_EXIT_MENU,
};

/* Main diagnostics menu */
static void MenuMain(WDC_DEVICE_HANDLE *phDev, WDC_DEVICE_HANDLE *phDev2)
{
    DWORD option;
    
    do
    {
        printf("\n");
        printf("PCIE main menu\n");
        printf("--------------\n");
        printf("%d. Scan PCI bus\n", MENU_MAIN_SCAN_PCI_BUS);
        printf("%d. Find and open a PCIE device\n", MENU_MAIN_FIND_AND_OPEN);
        if (*phDev)
        {
            printf("%d. Read/write memory and IO addresses on the device\n",
                MENU_MAIN_RW_ADDR);
            printf("%d. Read/write the device's configuration space\n",
                MENU_MAIN_RW_CFG_SPACE);
            if (PCIE_REGS_NUM)
            {
                printf("%d. Read/write the run-time registers\n",
                    MENU_MAIN_RW_REGS);
            }
            printf("%d. Enable/disable the device's interrupts\n",
                MENU_MAIN_ENABLE_DISABLE_INT);
            printf("%d. Register/unregister plug-and-play and power management "
                "events\n", MENU_MAIN_EVENTS);
            printf("%d. MicroBoone test\n", MENU_MAIN_MB_TEST);
            printf("%d. Test loop for PCIe\n", MENU_MAIN_JSEBII_TEST);
        }
        printf("%d. Exit\n", MENU_MAIN_EXIT);

	/**        
        if (DIAG_INPUT_FAIL == DIAG_GetMenuOption(&option,
            *phDev ? MENU_MAIN_EVENTS : MENU_MAIN_FIND_AND_OPEN))
        {
            continue;
        }
	**/

        if (DIAG_INPUT_FAIL == DIAG_GetMenuOption(&option,
            *phDev ? MENU_MAIN_JSEBII_TEST : MENU_MAIN_FIND_AND_OPEN))
        {
            continue;
        }

        switch (option)
        {
        case MENU_MAIN_EXIT: /* Exit menu */
            break;
        case MENU_MAIN_SCAN_PCI_BUS: /* Scan PCI bus */
            WDC_DIAG_PciDevicesInfoPrintAll(FALSE);
            break;
        case MENU_MAIN_FIND_AND_OPEN: /* Find and open a PCIE device */
            if (*phDev)
                DeviceClose(*phDev);
            *phDev = DeviceFindAndOpen(0, 0);
            break;
        case MENU_MAIN_RW_ADDR: /* Read/write memory and I/O addresses */
            MenuReadWriteAddr(*phDev);
            break;
        case MENU_MAIN_RW_CFG_SPACE: /* Read/Write the PCIE configuration space */
            MenuReadWriteCfgSpace(*phDev);
            break;
        case MENU_MAIN_RW_REGS: /* Read/write the run-time registers */
            if (PCIE_REGS_NUM)
                MenuReadWriteRegs(*phDev);
            else
                printf("Invalid selection\n");
            break;
        case MENU_MAIN_ENABLE_DISABLE_INT: /* Enable/disable interrupts */
            MenuInterrupts(*phDev);
            break;
        case MENU_MAIN_EVENTS: /* Register/unregister plug-and-play and power management events */
            MenuEvents(*phDev);
            break;
        case MENU_MAIN_MB_TEST: /* my test loop DMA */
            MenuMBtest(*phDev, *phDev2);
            break;
        case MENU_MAIN_JSEBII_TEST: /* my test loop DMA */
            Menujsebii_test(*phDev);
            break;
        }
    } while (MENU_MAIN_EXIT != option);
}

/* -----------------------------------------------
    Device find, open and close
   ----------------------------------------------- */
/* Find and open a PCIE device */
static WDC_DEVICE_HANDLE DeviceFindAndOpen(DWORD dwVendorId, DWORD dwDeviceId)
{
    WD_PCI_SLOT slot;
    
    if (!DeviceFind(dwVendorId, dwDeviceId, &slot))
        return NULL;

    return DeviceOpen(&slot);
}

/* Find a PCIE device */
static BOOL DeviceFind(DWORD dwVendorId, DWORD dwDeviceId, WD_PCI_SLOT *pSlot)
{
    DWORD dwStatus;
    DWORD i, dwNumDevices;
    WDC_PCI_SCAN_RESULT scanResult;

    if (dwVendorId == 0)
    {
        if (DIAG_INPUT_SUCCESS != DIAG_InputDWORD((PVOID)&dwVendorId,
            "Enter vendor ID", TRUE, 0, 0))
        {
            return FALSE;
        }

        if (DIAG_INPUT_SUCCESS != DIAG_InputDWORD((PVOID)&dwDeviceId,
            "Enter device ID", TRUE, 0, 0))
        {
            return FALSE;
        }
    }

    BZERO(scanResult);
    dwStatus = WDC_PciScanDevices(dwVendorId, dwDeviceId, &scanResult);
    if (WD_STATUS_SUCCESS != dwStatus)
    {
        PCIE_ERR("DeviceFind: Failed scanning the PCI bus.\n"
            "Error: 0x%lx - %s\n", dwStatus, Stat2Str(dwStatus));
        return FALSE;
    }

    dwNumDevices = scanResult.dwNumDevices;
    if (!dwNumDevices)
    {
        PCIE_ERR("No matching device was found for search criteria "
            "(Vendor ID 0x%lX, Device ID 0x%lX)\n",
            dwVendorId, dwDeviceId);

        return FALSE;
    }
    
    printf("\n");
    printf("Found %ld matching device%s [ Vendor ID 0x%lX%s, Device ID 0x%lX%s ]:\n",
        dwNumDevices, dwNumDevices > 1 ? "s" : "",
        dwVendorId, dwVendorId ? "" : " (ALL)",
        dwDeviceId, dwDeviceId ? "" : " (ALL)");

    for (i = 0; i < dwNumDevices; i++)
    {
        printf("\n");
        printf("%2ld. Vendor ID: 0x%lX, Device ID: 0x%lX\n",
            i + 1,
            scanResult.deviceId[i].dwVendorId,
            scanResult.deviceId[i].dwDeviceId);

        WDC_DIAG_PciDeviceInfoPrint(&scanResult.deviceSlot[i], FALSE);
    }
    printf("\n");

    if (dwNumDevices > 1)
    {
        sprintf(gsInput, "Select a device (1 - %ld): ", dwNumDevices);
        i = 0;
        if (DIAG_INPUT_SUCCESS != DIAG_InputDWORD((PVOID)&i,
            gsInput, FALSE, 1, dwNumDevices))
        {
            return FALSE;
        }
    }

    *pSlot = scanResult.deviceSlot[i - 1];

    return TRUE;
}

/* Open a handle to a PCIE device */
static WDC_DEVICE_HANDLE DeviceOpen(const WD_PCI_SLOT *pSlot)
{
    WDC_DEVICE_HANDLE hDev;
    DWORD dwStatus;
    WD_PCI_CARD_INFO deviceInfo;
    
    /* Retrieve the device's resources information */
    BZERO(deviceInfo);
    deviceInfo.pciSlot = *pSlot;
    dwStatus = WDC_PciGetDeviceInfo(&deviceInfo);
    if (WD_STATUS_SUCCESS != dwStatus)
    {
        PCIE_ERR("DeviceOpen: Failed retrieving the device's resources information.\n"
            "Error 0x%lx - %s\n", dwStatus, Stat2Str(dwStatus));
        return NULL;
    }

    /* NOTE: You can modify the device's resources information here, if
       necessary (mainly the deviceInfo.Card.Items array or the items number -
       deviceInfo.Card.dwItems) in order to register only some of the resources
       or register only a portion of a specific address space, for example. */

    /* Open a handle to the device */
    hDev = PCIE_DeviceOpen(&deviceInfo);
    if (!hDev)
    {
        PCIE_ERR("DeviceOpen: Failed opening a handle to the device: %s",
            PCIE_GetLastErr());
        return NULL;
    }

    return hDev;
}

/* Close handle to a PCIE device */
static void DeviceClose(WDC_DEVICE_HANDLE hDev)
{
    if (!hDev)
        return;

    if (!PCIE_DeviceClose(hDev))
    {
        PCIE_ERR("DeviceClose: Failed closing PCIE device: %s",
            PCIE_GetLastErr());
    }
}



/* Read/write memory or I/O space address menu */
static void MenuMBtest(WDC_DEVICE_HANDLE hDev, WDC_DEVICE_HANDLE hDev2)
{

#include "wdc_defs.h"
#define poweroff      0x0
#define poweron       0x1
#define configure_s30 0x2
#define configure_s60 0x3
#define configure_cont 0x20
#define rdstatus      0x80
#define loopback        0x04

#define dcm2_run_off  254
#define dcm2_run_on   255

#define dcm2_online   2
#define dcm2_setmask  3
#define dcm2_offline_busy 4
#define dcm2_load_packet_a 10
#define dcm2_load_packet_b 11
#define dcm2_offline_load 9
#define dcm2_status_read 20
#define dcm2_led_sel     29
#define dcm2_buffer_status_read 30
#define dcm2_status_read_inbuf 21
#define dcm2_status_read_evbuf 22
#define dcm2_status_read_noevnt 23
#define dcm2_zero 12
#define dcm2_compressor_hold 31

#define dcm2_5_readdata 4
#define dcm2_5_firstdcm 8
#define dcm2_5_lastdcm  9
#define dcm2_5_status_read 5
#define dcm2_5_source_id 25
#define dcm2_5_lastchnl 24

#define dcm2_packet_id_a 25
#define dcm2_packet_id_b 26
#define dcm2_hitformat_a 27
#define dcm2_hitformat_b 28

#define part_run_off  254
#define part_run_on   255
#define part_online   2
#define part_offline_busy 3
#define part_offline_hold 4
#define part_status_read 20
#define part_source_id 25


#define  t1_tr_bar 0
#define  t2_tr_bar 4
#define  cs_bar 2

/**  command register location **/

#define  tx_mode_reg 0x28
#define  t1_cs_reg 0x18
#define  r1_cs_reg 0x1c
#define  t2_cs_reg 0x20
#define  r2_cs_reg 0x24

#define  tx_md_reg 0x28

#define  cs_dma_add_low_reg 0x0
#define  cs_dma_add_high_reg  0x4
#define  cs_dma_by_cnt 0x8
#define  cs_dma_cntrl 0xc
#define  cs_dma_msi_abort 0x10

/** define status bits **/

#define  cs_init  0x20000000
#define  cs_mode_p 0x8000000
#define  cs_mode_n 0x0
#define  cs_start 0x40000000
#define  cs_done  0x80000000

#define  dma_tr1  0x100000
#define  dma_tr2  0x200000
#define  dma_tr12 0x300000
#define  dma_3dw_trans 0x0
#define  dma_4dw_trans 0x0
#define  dma_3dw_rec   0x40
#define  dma_4dw_rec   0x60
#define  dma_in_progress 0x80000000

#define  dma_abort 0x2

#define  mb_cntrl_add     0x1
#define  mb_cntrl_test_on 0x1
#define  mb_cntrl_test_off 0x0
#define  mb_cntrl_set_run_on 0x2
#define  mb_cntrl_set_run_off 0x3
#define  mb_cntrl_set_trig1 0x4
#define  mb_cntrl_set_trig2 0x5
#define  mb_cntrl_load_frame 0x6
#define  mb_cntrl_load_trig_pos 0x7

#define  mb_feb_power_add 0x1
#define  mb_feb_conf_add 0x2
#define  mb_feb_pass_add 0x3

#define  mb_feb_lst_on          1
#define  mb_feb_lst_off         0
#define  mb_feb_rxreset         2
#define  mb_feb_align           3


#define  mb_feb_adc_align       1
#define  mb_feb_a_nocomp        2
#define  mb_feb_b_nocomp        3
#define  mb_feb_blocksize       4
#define  mb_feb_timesize        5
#define  mb_feb_mod_number      6
#define  mb_feb_a_id            7
#define  mb_feb_b_id            8
#define  mb_feb_max             9

#define  mb_feb_test_source    10
#define  mb_feb_test_sample    11
#define  mb_feb_test_frame     12
#define  mb_feb_test_channel   13
#define  mb_feb_test_ph        14
#define  mb_feb_test_base      15
#define  mb_feb_test_ram_data  16

#define  mb_feb_a_test         17
#define  mb_feb_b_test         18

#define  mb_feb_a_rdhed        21
#define  mb_feb_a_rdbuf        22
#define  mb_feb_b_rdhed        23
#define  mb_feb_b_rdbuf        24

#define  mb_feb_read_probe     30
#define  mb_feb_adc_reset      33

#define  mb_a_buf_status       34
#define  mb_b_buf_status       35
#define  mb_a_ham_status       36
#define  mb_b_ham_status       37

#define  mb_feb_a_maxwords     40
#define  mb_feb_b_maxwords     41

#define  mb_feb_hold_enable    42

#define  mb_pmt_adc_reset       1
#define  mb_pmt_spi_add         2
#define  mb_pmt_adc_data_load   3

#define  mb_xmit_conf_add 0x2
#define  mb_xmit_pass_add 0x3

#define  mb_xmit_modcount 0x1
#define  mb_xmit_enable_1 0x2
#define  mb_xmit_enable_2 0x3
#define  mb_xmit_test1 0x4
#define  mb_xmit_test2 0x5

#define   mb_xmit_testdata  10

#define  mb_xmit_rdstatus 20
#define  mb_xmit_rdcounters 21
#define  mb_xmit_link_reset    22
#define  mb_opt_dig_reset   23
#define  mb_xmit_dpa_fifo_reset    24
#define  mb_xmit_dpa_word_align    25

#define  mb_trig_run                1
#define  mb_trig_frame_size         2
#define  mb_trig_deadtime_size      3
#define  mb_trig_active_size        4
#define  mb_trig_delay1_size        5
#define  mb_trig_delay2_size        6

#define  mb_trig_calib_delay        8

#define  mb_trig_prescale0         10
#define  mb_trig_prescale1         11
#define  mb_trig_prescale2         12
#define  mb_trig_prescale3         13
#define  mb_trig_prescale4         14
#define  mb_trig_prescale5         15
#define  mb_trig_prescale6         16
#define  mb_trig_prescale7         17
#define  mb_trig_prescale8         18

#define  mb_trig_mask0             20
#define  mb_trig_mask1             21
#define  mb_trig_mask2             22
#define  mb_trig_mask3             23
#define  mb_trig_mask4             24
#define  mb_trig_mask5             25
#define  mb_trig_mask6             26
#define  mb_trig_mask7             27
#define  mb_trig_mask8             28

#define  mb_trig_rd_param          30
#define  mb_trig_pctrig            31
#define  mb_trig_rd_status         32
#define  mb_trig_reset             33
#define  mb_trig_calib             34
#define  mb_trig_rd_gps            35

#define  mb_trig_g1_allow_min      36
#define  mb_trig_g1_allow_max      37
#define  mb_trig_g2_allow_min      38
#define  mb_trig_g2_allow_max      39

#define  mb_trig_sel1              40
#define  mb_trig_sel2              41
#define  mb_trig_sel3              42
#define  mb_trig_sel4              43

#define  mb_trig_p1_delay          50
#define  mb_trig_p1_width          51
#define  mb_trig_p2_delay          52
#define  mb_trig_p2_width          53
#define  mb_trig_p3_delay          54
#define  mb_trig_p3_width          55
#define  mb_trig_pulse_delay       58
#define  mb_trig_output_select     59

#define  mb_trig_pulse1            60
#define  mb_trig_pulse2            61
#define  mb_trig_pulse3            62

#define  mb_trig_frame_trig        63

#define  mb_shaper_pulsetime        1
#define  mb_shaper_dac              2
#define  mb_shaper_pattern          3
#define  mb_shaper_write            4
#define  mb_shaper_pulse            5
#define  mb_shaper_entrig           6

#define  mb_feb_pmt_gate_size      47
#define  mb_feb_pmt_beam_delay     48
#define  mb_feb_pmt_beam_size      49
#define  mb_feb_pmt_trig_delay     87

#define  mb_feb_pmt_gate1_size     88
#define  mb_feb_pmt_beam1_delay    89
#define  mb_feb_pmt_beam1_size     90
#define  mb_feb_pmt_trig1_delay    91

#define  mb_feb_pmt_ch_set         50
#define  mb_feb_pmt_delay0         51
#define  mb_feb_pmt_delay1         52
#define  mb_feb_pmt_precount       53
#define  mb_feb_pmt_thresh0        54
#define  mb_feb_pmt_thresh1        55
#define  mb_feb_pmt_thresh2        56
#define  mb_feb_pmt_thresh3        57
#define  mb_feb_pmt_width          58
#define  mb_feb_pmt_deadtime       59
#define  mb_feb_pmt_window         60
#define  mb_feb_pmt_words          61
#define  mb_feb_pmt_cos_mul        62
#define  mb_feb_pmt_cos_thres      63
#define  mb_feb_pmt_mich_mul       64
#define  mb_feb_pmt_mich_thres     65
#define  mb_feb_pmt_beam_mul       66
#define  mb_feb_pmt_beam_thres     67
#define  mb_feb_pmt_en_top         68
#define  mb_feb_pmt_en_upper       69
#define  mb_feb_pmt_en_lower       70
#define  mb_feb_pmt_blocksize      71

#define  mb_feb_pmt_test           80
#define  mb_feb_pmt_clear          81
#define  mb_feb_pmt_test_data      82
#define  mb_feb_pmt_pulse          83

#define  mb_feb_pmt_rxreset        84
#define  mb_feb_pmt_align_pulse    85
#define  mb_feb_pmt_rd_counters    86

#define  dma_buffer_size        10000000

    static DWORD dwAddrSpace;

    static UINT32 u32Data;
    static unsigned short u16Data;
    static unsigned long long u64Data, u64Data1;
    static DWORD dwOffset;
    static long imod,ichip;
    unsigned short *buffp;

/*
    WDC_ADDR_MODE mode;
    WDC_ADDR_RW_OPTIONS options;
*/
    static UINT32 i,j,k,ifr,nread,iprint,iwrite,ik,il,is,checksum;
    static UINT32 istop,newcmd,irand,ioffset,kword,lastchnl,ib;
    static UINT32 send_array[40000],read_array[dma_buffer_size],read_array1[40000];
    static UINT32 read_array_c[40000];
    static UINT32 read_comp[8000];
    static UINT32 nmask,index,itmp,nword_tot,nevent,iv,ijk,islow_read;
    static UINT32 imod_p,imod_trig,imod_shaper;
    unsigned short idcm_read_array[40000],read_array_s[1600000];
    static UINT32 idcm_read_array32[40000];
    static UINT32 idcm_send_array[400000];
    static UINT32 idcm_verify_array[400000];
    static int icomp_l,comp_s,ia,ic,ihuff;
    UINT32 *idcm_send_p,*idcm_verify_p,*pbuffp_rec;
    DWORD dwDMABufSize;
    PVOID pbuf;
    WD_DMA *pDma;
    DWORD dwStatus;
    DWORD dwOptions = DMA_FROM_DEVICE;
    UINT32 iread,icheck,izero;
    UINT32 buf_send[40000];
    static int   count,num,counta,nword,ireadback,nloop,ierror;
    static int   ij,nsend,iloop,inew,idma_readback,iadd,jevent;
    static int   itest,iframe,irun,ichip_c,dummy1,itrig_c;
    static int  idup,ihold,idouble,ihold_set,istatus_read;
    static int  idone,tr_bar,t_cs_reg,r_cs_reg,dma_tr;
    static int   timesize,ipulse,ibase,a_id,itrig_delay;
    static int   iset,ncount,nsend_f,nwrite,itrig_ext;
    static int   imod_xmit,idiv,isample;
    static int   iframe_length, itrig,idrift_time,ijtrig;
    static int   idelay0, idelay1, threshold0, threshold1, pmt_words;
    static int   cos_mult, cos_thres, en_top, en_upper, en_lower;
    static int   irise, ifall, istart_time, use_pmt, pmt_testpulse;
    static int   ich_head, ich_sample, ich_frm,idebug,ntot_rec,nred;
    static int   ineu,ibusy_send,ibusy_test,ihold_word,ndma_loop;
    static int   irawprint,ifem_fst,ifem_lst,ifem_loop,imod_fem;
    static int   pmt_deadtime,pmt_mich_window;
    static int   oframe,osample,odiv,cframe,csample,cdiv;
    static int   idac_shaper, pmt_dac_scan,pmt_precount;;
    static int   inewcode, p1_delay, p1_width, pulse_trig_delay;
    static int   p2_delay,p2_width,itrig_pulse,p3_delay,p3_width;
    unsigned char    charchannel;
    unsigned char    carray[4000];
    struct timespec tim, tim2;
    tim.tv_sec = 0;
    tim.tv_nsec =128000;


    PVOID pbuf_rec;
    WD_DMA *pDma_rec;
    DWORD dwOptions_send = DMA_TO_DEVICE | DMA_ALLOW_CACHE;
//    DWORD dwOptions_rec = DMA_FROM_DEVICE | DMA_ALLOW_CACHE | DMA_ALLOW_64BIT_ADDRESS;
    DWORD dwOptions_rec = DMA_FROM_DEVICE | DMA_ALLOW_64BIT_ADDRESS;

    static UINT64 *buffp_rec64;
    static UINT32 *buffp_rec32;
    UINT32 *px, *py, *py1;

    FILE *outf,*inpf;
    



    nread = 4096*2+6; /*16384 32768, 65536+4;  number of byte to be readout */
    ifr=0;
    iwrite =0;
    iprint =0;
    icheck =0;
    istop=0;

    printf("Input the command code for test......\n");
    printf("     (1) boot FPGA 5\n");
    printf("     (2) boot FPGA 1-4 \n");
    printf("     (3) loop back test \n");
    printf("     (4) MB controller test loopback\n");
    printf("     (5) MB controller output test \n");
    printf("     (6) MB FEM booting \n");
    printf("     (7) Fake data read \n");
    printf("     (8) Fake data read - test 2 \n");
    printf("     (9) ADC basic testing \n");
    printf("     (10) ADC testing \n");
    printf("     (11) XMIT board boot test \n");
    printf("     (12) BNL ADC testing \n");
    printf("     (14) new FEM FPGA code testing  \n");
    printf("     (15) 2 FEM and XMIT test  \n");
    printf("     (16) trigger board test \n");
    printf("     (17) shapper baord test \n");
    printf("     (18) new BNL ADC testing \n");
    printf("     (19) FEM fake data slow readback test \n");
    printf("     (20) BNL chian test routine \n");
    printf("     (21) SuperNova readout test \n");
    printf("     (22) PMT ADC systen readout test \n");
    printf("     (23) XMIT module busy test \n");
    printf("     (24) SuperNova readout test -- 2 buffer mode \n");
    printf("     (26) multiple ADC module test \n");

    scanf("%d",&newcmd);
    switch(newcmd) {


    case 1:
     printf(" number of loop \n");
     scanf("%d",&nloop);
     printf(" enter number of word per packet\n");
     scanf("%d",&nsend);
     printf(" enter 1 for loopback check\n");
     scanf("%d",&ireadback);
     printf(" type 1 to use new PCie FPGA code \n");
     scanf("%d",&inew);
     if(ireadback == 1) {
       printf(" enter 1 for readback in DCM mode\n");
       scanf("%d",&idma_readback);
     }


     if(iwrite ==1) outf = fopen("/home/chi/test.dat","w");
     printf(" scope loop test \n");
/*
    dwDMABufSize = 140000;
    dwStatus = WDC_DMAContigBufLock(hDev, &pbuf, dwOptions, dwDMABufSize, &pDma);
    if (WD_STATUS_SUCCESS != dwStatus) {
             printf("Failed locking a receive Contiguous DMA buffer. Error 0x%lx - %s\n", dwStatus, Stat2Str(dwStatus));
    }
*/
     px = &buf_send;
     py = &read_array;
     imod =11;
     ichip=6;
     for (j=0; j<nloop; j++) {
       if(inew == 1) {
         dwAddrSpace =2;
         u32Data = 0xf0000008;
         dwOffset = 0x28;
         WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
       }
       ifr=0;

/** initialize **/
/*      if(j ==0) { */
       buf_send[0]=0x0;
       buf_send[1]=0x0;
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);
/*      }   */
/** test command 1 ***/
      if (j == 0) {
       buf_send[0]=(imod <<11)+ (ichip << 8) + poweron;
       buf_send[1]=0x1111;
       i= 1;
       k= 2;
/** try to cover  1.5*100ms */
       i = pcie_send(hDev, i, k, px);
       for (k=0; k<150000000; k++) {
            ik=k+1;
            i=ik*ik;
       }
      }
       buf_send[0]=(imod <<11)+ (ichip << 8) + configure_s60;
       buf_send[1]=0x5555aaaa;
       buf_send[2]=0;
       i= 1;
       k= 2;
       i = pcie_send(hDev, i, k, px);
       for (k=0; k<1000000; k++) {
            ik=k+1;
            i=ik*ik;
       }

       /** test command 2  **/
/*       buf_send[0]=(imod <<11)+ (ichip << 8) + poweroff;
       buf_send[1]=0x1111;
       i= 1;
       k= 2;
       i = pcie_send(hDev, i, k, px);
*/

       if(ireadback == 1) {
        buf_send[0]=(imod <<11)+ (ichip << 8) + loopback;
        i= 1;
        k= 1;
        i = pcie_send(hDev, i, k, px);
       }
       inpf = fopen("/home/chi/dcm2_1152_boot","r");

        /* read data as characters (28941) */

       count = 0;
       counta= 0;
       while (fread(&charchannel,sizeof(char),1,inpf)==1) {

         carray[count] = charchannel;
         count++;
         counta++;
 /*        if ((count)%1998==0) { */
  /*       nsend = 499;   normal is 999 */
         if((count%(nsend*2)) == 0){    /* normal is 1998 */

 /*      printf(" loop = %d\n",dummy1);                          */


           buf_send[0] = (imod <<11) + (ichip << 8) + configure_cont + (carray[0]<<16);
           send_array[0] =buf_send[0];
/*           printf(" counta = %d, first word = %x, %x, %x \n",counta,buf_send[0], carray[0], carray[1]);  */
           for (ij=0; ij< nsend; ij++) {
            buf_send[ij+1] = carray[2*ij+1]+ (carray[2*ij+2]<<16);
            send_array[ij+1] = buf_send[ij+1];
           }
           nword =nsend+1;
/*
           buf_send[0] = (imod <<11) + (ichip << 8) + configure_cont + (carray[0]<<16) +(carray[1]<<24) ;
           for (ij=0; ij<499;ij++){
            buf_send[ij+1] = carray[4*ij+2]+(carray[4*ij+3]<<8)+(carray[4*ij+4]<<16)+(carray[4*ij+5]<<24);
           }
           nword = 500;
*/
           i=1;
/*
           printf(" counta = %d, first word = %x \n",counta,buf_send[0]);
           printf(" counta = %d, first word+1 = %x \n",counta,buf_send[1]);
           printf(" counta = %d, last word-1= %x \n",counta,buf_send[498]);
           printf(" counta = %d, last word = %x \n",counta,buf_send[499]);
*/
/*           if(counta < 4*nsend+1) {   */
          if(ireadback == 1) {
            if(idma_readback == 1) {
              i=pcie_rec(hDev,1,1,nword,0,py); /** set up readback  **/
            }
            else {
              if(ifr ==0) {
               WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
               dwAddrSpace =2;
               u32Data = 0x20000000;
               dwOffset = 0x1c;
               WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
               printf(" receiver inited \n");
              }
              ifr =1;
              dwAddrSpace =2;
              u32Data = 0x40000000+nword*4;
              dwOffset = 0x1c;
              WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
              dwAddrSpace =2;
              u64Data =0;
              dwOffset = 0x18;
              WDC_ReadAddr64(hDev, dwAddrSpace, dwOffset, &u64Data);
	      if(iprint==1) printf (" status word before send = %llX \n",u64Data);
//	      printf (" status word before send = %llX \n",u64Data);
            }
          }

           i =1;
           i = pcie_send(hDev, i, nword, px);

           for (k=0; k<100000; k++) {    /* 100000 for 100 microsec */
            ik=k+1;
            i=ik*ik;
           }

           if(ireadback == 1) {
            if(idma_readback == 1) {
              i=pcie_rec(hDev,1,2,nword,0,py); /** dma readback  **/
            }
            else {
             dwAddrSpace =2;
             u64Data =0;
             dwOffset = 0x18;
             WDC_ReadAddr64(hDev, dwAddrSpace, dwOffset, &u64Data);
	     if(iprint == 1) printf (" status word before read = %llX \n",u64Data);
//             printf (" status word before read = %llX \n",u64Data);
	     k = nword%2;
	     ik= nword/2+1;
	     if(k == 0) ik = nword/2;
	     for (i=0; i<ik; i++) {
               dwAddrSpace =0;
	       u64Data =0;
               dwOffset = 0x0;
               WDC_ReadAddr64(hDev, dwAddrSpace, dwOffset, &u64Data);
               read_array[i*2] = u64Data;
               read_array[i*2+1] = u64Data>>32;
             }
             dwAddrSpace =2;
             u64Data =0;
             dwOffset = 0x18;
             WDC_ReadAddr64(hDev, dwAddrSpace, dwOffset, &u64Data);
	     if(iprint ==1 )printf (" status word after read = %llX \n",u64Data);
//	     printf (" status word after read = %llX \n",u64Data);
            }
            for (i=0; i< nword; i++) {
               if(iprint ==1 ) {
                if(i%8 == 0) printf("%d", i);
                printf("%9X",read_array[i]);
                if(((i+1)%8) ==0) printf("\n");
               }
               if(read_array[i] != send_array[i]) {
                 printf("\n counta=%d, i=%d, send =%9X read= %9X \n",counta,i,send_array[i],read_array[i]);
               }
            }
            if(iprint == 1) {
               if(nword%8 !=0) printf("\n");
            }
           }
/*           }  */
           count=0;
         }
       }
       if (feof(inpf)) {
        printf("You have reached the end-of-file word count= %d %d\n", counta, count);
/*
        for (ij=count-40; ij< count; ij++) {
          printf("Last data = %d, %x\n",ij,carray[ij]);
        }
*/
/*
        buf_send[0] = (imod <<11) + (ichip << 8) + configure_cont + (carray[0]<<16)+(carray[1]<<24) ;
        if ( count > 2) {
           if( ((count-2)%4) ==0) {
             ik =(count-2)/4;
           }
           else {
             ik =(count-2)/4+1;
           }
           printf("ik= %d\n",ik);
           for (ij=0; ij<ik;ij++){
            buf_send[ij+1] = carray[4*ij+2]+(carray[4*ij+3]<<8)+ (carray[4*ij+4]<<16)+(carray[4*ij+5]<<24);
           }
           nword =ik;
        }
*/
        buf_send[0] = (imod <<11) + (ichip << 8) + configure_cont + (carray[0]<<16);
        if ( count > 1) {
           if( ((count-1)%2) ==0) {
             ik =(count-1)/2;
           }
           else {
             ik =(count-1)/2+1;
           }
           printf("ik= %d\n",ik);
           for (ij=0; ij<ik;ij++){
            buf_send[ij+1] = carray[2*ij+1]+(carray[2*ij+2]<<16);
            send_array[ij+1] = buf_send[ij+1];
           }
        }
        else ik=1;
/*
           for (ij=ik-10; ij< ik; ij++) {
            printf("Last data = %d, %x\n",ij,buf_send[ij]);
           }
*/
        nword =ik+5;
        if(ireadback == 1) {
              WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
              dwAddrSpace =2;
              u32Data = 0x20000000;
              dwOffset = 0x1c;
              WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
              dwAddrSpace =2;
              u32Data = 0x40000000+nword*4;
              dwOffset = 0x1c;
              WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
              dwAddrSpace =2;
              u64Data =0;
              dwOffset = 0x18;
              WDC_ReadAddr64(hDev, dwAddrSpace, dwOffset, &u64Data);
	      if(iprint==1) printf (" status word before send = %llX \n",u64Data);
        }
        i=1;
        i = pcie_send(hDev, i, nword, px);

        if(ireadback == 1) {
         dwAddrSpace =2;
         u64Data =0;
         dwOffset = 0x18;
         WDC_ReadAddr64(hDev, dwAddrSpace, dwOffset, &u64Data);
	 if(iprint == 1) printf (" status word before read = %llX \n",u64Data);
         k = nword%2;
	 ik= nword/2+1;
	 if(k == 0) ik = nword/2;
	 for (i=0; i<ik; i++) {
             dwAddrSpace =0;
	     u64Data =0;
             dwOffset = 0x0;
             WDC_ReadAddr64(hDev, dwAddrSpace, dwOffset, &u64Data);
             read_array[i*2] = u64Data;
             read_array[i*2+1] = u64Data>>32;
         }
	 if(iprint ==1 )printf (" status word after read = %llX \n",u64Data);
         for (i=0; i< nword; i++) {
          if(iprint ==1 ) {
            if(i%8 == 0) printf("%d", i);
            printf("%9X",read_array[i]);
            if(((i+1)%8) ==0) printf("\n");
          }
          if(read_array[i] != send_array[i]) {
            printf("\n counta=%d, i=%d, send =%9X read= %9X \n",counta,i,send_array[i],read_array[i]);
          }
         }
        }
        fclose(inpf);
       }


       printf(" j= %d\n",j);
       for (k=0; k<3000000; k++) {
        ik=k+1;
        i=ik*ik;
       }
       if(ireadback == 1) {
        buf_send[0]=(imod <<11)+ ((ichip+1) << 8) + loopback;  /* turn off loopback */
        buf_send[1]=0x5555aaaa;
        i= 1;
        k= 1;
        i = pcie_send(hDev, i, k, px);
       }

       WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
       dwAddrSpace =2;
       u32Data = 0x20000000;
       dwOffset = 0x1c;
       WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
       if(iprint == 1) printf(" receiver inited \n");
       dwAddrSpace =2;
       u32Data = 0x40000000+4;
       dwOffset = 0x1c;
       WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
       dwAddrSpace =2;
       u64Data =0;
       dwOffset = 0x18;
       WDC_ReadAddr64(hDev, dwAddrSpace, dwOffset, &u64Data);
       printf (" status word in the status read = %llX \n",u64Data);

       buf_send[0]=(imod <<11)+ (ichip << 8) + rdstatus;  /* turn on status read*/
       buf_send[1]=0x5555aaaa;
       i= 1;
       k= 1;
       i = pcie_send(hDev, i, k, px);

       dwAddrSpace =2;
       u64Data =0;
       dwOffset = 0x18;
       WDC_ReadAddr64(hDev, dwAddrSpace, dwOffset, &u64Data);
       printf (" status word in the status read = %llX \n",u64Data);

       dwAddrSpace =0;
       u64Data =0;
       dwOffset = 0x0;
       WDC_ReadAddr64(hDev, dwAddrSpace, dwOffset, &u64Data);
       u32Data = u64Data;
       printf(" status word from FPGA 5 = %11X \n", u32Data);


       if(iprint == 1) {
        if(nword%8 !=0) printf("\n");
        printf ("enter something to continue\n");
        scanf("%d",&k);
       }

     }
     break;

    case 2:
     printf(" number of loop \n");
     scanf("%d",&nloop);
     printf(" enter number of word per packet\n");
     scanf("%d",&nsend);
     if(iwrite ==1) outf = fopen("/home/chi/test.dat","w");
     printf(" scope loop test \n");

     px = &buf_send;
     imod =11;
     ichip=6;
     for (j=0; j<nloop; j++) {
/** initialize **/
      buf_send[0]=0x0;
      buf_send[1]=0x0;
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);
/** test command 1 ***/
      if (j == 0) {
       buf_send[0]=(imod <<11)+ (ichip << 8) + poweron;
       buf_send[1]=0x1111;
       i= 1;
       k= 2;
/** try to cover  100ms */
       i = pcie_send(hDev, i, k, px);
              for (k=0; k<150000000; k++) {
            ik=k+1;
            i=ik*ik;
       }
      }
/** command to configure the FPGA 1-4 ***/

       buf_send[0]=(imod <<11)+ (ichip << 8) + configure_s30;
       buf_send[1]=0x5555aaaa;
       buf_send[2]=0;
       i= 1;
       k= 2;
       i = pcie_send(hDev, i, k, px);
       for (k=0; k<100000; k++) {
            ik=k+1;
            i=ik*ik;
       }

       for (iloop=0; iloop<4; iloop++) {
        inpf = fopen("/home/chi/dcm2_780_boot","r");

        /* read data as characters (28941) */

        count = 0;
        counta= 0;
        while (fread(&charchannel,sizeof(char),1,inpf)==1) {

         carray[count] = charchannel;
         count++;
         counta++;
 /*        if ((count)%1998==0) { */
  /*       nsend = 499;   normal is 999 */
         if((count%(nsend*2)) == 0){    /* normal is 1998 */

 /*      printf(" loop = %d\n",dummy1);                          */


           buf_send[0] = (imod <<11) + (ichip << 8) + configure_cont + (carray[0]<<16);
/*           printf(" counta = %d, first word = %x, %x, %x \n",counta,buf_send[0], carray[0], carray[1]);  */
           for (ij=0; ij< nsend; ij++) {
            buf_send[ij+1] = carray[2*ij+1]+ (carray[2*ij+2]<<16);
           }
           nword =nsend+1;
/*
           buf_send[0] = (imod <<11) + (ichip << 8) + configure_cont + (carray[0]<<16) +(carray[1]<<24) ;
           for (ij=0; ij<499;ij++){
            buf_send[ij+1] = carray[4*ij+2]+(carray[4*ij+3]<<8)+(carray[4*ij+4]<<16)+(carray[4*ij+5]<<24);
           }
           nword = 500;
*/
           i=1;
/*
           printf(" counta = %d, first word = %x \n",counta,buf_send[0]);
           printf(" counta = %d, first word+1 = %x \n",counta,buf_send[1]);
           printf(" counta = %d, last word-1= %x \n",counta,buf_send[498]);
           printf(" counta = %d, last word = %x \n",counta,buf_send[499]);
*/
/*           if(counta < 4*nsend+1) {   */
           i = pcie_send(hDev, i, nword, px);
           for (k=0; k<100000; k++) {    /* 100000 for 100 microsec */
            ik=k+1;
            i=ik*ik;
           }
/*           }  */
           count=0;
         }
        }
        if (feof(inpf)) {
         printf("You have reached the end-of-file word count for fpga %d = %d %d\n", iloop+1,counta,count);
/*
        for (ij=count-40; ij< count; ij++) {
          printf("Last data = %d, %x\n",ij,carray[ij]);
        }
*/
/*
        buf_send[0] = (imod <<11) + (ichip << 8) + configure_cont + (carray[0]<<16)+(carray[1]<<24) ;
        if ( count > 2) {
           if( ((count-2)%4) ==0) {
             ik =(count-2)/4;
           }
           else {
             ik =(count-2)/4+1;
           }
           printf("ik= %d\n",ik);
           for (ij=0; ij<ik;ij++){
            buf_send[ij+1] = carray[4*ij+2]+(carray[4*ij+3]<<8)+ (carray[4*ij+4]<<16)+(carray[4*ij+5]<<24);
           }
           nword =ik;
        }
*/
         buf_send[0] = (imod <<11) + (ichip << 8) + configure_cont + (carray[0]<<16);
         if ( count > 1) {
           if( ((count-1)%2) ==0) {
             ik =(count-1)/2;
           }
           else {
             ik =(count-1)/2+1;
           }
           printf("ik= %d\n",ik);
           for (ij=0; ij<ik;ij++){
            buf_send[ij+1] = carray[2*ij+1]+(carray[2*ij+2]<<16);
           }
         }
         else ik=1;
/*
           for (ij=ik-10; ij< ik; ij++) {
            printf("Last data = %d, %x\n",ij,buf_send[ij]);
           }
*/
         nword =ik+1;
         i=1;
         i = pcie_send(hDev, i, nword, px);

         fclose(inpf);
        }
       }


       printf(" j= %d\n",j);
       for (k=0; k<3000000; k++) {
        ik=k+1;
        i=ik*ik;
       }
     }
     break;


   case 3:
     printf(" number of loop \n");
     scanf("%d",&nloop);
     printf(" enter number of word per packet\n");
     scanf("%d",&nword);
     printf(" type 1 to print \n");
     scanf("%d",&iprint);
     ireadback =1;
     printf(" type 1 to use random number \n");
     scanf("%d",&irand);
     printf(" type 1 to use new PCie FPGA code \n");
     scanf("%d",&inew);


     printf(" loop back test \n");
/*
    dwDMABufSize = 140000;
    dwStatus = WDC_DMAContigBufLock(hDev, &pbuf, dwOptions, dwDMABufSize, &pDma);
    if (WD_STATUS_SUCCESS != dwStatus) {
             printf("Failed locking a receive Contiguous DMA buffer. Error 0x%lx - %s\n", dwStatus, Stat2Str(dwStatus));
    }
*/
     px = &buf_send;
     imod =12;  /* set avoid the DCM  **/
     ichip=6;
     for (j=0; j<nloop; j++) {
/** initialize **/
      if(j ==0) {
       buf_send[0]=0x0;
       buf_send[1]=0x0;
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);
      }
      buf_send[0]=0x1;
      buf_send[1]=0x0;
      i=1;
      k=1;
      i = pcie_send(hDev, i, k, px);
      for (k=0; k<100000; k++) {    /* 100000 for 100 microsec */
       ik=k+1;
       i=ik*ik;
      }

      if(ireadback == 1) {
        if(inew == 1) {
         dwAddrSpace =2;
         u32Data = 0xf0000008;
         dwOffset = 0x28;
         WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
        }
        dwAddrSpace =2;
        u32Data = 0x20000000;
        dwOffset = 0x1c;
        WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
        dwAddrSpace =2;
        u32Data = 0x40000000+nword*4;
        dwOffset = 0x1c;
        WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
        dwAddrSpace =2;
        u64Data =0;
        dwOffset = 0x18;
        WDC_ReadAddr64(hDev, dwAddrSpace, dwOffset, &u64Data);
      	if(iprint==1) printf (" status word before send = %llX \n",u64Data);
      }
/*      }   */
/** test command 1 ***/
      for (i=0; i<nword; i++) {
       ik=i%4;

       send_array[i]=0x5555aaaa ;
       if(ik == 0) send_array[i]= 0xaaaa5555+i;
       if(irand == 1) send_array[i]=rand();
       if(i ==0) send_array[i]=0xffffffff;
       if(i ==1) send_array[i]=0x0;
       if(i ==2) send_array[i]=0xffffffff;

/*       send_array[i]= i+1;    */
       buf_send[i]=send_array[i];
      }
      i= 1;
      k= nword;
/** try to cover  100ms */
      i = pcie_send(hDev, i, k, px);
      if(ireadback == 1) {
       dwAddrSpace =2;
       u64Data =0;
       dwOffset = 0x18;
       WDC_ReadAddr64(hDev, dwAddrSpace, dwOffset, &u64Data);
       if(iprint == 1) printf (" status word before read = %llX \n",u64Data);
       k = nword%2;
       ik= nword/2+1;
       if(k == 0) ik = nword/2;
       for (i=0; i<ik; i++) {
         dwAddrSpace =0;
         u64Data =0;
         dwOffset = 0x0;
         WDC_ReadAddr64(hDev, dwAddrSpace, dwOffset, &u64Data);
         read_array[i*2] = u64Data;
         read_array[i*2+1] = u64Data>>32;
       }
       dwAddrSpace =2;
       u64Data =0;
       dwOffset = 0x18;
       WDC_ReadAddr64(hDev, dwAddrSpace, dwOffset, &u64Data);
       if(iprint ==1 )printf (" status word after read = %llX \n",u64Data);
       for (i=0; i< nword; i++) {
          if(iprint ==1 ) {
           if(i%8 == 0) printf("%d", i);
           printf("%9X",read_array[i]);
           if(((i+1)%8) ==0) printf("\n");
          }

          if(read_array[i] != send_array[i]) {
           printf("\n loop=%d, i=%d, send =%9X read= %9X \n",j,i,send_array[i],read_array[i]);
          }

       }
       if(iprint == 1) {
        if(nword%8 !=0) printf("\n");
        printf ("enter something to continue\n");
        scanf("%d",&k);
       }
      }
      ik =j%50000;
      if(ik == 0) printf(" loop = %d \n",j);
     }

     break;

   case 4:
     printf(" number of loop \n");
     scanf("%d",&nloop);
     printf(" enter number of word per packet\n");
     scanf("%d",&nword);

     printf(" type 1 to print \n");
     scanf("%d",&iprint);
     ireadback =1;
     printf(" type 1 to use random number \n");
     scanf("%d",&irand);
     inew =1;
/*
     printf(" type 1 to use new PCie FPGA code \n");
     scanf("%d",&inew);
     inew=1;
     iprint=0;
     irand=0;
     ireadback=0;
*/
     printf(" loop back test \n");
/*
    dwDMABufSize = 140000;
    dwStatus = WDC_DMAContigBufLock(hDev, &pbuf, dwOptions, dwDMABufSize, &pDma);
    if (WD_STATUS_SUCCESS != dwStatus) {
             printf("Failed locking a receive Contiguous DMA buffer. Error 0x%lx - %s\n", dwStatus, Stat2Str(dwStatus));
    }
*/
     px = &buf_send;
     imod =12;  /* set avoid the DCM  **/
     ichip=6;
     for (j=0; j<nloop; j++) {
/** initialize **/
      if(j ==0) {
       buf_send[0]=0x0;
       buf_send[1]=0x0;
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);
      }
      buf_send[0]=0x1;
      buf_send[1]=0x0;
      i=1;
      k=1;
      i = pcie_send(hDev, i, k, px);      /* set up look back */
      for (k=0; k<100000; k++) {    /* 100000 for 100 microsec */
       ik=k+1;
       i=ik*ik;
      }

      if(ireadback == 1) {
        if(inew == 1) {
         dwAddrSpace =2;
         u32Data = 0xf0000008;
         dwOffset = 0x28;
         WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
        }
        dwAddrSpace =2;
        u32Data = 0x20000000;
        dwOffset = 0x1c;
        WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
        dwAddrSpace =2;
        u32Data = 0x40000000+nword*4;
        dwOffset = 0x1c;
        WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
        dwAddrSpace =2;
        u64Data =0;
        dwOffset = 0x18;
        WDC_ReadAddr64(hDev, dwAddrSpace, dwOffset, &u64Data);
      	if(iprint==1) printf (" status word before send = %llX \n",u64Data);
      }
/*      }   */
/** test command 1 ***/
      for (i=0; i<nword; i++) {
       ik=i%4;

       send_array[i]=0x5555aaaa ;
       if(ik == 0) send_array[i]= 0xaaaa5555+i;
       if(irand == 1) send_array[i]=rand();
       if(i ==0) send_array[i]=0xffffffff;
       if(i ==1) send_array[i]=0x0;
       if(i ==2) send_array[i]=0xffffffff;

/*       send_array[i]= i+1;    */
       buf_send[i]=send_array[i];
      }
      i= 1;
      k= nword;
/** try to cover  100ms */
      i = pcie_send(hDev, i, k, px);
      if(ireadback == 1) {
       dwAddrSpace =2;
       u64Data =0;
       dwOffset = 0x18;
       WDC_ReadAddr64(hDev, dwAddrSpace, dwOffset, &u64Data);
       if(iprint == 1) printf (" status word before read = %llX \n",u64Data);
       k = nword%2;
       ik= nword/2+1;
       if(k == 0) ik = nword/2;
       for (i=0; i<ik; i++) {
         dwAddrSpace =0;
         u64Data =0;
         dwOffset = 0x0;
         WDC_ReadAddr64(hDev, dwAddrSpace, dwOffset, &u64Data);
         read_array[i*2] = u64Data;
         read_array[i*2+1] = u64Data>>32;
       }
       dwAddrSpace =2;
       u64Data =0;
       dwOffset = 0x18;
       WDC_ReadAddr64(hDev, dwAddrSpace, dwOffset, &u64Data);
       if(iprint ==1 )printf (" status word after read = %llX \n",u64Data);
       for (i=0; i< nword; i++) {
          if(iprint ==1 ) {
           if(i%8 == 0) printf("%d", i);
           printf("%9X",read_array[i]);
           if(((i+1)%8) ==0) printf("\n");
          }

          if(read_array[i] != send_array[i]) {
           printf("\n loop=%d, i=%d, send =%9X read= %9X \n",j,i,send_array[i],read_array[i]);
          }

       }
       if(iprint == 1) {
        if(nword%8 !=0) printf("\n");
        printf ("enter something to continue\n");
        scanf("%d",&k);
       }
      }
      ik =j%50000;
      if(ik == 0) printf(" loop = %d \n",j);
     }

     break;

   case 5:
     printf(" system control test \n");
     px = &buf_send;
     imod =0;  /* controller module */
/** initialize **/
     buf_send[0]=0x0;
     buf_send[1]=0x0;
     i=1;
     k=1;
     i = pcie_send(hDev, i, k, px);
     imod=0;
     ichip=1;
     buf_send[0]=(imod<<11)+(ichip<<8)+(mb_cntrl_set_run_off)+(0x0<<16); //enable offline run on
     i=1;
     k=1;
     i = pcie_send(hDev, i, k, px);

     printf("system initialized \n");
     printf("type 1 to turn on power \n");
     scanf("%d",&itest);
     if(itest == 1) {
       imod=11;
       ichip =1;
       buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_power_add+(0x0<<16); //turn module 11 power on
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);
     }
     printf(" enter 1 to set to test mode \n");
     scanf("%d",&itest);
     if(itest == 1) {
      printf(" enter the frame size \n");
      scanf("%d",&iframe);
      imod=0;
      ichip=1;
      buf_send[0]=(imod<<11)+(ichip<<8)+(mb_cntrl_load_frame)+((iframe & 0xffff)<<16); //enable test mode
      i=1;
      k=1;
      i = pcie_send(hDev, i, k, px);
      printf("enter 1 to set run on \n");
      scanf("%d",&irun);
      if(irun == 1) {
       imod=0;
       ichip=1;
       buf_send[0]=(imod<<11)+(ichip<<8)+(mb_cntrl_set_run_on)+(0x0<<16); //enable offline run on
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);
      }
     }
     break;

    case 6:
     printf(" feb boot test \n");
     printf(" enable number of loop\n");
     scanf("%d",&nloop);
     printf(" enter number of words per packet \n");
     scanf("%d",&nsend);

     px = &buf_send;
     py = &read_array;
     imod =0;  /* controller module */
/** initialize **/
     buf_send[0]=0x0;
     buf_send[1]=0x0;
     i=1;
     k=1;
     i = pcie_send(hDev, i, k, px);
// set offline test
     imod=0;
     ichip=1;
     buf_send[0]=(imod<<11)+(ichip<<8)+(mb_cntrl_test_on)+(0x0<<16); //enable offline run on
     i=1;
     k=1;
     i = pcie_send(hDev, i, k, px);
 //disable the run command
     imod=0;
     ichip=1;
     buf_send[0]=(imod<<11)+(ichip<<8)+(mb_cntrl_set_run_off)+(0x0<<16); //enable offline run on
     i=1;
     k=1;
     i = pcie_send(hDev, i, k, px);
 // turn on the Stratix III power supply
     imod=11;
     ichip =1;
     buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_power_add+(0x0<<16); //turn module 11 power on
     i=1;
     k=1;
     i = pcie_send(hDev, i, k, px);
     usleep(200000);  // wait for 200 ms
//     printf(" enable number of loop\n");
//     scanf("%d",&nloop);
     for ( j=0; j<nloop; j++) {
      usleep(10000); // wait for 10ms
      inpf = fopen("/home/ub/feb_fpga","r");
      imod=11;
      ichip=mb_feb_conf_add;
      buf_send[0]=(imod<<11)+(ichip<<8)+0x0+(0x0<<16);  // turn conf to be on
      i=1;
      k=1;
      i = pcie_send(hDev, i, k, px);
//      for (i=0; i<100000; i++) {
//          ik= i%2;
//          dummy1= (ik+i)*(ik+i);
//      }


        /* read data as characters (28941) */
      usleep(1000);   // wait fior a while
      count = 0;
      counta= 0;
      ichip_c = 7; // set ichip_c to stay away from any other command in the
      dummy1 =0;
      while (fread(&charchannel,sizeof(char),1,inpf)==1) {
       carray[count] = charchannel;
       count++;
       counta++;
       if((count%(nsend*2)) == 0) {
//        printf(" loop = %d\n",dummy1);
        buf_send[0] = (imod <<11) +(ichip_c <<8)+ (carray[0]<<16);
        send_array[0] =buf_send[0];
        if(dummy1 <= 5 ) printf(" counta = %d, first word = %x, %x, %x %x %x \n",counta,buf_send[0], carray[0], carray[1]
        ,carray[2], carray[3]);
        for (ij=0; ij< nsend; ij++) {
         if(ij== (nsend-1)) buf_send[ij+1] = carray[2*ij+1]+(0x0<<16);
         else buf_send[ij+1] = carray[2*ij+1]+ (carray[2*ij+2]<<16);
//         buf_send[ij+1] = carray[2*ij+1]+ (carray[2*ij+2]<<16);
         send_array[ij+1] = buf_send[ij+1];
        }
        nword =nsend+1;
        i=1;
//       if(dummy1 == 0)
        ij = pcie_send(hDev, i, nword, px);
        nanosleep(&tim , &tim2);
        dummy1 = dummy1+1;
        count =0;
       }
      }
      if(feof(inpf)) {
       printf("You have reached the end-of-file word count= %d %d\n", counta, count);
       buf_send[0] = (imod <<11) +(ichip_c <<8)+ (carray[0]<<16);
       if ( count > 1) {
        if( ((count-1)%2) ==0) {
         ik =(count-1)/2;
        }
        else {
         ik =(count-1)/2+1;
        }
        ik=ik+2;   // add one more for safety
        printf("ik= %d\n",ik);
        for (ij=0; ij<ik; ij++){
         if(ij == (ik-1)) buf_send[ij+1] = carray[(2*ij)+1]+(((imod<<11)+(ichip<<8)+0x0)<<16);
         else buf_send[ij+1] = carray[(2*ij)+1]+ (carray[(2*ij)+2]<<16);
         send_array[ij+1] = buf_send[ij+1];
        }
       }
       else ik=1;

           for (ij=ik-10; ij< ik+1; ij++) {
            printf("Last data = %d, %x\n",ij,buf_send[ij]);
           }

       nword =ik+1;
       i=1;
       i = pcie_send(hDev, i, nword, px);
       usleep(2000);    // wait for 2ms to cover the packet time plus fpga init time
       fclose(inpf);
       printf(" enter 1 to reset the dram \n");
       scanf("%d",&ik);
 //      ik =1;
       if(ik ==1) {
         imod=11;
         ichip=3;
         buf_send[0]=(imod<<11)+(ichip<<8)+31+(0x1<<16);  // turm the DRAM reset on
         i=1;
         k=1;
         i = pcie_send(hDev, i, k, px);
         imod=11;
         ichip=3;
         buf_send[0]=(imod<<11)+(ichip<<8)+31+(0x0<<16);  // turm the DRAM reset off
         i=1;
         k=1;
         i = pcie_send(hDev, i, k, px);

         usleep(5000);    // wait for 5 ms for DRAM to be initialized

         imod=11;
         ichip=3;
         buf_send[0]=(imod<<11)+(ichip<<8)+6+(imod<<16);  // set module number
         i=1;
         k=1;
         i = pcie_send(hDev, i, k, px);


       }
//       printf(" enter 1 to read system status \n");
//       scanf("%d",&ik);
       ik=1;
       nword =1;
       if(ik ==1) {


         i = pcie_rec(hDev,0,1,nword,1,py);     // init the receiver

         imod=11;
         ichip=3;
         buf_send[0]=(imod<<11)+(ichip<<8)+20+(0x0<<16);  // read out status
         i=1;
         k=1;
         i = pcie_send(hDev, i, k, px);
         py = &read_array;
         i = pcie_rec(hDev,0,2,nword,1,py);     // read out 2 32 bits words
         printf("receive data word = %x, %x \n", read_array[0], read_array[1]);
       }
       printf(" enter 1 to start the fake data testing \n");
       scanf("%d",&ik);
       if(ik ==1) {
        nword =1;
//
// set to use test generator 1, set test =1
//
         imod=11;
         ichip=mb_feb_pass_add;
         buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_test_source+(0x1<<16);  // set test source to 1
         i=1;
         k=1;
         i = pcie_send(hDev, i, k, px);

         imod=0;
         ichip=1;
         iframe= 511;
         buf_send[0]=(imod<<11)+(ichip<<8)+(mb_cntrl_load_frame)+((iframe & 0xffff)<<16); //enable test mode
         i=1;
         k=1;
         i = pcie_send(hDev, i, k, px);

         il=7;
         for (is=0; is<8; is++) {
          ik=il<<is;
          printf(" ik = %x\n",ik);
          imod=11;
          ichip=3;
          buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_test_ph+(ik<<16);  // set pulse height
          i=1;
          k=1;
          i = pcie_send(hDev, i, k, px);

          imod=0;
          ichip=1;
          buf_send[0]=(imod<<11)+(ichip<<8)+(mb_cntrl_set_run_on)+(0x0<<16); //enable offline run on
          i=1;
          k=1;
          i = pcie_send(hDev, i, k, px);
//      set module number again to enable the FEB module read back

          imod=11;
          ichip=3;
          buf_send[0]=(imod<<11)+(ichip<<8)+6+(imod<<16);  // set module number
          i=1;
          k=1;
          i = pcie_send(hDev, i, k, px);

          usleep(5000); // wait for 5 ms


          nword = 1;
          i = pcie_rec(hDev,0,1,nword,1,py);     // init the receiver

          imod=11;
          ichip=mb_feb_pass_add;
          buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_read_probe+(0x0<<16);  // read probe
          i=1;
          k=1;
          i = pcie_send(hDev, i, k, px);

          py = &read_array;
          i = pcie_rec(hDev,0,2,nword,1,py);     // read out 2 32 bits words
          printf("receive data word = %x, %x \n", read_array[0], read_array[1]);
          printf(" module= %d, op=%d, data= %x\n", ((read_array[0]>>11) &0x3f), (read_array[0] &0xff), (read_array[0]>>16));
          imod=0;
          ichip=1;
          buf_send[0]=(imod<<11)+(ichip<<8)+(mb_cntrl_set_run_off)+(0x0<<16); //enable offline run off
          i=1;
          k=1;
          i = pcie_send(hDev, i, k, px);
          scanf("%d",&ik);

         }

       }

       scanf("%d",&ik);
      }





     }

     break;


    case 7:
     printf(" feb boot test \n");
     printf(" enable number of loop\n");
     scanf("%d",&nloop);
     printf(" enter number of words per packet \n");
     scanf("%d",&nsend);

     px = &buf_send;
     py = &read_array;
     imod =0;  /* controller module */
/** initialize **/
     buf_send[0]=0x0;
     buf_send[1]=0x0;
     i=1;
     k=1;
     i = pcie_send(hDev, i, k, px);
// set offline test
     imod=0;
     ichip=1;
     buf_send[0]=(imod<<11)+(ichip<<8)+(mb_cntrl_test_on)+(0x0<<16); //enable offline run on
     i=1;
     k=1;
     i = pcie_send(hDev, i, k, px);
 //disable the run command
     imod=0;
     ichip=1;
     buf_send[0]=(imod<<11)+(ichip<<8)+(mb_cntrl_set_run_off)+(0x0<<16); //enable offline run on
     i=1;
     k=1;
     i = pcie_send(hDev, i, k, px);
 // turn on the Stratix III power supply
     imod=11;
     ichip =1;
     buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_power_add+(0x0<<16); //turn module 11 power on
     i=1;
     k=1;
     i = pcie_send(hDev, i, k, px);
     usleep(200000);  // wait for 200 ms
//     printf(" enable number of loop\n");
//     scanf("%d",&nloop);
     for ( j=0; j<nloop; j++) {
      usleep(10000); // wait for 10ms
      inpf = fopen("/home/ub/feb_fpga","r");
      imod=11;
      ichip=mb_feb_conf_add;
      buf_send[0]=(imod<<11)+(ichip<<8)+0x0+(0x0<<16);  // turn conf to be on
      i=1;
      k=1;
      i = pcie_send(hDev, i, k, px);
//      for (i=0; i<100000; i++) {
//          ik= i%2;
//          dummy1= (ik+i)*(ik+i);
//      }


        /* read data as characters (28941) */
      usleep(1000);   // wait fior a while
      count = 0;
      counta= 0;
      ichip_c = 7; // set ichip_c to stay away from any other command in the
      dummy1 =0;
      while (fread(&charchannel,sizeof(char),1,inpf)==1) {
       carray[count] = charchannel;
       count++;
       counta++;
       if((count%(nsend*2)) == 0) {
//        printf(" loop = %d\n",dummy1);
        buf_send[0] = (imod <<11) +(ichip_c <<8)+ (carray[0]<<16);
        send_array[0] =buf_send[0];
        if(dummy1 <= 5 ) printf(" counta = %d, first word = %x, %x, %x %x %x \n",counta,buf_send[0], carray[0], carray[1]
        ,carray[2], carray[3]);
        for (ij=0; ij< nsend; ij++) {
         if(ij== (nsend-1)) buf_send[ij+1] = carray[2*ij+1]+(0x0<<16);
         else buf_send[ij+1] = carray[2*ij+1]+ (carray[2*ij+2]<<16);
//         buf_send[ij+1] = carray[2*ij+1]+ (carray[2*ij+2]<<16);
         send_array[ij+1] = buf_send[ij+1];
        }
        nword =nsend+1;
        i=1;
//       if(dummy1 == 0)
        ij = pcie_send(hDev, i, nword, px);
        nanosleep(&tim , &tim2);
        dummy1 = dummy1+1;
        count =0;
       }
      }
      if(feof(inpf)) {
       printf("You have reached the end-of-file word count= %d %d\n", counta, count);
       buf_send[0] = (imod <<11) +(ichip_c <<8)+ (carray[0]<<16);
       if ( count > 1) {
        if( ((count-1)%2) ==0) {
         ik =(count-1)/2;
        }
        else {
         ik =(count-1)/2+1;
        }
        ik=ik+2;   // add one more for safety
        printf("ik= %d\n",ik);
        for (ij=0; ij<ik; ij++){
         if(ij == (ik-1)) buf_send[ij+1] = carray[(2*ij)+1]+(((imod<<11)+(ichip<<8)+0x0)<<16);
         else buf_send[ij+1] = carray[(2*ij)+1]+ (carray[(2*ij)+2]<<16);
         send_array[ij+1] = buf_send[ij+1];
        }
       }
       else ik=1;

           for (ij=ik-10; ij< ik+1; ij++) {
            printf("Last data = %d, %x\n",ij,buf_send[ij]);
           }

       nword =ik+1;
       i=1;
       i = pcie_send(hDev, i, nword, px);
       usleep(2000);    // wait for 2ms to cover the packet time plus fpga init time
       fclose(inpf);
       printf(" enter 1 to reset the dram \n");
       scanf("%d",&ik);
 //      ik =1;
       if(ik ==1) {
         imod=11;
         ichip=3;
         buf_send[0]=(imod<<11)+(ichip<<8)+31+(0x1<<16);  // turm the DRAM reset on
         i=1;
         k=1;
         i = pcie_send(hDev, i, k, px);
         imod=11;
         ichip=3;
         buf_send[0]=(imod<<11)+(ichip<<8)+31+(0x0<<16);  // turm the DRAM reset off
         i=1;
         k=1;
         i = pcie_send(hDev, i, k, px);

         usleep(5000);    // wait for 5 ms for DRAM to be initialized

         imod=11;
         ichip=3;
         buf_send[0]=(imod<<11)+(ichip<<8)+6+(imod<<16);  // set module number
         i=1;
         k=1;
         i = pcie_send(hDev, i, k, px);


       }
//       printf(" enter 1 to read system status \n");
//       scanf("%d",&ik);
       ik=1;
       nword =1;
       if(ik ==1) {


         i = pcie_rec(hDev,0,1,nword,1,py);     // init the receiver

         imod=11;
         ichip=3;
         buf_send[0]=(imod<<11)+(ichip<<8)+20+(0x0<<16);  // read out status
         i=1;
         k=1;
         i = pcie_send(hDev, i, k, px);
         py = &read_array;
         i = pcie_rec(hDev,0,2,nword,1,py);     // read out 2 32 bits words
         printf("receive data word = %x, %x \n", read_array[0], read_array[1]);
       }
       printf(" enter 1 to start the fake data testing \n");
       scanf("%d",&ik);
       if(ik ==1) {
        nword =1;
//
// set to use test generator 1, set test =1
//
         imod=11;
         ichip=mb_feb_pass_add;
         buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_test_source+(0x1<<16);  // set test source to 1
         i=1;
         k=1;
         i = pcie_send(hDev, i, k, px);

         imod=0;
         ichip=1;
         iframe= 127;
         buf_send[0]=(imod<<11)+(ichip<<8)+(mb_cntrl_load_frame)+((iframe & 0xffff)<<16); //enable test mode
         i=1;
         k=1;
         i = pcie_send(hDev, i, k, px);

         ipulse = 0x2ff;
         ibase = 0x1f;
         for (is=0; is<10; is++) {

          imod=11;
          ichip=3;
          buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_test_base+(ibase<<16);  // set pulse base
          i=1;
          k=1;
          i = pcie_send(hDev, i, k, px);

          imod=11;
          ichip=3;
          buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_test_ph+(ipulse<<16);  // set pulse height
          i=1;
          k=1;
          i = pcie_send(hDev, i, k, px);

          imod=11;
          ichip=3;
          buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_a_nocomp+(0x1<<16);  // set a channel no compression
          i=1;
          k=1;
          i = pcie_send(hDev, i, k, px);

          timesize =3;
          imod=11;
          ichip=3;
          buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_timesize+(timesize<<16);  // set drift time size
          i=1;
          k=1;
          i = pcie_send(hDev, i, k, px);

          a_id =0x20;
          imod=11;
          ichip=3;
          buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_a_id+(a_id<<16);  // set a_id
          i=1;
          k=1;
          i = pcie_send(hDev, i, k, px);

          imod=11;
          ichip=3;
          buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_a_test+(0x1<<16);    // enable a test on
          i=1;
          k=1;
          i = pcie_send(hDev, i, k, px);


          imod=0;
          ichip=1;
          buf_send[0]=(imod<<11)+(ichip<<8)+(mb_cntrl_set_run_on)+(0x0<<16); //enable offline run on
          i=1;
          k=1;
          i = pcie_send(hDev, i, k, px);

          usleep(5000); //wait for 5 ms

          imod=0;
          ichip=1;
          buf_send[0]=(imod<<11)+(ichip<<8)+mb_cntrl_set_trig1+(0x0<<16);  // send trigger
          i=1;
          k=1;
          i = pcie_send(hDev, i, k, px);



//      set module number again to enable the FEB module read back

          imod=11;
          ichip=3;
          buf_send[0]=(imod<<11)+(ichip<<8)+6+(imod<<16);  // set module number
          i=1;
          k=1;
          i = pcie_send(hDev, i, k, px);


          usleep(5000); // wait for 5 ms


          nword = 4;
          i = pcie_rec(hDev,0,1,nword,1,py);     // init the receiver

          imod=11;
          ichip=3;
          buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_a_rdhed+(0x1<<16);  // read a header
          i=1;
          k=1;
          i = pcie_send(hDev, i, k, px);

          py = &read_array;
          i = pcie_rec(hDev,0,2,nword,1,py);     // read out 2 32 bits words
          printf("receive data word = %x, %x, %x, %x \n", read_array[0], read_array[1], read_array[2], read_array[3]);
          nread = (((read_array[1] >>16) & 0xfff)<<12) + (read_array[1] & 0xfff);
          printf(" number of data word to read = %d\n",nread);
          scanf("%d",&ik);
          nword = (nread)/2+1;                    // short words
          i = pcie_rec(hDev,0,1,nword,1,py);     // init the receiver

          imod=11;
          ichip=mb_feb_pass_add;
          buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_a_rdbuf+(0x0<<16);  // read a header
          i=1;
          k=1;
          i = pcie_send(hDev, i, k, px);

          py = &read_array;
          i = pcie_rec(hDev,0,2,nword,1,py);     // read out 2 32 bits words

          for (i=0; i< nword; i++) {
              if((i%8) ==0) printf("%4d",i);
              printf(" %8x",read_array[i]);
              if(((i+1)%8) ==0 ) printf("\n");
          }
          imod=0;
          ichip=1;
          buf_send[0]=(imod<<11)+(ichip<<8)+(mb_cntrl_set_run_off)+(0x0<<16); //enable offline run off
          i=1;
          k=1;
          i = pcie_send(hDev, i, k, px);
          scanf("%d",&ik);

         }

       }

       scanf("%d",&ik);
      }





     }

     break;


    case 8:
     printf(" feb boot test \n");
     printf(" enable number of loop\n");
     scanf("%d",&nloop);
     printf(" 1 for checking the event \n");
     scanf("%d",&icheck);
     printf(" type 1 to use random number \n");
     scanf("%d",&irand);
     if(icheck != 1) {
      printf(" 1 for print event\n");
      scanf("%d",&iprint);
     }
     else iprint =0;
     printf(" number event \n");
     scanf("%d",&nevent);

//     printf(" enter number of words per packet \n");
//     scanf("%d",&nsend);
     nsend=500;

     px = &buf_send;
     py = &read_array;
     imod =0;  /* controller module */
/** initialize **/
     buf_send[0]=0x0;
     buf_send[1]=0x0;
     i=1;
     k=1;
     i = pcie_send(hDev, i, k, px);
// set offline test
     imod=0;
     ichip=1;
     buf_send[0]=(imod<<11)+(ichip<<8)+(mb_cntrl_test_on)+(0x0<<16); //enable offline run on
     i=1;
     k=1;
     i = pcie_send(hDev, i, k, px);
 //disable the run command
     imod=0;
     ichip=1;
     buf_send[0]=(imod<<11)+(ichip<<8)+(mb_cntrl_set_run_off)+(0x0<<16); //enable offline run on
     i=1;
     k=1;
     i = pcie_send(hDev, i, k, px);
 // turn on the Stratix III power supply
     imod=11;
     ichip =1;
     buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_power_add+(0x0<<16); //turn module 11 power on
     i=1;
     k=1;
     i = pcie_send(hDev, i, k, px);
     usleep(200000);  // wait for 200 ms
//     printf(" enable number of loop\n");
//     scanf("%d",&nloop);
     for ( j=0; j<nloop; j++) {
      usleep(10000); // wait for 10ms
      inpf = fopen("/home/ub/feb_fpga","r");
      imod=11;
      ichip=mb_feb_conf_add;
      buf_send[0]=(imod<<11)+(ichip<<8)+0x0+(0x0<<16);  // turn conf to be on
      i=1;
      k=1;
      i = pcie_send(hDev, i, k, px);
//      for (i=0; i<100000; i++) {
//          ik= i%2;
//          dummy1= (ik+i)*(ik+i);
//      }


        /* read data as characters (28941) */
      usleep(1000);   // wait fior a while
      count = 0;
      counta= 0;
      ichip_c = 7; // set ichip_c to stay away from any other command in the
      dummy1 =0;
      while (fread(&charchannel,sizeof(char),1,inpf)==1) {
       carray[count] = charchannel;
       count++;
       counta++;
       if((count%(nsend*2)) == 0) {
//        printf(" loop = %d\n",dummy1);
        buf_send[0] = (imod <<11) +(ichip_c <<8)+ (carray[0]<<16);
        send_array[0] =buf_send[0];
        if(dummy1 <= 5 ) printf(" counta = %d, first word = %x, %x, %x %x %x \n",counta,buf_send[0], carray[0], carray[1]
        ,carray[2], carray[3]);
        for (ij=0; ij< nsend; ij++) {
         if(ij== (nsend-1)) buf_send[ij+1] = carray[2*ij+1]+(0x0<<16);
         else buf_send[ij+1] = carray[2*ij+1]+ (carray[2*ij+2]<<16);
//         buf_send[ij+1] = carray[2*ij+1]+ (carray[2*ij+2]<<16);
         send_array[ij+1] = buf_send[ij+1];
        }
        nword =nsend+1;
        i=1;
//       if(dummy1 == 0)
        ij = pcie_send(hDev, i, nword, px);
        nanosleep(&tim , &tim2);
        dummy1 = dummy1+1;
        count =0;
       }
      }
      if(feof(inpf)) {
       printf("You have reached the end-of-file word count= %d %d\n", counta, count);
       buf_send[0] = (imod <<11) +(ichip_c <<8)+ (carray[0]<<16);
       if ( count > 1) {
        if( ((count-1)%2) ==0) {
         ik =(count-1)/2;
        }
        else {
         ik =(count-1)/2+1;
        }
        ik=ik+2;   // add one more for safety
        printf("ik= %d\n",ik);
        for (ij=0; ij<ik; ij++){
         if(ij == (ik-1)) buf_send[ij+1] = carray[(2*ij)+1]+(((imod<<11)+(ichip<<8)+0x0)<<16);
         else buf_send[ij+1] = carray[(2*ij)+1]+ (carray[(2*ij)+2]<<16);
         send_array[ij+1] = buf_send[ij+1];
        }
       }
       else ik=1;

           for (ij=ik-10; ij< ik+1; ij++) {
            printf("Last data = %d, %x\n",ij,buf_send[ij]);
           }

       nword =ik+1;
       i=1;
       i = pcie_send(hDev, i, nword, px);
       usleep(2000);    // wait for 2ms to cover the packet time plus fpga init time
       fclose(inpf);
       printf(" enter 1 to reset the dram \n");
       scanf("%d",&ik);
 //      ik =1;
       if(ik ==1) {
         imod=11;
         ichip=3;
         buf_send[0]=(imod<<11)+(ichip<<8)+31+(0x1<<16);  // turm the DRAM reset on
         i=1;
         k=1;
         i = pcie_send(hDev, i, k, px);
         imod=11;
         ichip=3;
         buf_send[0]=(imod<<11)+(ichip<<8)+31+(0x0<<16);  // turm the DRAM reset off
         i=1;
         k=1;
         i = pcie_send(hDev, i, k, px);

         usleep(5000);    // wait for 5 ms for DRAM to be initialized

         imod=11;
         ichip=3;
         buf_send[0]=(imod<<11)+(ichip<<8)+6+(imod<<16);  // set module number
         i=1;
         k=1;
         i = pcie_send(hDev, i, k, px);


       }
//       printf(" enter 1 to read system status \n");
//       scanf("%d",&ik);
       ik=1;
       nword =1;
       if(ik ==1) {


         i = pcie_rec(hDev,0,1,nword,iprint,py);     // init the receiver

         imod=11;
         ichip=3;
         buf_send[0]=(imod<<11)+(ichip<<8)+20+(0x0<<16);  // read out status
         i=1;
         k=1;
         i = pcie_send(hDev, i, k, px);
         py = &read_array;
         i = pcie_rec(hDev,0,2,nword,iprint,py);     // read out 2 32 bits words
         printf("receive data word = %x, %x \n", read_array[0], read_array[1]);
       }
//       printf(" enter L1 trigger delay \n");
//       scanf("%d",&itrig_delay);
       itrig_delay = 51;
       nword =1;
//
// set to use test generator 2, set test =2
//
       imod=11;
       ichip=mb_feb_pass_add;
       buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_test_source+(0x2<<16);  // set test source to 2
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);
//
// set frame set to be 1023 --- there will be 1024/8 = 128 adc samples.
//
       imod=0;
       ichip=1;
       iframe= 255;    //1023
       buf_send[0]=(imod<<11)+(ichip<<8)+(mb_cntrl_load_frame)+((iframe & 0xffff)<<16); //enable test mode
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);


//
// load trig 1 position relative to the frame..
//
       imod=0;
       ichip=1;
       buf_send[0]=(imod<<11)+(ichip<<8)+(mb_cntrl_load_trig_pos)+((itrig_delay & 0xffff)<<16); //enable test mode
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);
//
//    start loading the test 2 data memory
//
       imod =11;
       ichip=3;
       for (is=0; is<64; is++) {
        ik = 0x4000+is;                        // load channel address
        buf_send[0]=(imod<<11)+(ichip<<8)+(mb_feb_test_ram_data)+((ik & 0xffff)<<16); //enable test mode
        i = pcie_send(hDev, 1, 1, px);
        ibase = 32*is;
        il = is%8;
        if(il == 0) printf(" loading channel %d\n",is);
        for (ik=0; ik< 256; ik++) {                 // loop over all possible address
         if(irand ==1) ijk = rand() & 0xfff ;        // use random number
         else ijk= (ibase+ik*8) & 0xfff;
         k = 0x8000+ ijk;        // make sure bit 15-12 is clear for the data
         buf_send[0]=(imod<<11)+(ichip<<8)+(mb_feb_test_ram_data)+((k & 0xffff)<<16); //enable test mode
         i = pcie_send(hDev, 1, 1, px);
         send_array[is*256+ik]=ijk;           //load up data map
        }
       }

       imod=11;
       ichip=3;
       buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_a_nocomp+(0x1<<16);  // set a channel no compression
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);

       timesize =4;
       imod=11;
       ichip=3;
       buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_timesize+(timesize<<16);  // set drift time size
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);

       a_id =0x20;
       imod=11;
       ichip=3;
       buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_a_id+(a_id<<16);  // set a_id
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);


       imod=11;
       ichip=3;
       buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_a_test+(0x1<<16);    // enable a test on
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);

       imod=0;
       ichip=1;
       buf_send[0]=(imod<<11)+(ichip<<8)+(mb_cntrl_set_run_on)+(0x0<<16); //enable offline run on
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);

       usleep(5000); //wait for 5 ms


       for (is=0; is<nevent; is++) {



        imod=0;
        ichip=1;
        buf_send[0]=(imod<<11)+(ichip<<8)+mb_cntrl_set_trig1+(0x0<<16);  // send trigger
        i=1;
        k=1;
        i = pcie_send(hDev, i, k, px);



//      set module number again to enable the FEB module read back

        imod=11;
        ichip=3;
        buf_send[0]=(imod<<11)+(ichip<<8)+6+(imod<<16);  // set module number
        i=1;
        k=1;
        i = pcie_send(hDev, i, k, px);

        usleep(5000); // wait for 5 ms


        nword = 5;
        i = pcie_rec(hDev,0,1,nword,iprint,py);     // init the receiver

        imod=11;
        ichip=3;
        buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_a_rdhed+(0x1<<16);  // read a header
        i=1;
        k=1;
        i = pcie_send(hDev, i, k, px);

        py = &read_array;
        i = pcie_rec(hDev,0,2,nword,iprint,py);     // read out 2 32 bits words
        if(iprint ==1) printf("receive data word = %x, %x, %x, %x, %x\n", read_array[0], read_array[1], read_array[2], read_array[3], read_array[4]);
        nread = (((read_array[1] >>16) & 0xfff)<<12) + (read_array[1] & 0xfff);
        if(iprint ==1) printf(" number of data word to read = %d\n",nread);

        ik =  read_array[0] & 0x1f;
        if(iprint ==1) printf(" module number = %d",ik);
        ik =  (read_array[0] >> 5) & 0x7f;
        if(iprint ==1) printf(" data ID = %d",ik);
        ik =  (((read_array[2] >>16) & 0xfff)<<12) + (read_array[2] & 0xfff);
        if(iprint ==1) printf(" event number = %d",ik);
        ik =  (((read_array[3] >>16) & 0xfff)<<12) + (read_array[3] & 0xfff);
        if(iprint ==1) printf(" frame number = %d\n",ik);
        ik =  (((read_array[4] >>16) & 0xfff)<<12) + (read_array[4] & 0xfff);
        if(iprint ==1) printf(" checksum = %x\n",ik);

        if(iprint ==1 )scanf("%d",&ik);
        nword = (nread)/2+1;                    // short words
        i = pcie_rec(hDev,0,1,nword,iprint,py);     // init the receiver

        imod=11;
        ichip=mb_feb_pass_add;
        buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_a_rdbuf+(0x0<<16);  // read a header
        i=1;
        k=1;
        i = pcie_send(hDev, i, k, px);

        py = &read_array;
        i = pcie_rec(hDev,0,2,nword,iprint,py);     // read out 2 32 bits words

        if(iprint == 1) {
         for (i=0; i< nword; i++) {
          if((i%8) ==0) printf("%4d",i);
          printf(" %8x",read_array[i]);
          if(((i+1)%8) ==0 ) printf("\n");
         }
        }

        ik=0;
        for (i=0; i< nword; i++) {
          read_array_s[ik] = read_array[i] &0xffff;
          read_array_s[ik+1] = ((read_array[i]>>16) & 0xffff);
          ik=ik+2;
        }

//
//      printout formatted word
//
        if(iprint ==1) {
         iset = 0;
         for(i=0; i< 2*nword; i++) {
          if((read_array_s[i] & 0xf000) == 0x4000) {
            iset=1;
            ncount=0;
            printf(" channel %d\n",(read_array_s[i] & 0xfff));
          }
          else if ((read_array_s[i] & 0xf000) == 0x5000) printf(" channel end %d\n",(read_array_s[i] &0xfff));
          else if (iset ==1) {
            printf(" %4x",read_array_s[i]);
            ncount = ncount+1;
            if((ncount%8) == 0) printf("\n");
          }
          else {
            printf("%x",read_array_s[i]);
            ncount = ncount+1;
            if((ncount%8) == 0) printf("\n");
          }
         }
        }

        if(icheck ==1 ){
         if((2*nword) == (64*timesize*3)){
          for (i=0; i<64; i++){
           k=i*(timesize*3);
           ij= i*256;
           if(read_array_s[k] != (0x4000+i))
            printf(" first word error, event %d data received %x, data expected %x\n", is, read_array_s[k], (0x4000+i));
           for (ik=0; ik< ((3*timesize)-2); ik++) {
            if(read_array_s[k+1+ik] != send_array[ij+ik])
             printf(" data word error, event %d ch = %d, received %x, expected %x\n",is,i,read_array_s[k+1+ik], send_array[ij+ik]);
           }
           k=(i+1)*(timesize*3)-1;
           if(read_array_s[k] != (0x5000+i))
            printf(" last word error, event %d data received %x, data expected %x\n", is, read_array_s[k], (0x5000+i));
          }
         }
         else {
          printf(" event %d number word receive = %d, expected=  %d \n", is, (2*nword), (64*timesize*3));
         }
        }
        if(icheck ==1) {
          k = is%1000;
          if(k ==0) printf("event %d\n",is);
        }
        if(iprint == 1) scanf("%d",&ik);
       }

       imod=0;
       ichip=1;
       buf_send[0]=(imod<<11)+(ichip<<8)+(mb_cntrl_set_run_off)+(0x0<<16); //enable offline run off
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);
       scanf("%d",&ik);
      }





     }

     break;


    case 9:
     printf(" ADC testing \n");
//     printf(" enter number of words per packet \n");
//     scanf("%d",&nsend);
     nsend=500;

     px = &buf_send;
     py = &read_array;
     imod =0;  /* controller module */
/** initialize **/
     buf_send[0]=0x0;
     buf_send[1]=0x0;
     i=1;
     k=1;
     i = pcie_send(hDev, i, k, px);
// set offline test
     imod=0;
     ichip=1;
     buf_send[0]=(imod<<11)+(ichip<<8)+(mb_cntrl_test_on)+(0x0<<16); //enable offline run on
     i=1;
     k=1;
     i = pcie_send(hDev, i, k, px);
 //disable the run command
     imod=0;
     ichip=1;
     buf_send[0]=(imod<<11)+(ichip<<8)+(mb_cntrl_set_run_off)+(0x0<<16); //enable offline run on
     i=1;
     k=1;
     i = pcie_send(hDev, i, k, px);
 
     printf(" 1 to send ADC RESET, 2 turn on sgate , 3 adc chip select\n");
     scanf("%d",&ik);
     if(ik ==1) {
       imod=11;
       ichip=5;
       buf_send[0]=(imod<<11)+(ichip<<8)+(mb_pmt_adc_reset)+(0x1<<16); //pulse reset
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);
       imod=11;
       ichip=5;
       buf_send[0]=(imod<<11)+(ichip<<8)+(mb_pmt_adc_reset)+(0x0<<16); //pulse reset
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);

     }
     else if(ik == 2) {
       imod=11;
       ichip=5;
       buf_send[0]=(imod<<11)+(ichip<<8)+(mb_pmt_spi_add)+(0x7<<16); //set spi address
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);
       imod=11;
       ichip=5;
       buf_send[0]=(imod<<11)+(ichip<<8)+(mb_pmt_adc_data_load)+(0xffff<<16); //load spi data
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);
     }
     else if(ik == 3) {

       imod=11;
       ichip=5;
       buf_send[0]=(imod<<11)+(ichip<<8)+(mb_pmt_adc_reset)+(0x0<<16); // reset goes high
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);
       imod=11;
       ichip=5;
       buf_send[0]=(imod<<11)+(ichip<<8)+(mb_pmt_adc_reset)+(0x1<<16); // reset goes low
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);
       imod=11;
       ichip=5;
       buf_send[0]=(imod<<11)+(ichip<<8)+(mb_pmt_adc_reset)+(0x0<<16); // reset goes high
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);
//
//
//
       imod=11;
       ichip=5;
       buf_send[0]=(imod<<11)+(ichip<<8)+(mb_pmt_spi_add)+(0x7<<16); //set spi address
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);
       imod=11;
       ichip=5;
       buf_send[0]=(imod<<11)+(ichip<<8)+(mb_pmt_adc_data_load)+(0xffff<<16); //load spi data
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);
       scanf("%d",&is);
//
//
//
       imod=11;
       ichip=5;
       buf_send[0]=(imod<<11)+(ichip<<8)+(mb_pmt_spi_add)+(0x1<<16); //set spi address
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);
       imod=11;
       ichip=5;
       buf_send[0]=(imod<<11)+(ichip<<8)+(mb_pmt_adc_data_load)+(0x0b00<<16); //load spi data
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);
     }




    break;

    case 10:
     printf(" ADC testing \n");
//     printf(" enter number of words per packet \n");
//     scanf("%d",&nsend);
     printf(" enable number of loop\n");
     scanf("%d",&nloop);
     printf(" number event \n");
     scanf("%d",&nevent);
     printf(" type 1 to write dat to file \n");
     scanf("%d",&iwrite);
     if(iwrite == 1) {
       iprint = 0;
       outf = fopen("/home/ub/test.dat","w");
     }
     else iprint = 1;

     nsend=500;

     px = &buf_send;
     py = &read_array;
     imod =0;  /* controller module */
/** initialize **/
     buf_send[0]=0x0;
     buf_send[1]=0x0;
     i=1;
     k=1;
     i = pcie_send(hDev, i, k, px);
// set offline test
     imod=0;
     ichip=1;
     buf_send[0]=(imod<<11)+(ichip<<8)+(mb_cntrl_test_on)+(0x0<<16); //enable offline run on
     i=1;
     k=1;
     i = pcie_send(hDev, i, k, px);
 //disable the run command
     imod=0;
     ichip=1;
     buf_send[0]=(imod<<11)+(ichip<<8)+(mb_cntrl_set_run_off)+(0x0<<16); //enable offline run on
     i=1;
     k=1;
     i = pcie_send(hDev, i, k, px);
 // turn on the Stratix III power supply
     imod=11;
     ichip =1;
     buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_power_add+(0x0<<16); //turn module 11 power on
     i=1;
     k=1;
     i = pcie_send(hDev, i, k, px);
     usleep(200000);  // wait for 200 ms
//     printf(" enable number of loop\n");
//     scanf("%d",&nloop);
     for ( j=0; j<nloop; j++) {
      usleep(10000); // wait for 10ms
      inpf = fopen("/home/ub/feb_fpga","r");
      imod=11;
      ichip=mb_feb_conf_add;
      buf_send[0]=(imod<<11)+(ichip<<8)+0x0+(0x0<<16);  // turn conf to be on
      i=1;
      k=1;
      i = pcie_send(hDev, i, k, px);
//      for (i=0; i<100000; i++) {
//          ik= i%2;
//          dummy1= (ik+i)*(ik+i);
//      }


        /* read data as characters (28941) */
      usleep(1000);   // wait fior a while
      count = 0;
      counta= 0;
      ichip_c = 7; // set ichip_c to stay away from any other command in the
      dummy1 =0;
      while (fread(&charchannel,sizeof(char),1,inpf)==1) {
       carray[count] = charchannel;
       count++;
       counta++;
       if((count%(nsend*2)) == 0) {
//        printf(" loop = %d\n",dummy1);
        buf_send[0] = (imod <<11) +(ichip_c <<8)+ (carray[0]<<16);
        send_array[0] =buf_send[0];
        if(dummy1 <= 5 ) printf(" counta = %d, first word = %x, %x, %x %x %x \n",counta,buf_send[0], carray[0], carray[1]
        ,carray[2], carray[3]);
        for (ij=0; ij< nsend; ij++) {
         if(ij== (nsend-1)) buf_send[ij+1] = carray[2*ij+1]+(0x0<<16);
         else buf_send[ij+1] = carray[2*ij+1]+ (carray[2*ij+2]<<16);
//         buf_send[ij+1] = carray[2*ij+1]+ (carray[2*ij+2]<<16);
         send_array[ij+1] = buf_send[ij+1];
        }
        nword =nsend+1;
        i=1;
//       if(dummy1 == 0)
        ij = pcie_send(hDev, i, nword, px);
        nanosleep(&tim , &tim2);
        dummy1 = dummy1+1;
        count =0;
       }
      }
      if(feof(inpf)) {
       printf("You have reached the end-of-file word count= %d %d\n", counta, count);
       buf_send[0] = (imod <<11) +(ichip_c <<8)+ (carray[0]<<16);
       if ( count > 1) {
        if( ((count-1)%2) ==0) {
         ik =(count-1)/2;
        }
        else {
         ik =(count-1)/2+1;
        }
        ik=ik+2;   // add one more for safety
        printf("ik= %d\n",ik);
        for (ij=0; ij<ik; ij++){
         if(ij == (ik-1)) buf_send[ij+1] = carray[(2*ij)+1]+(((imod<<11)+(ichip<<8)+0x0)<<16);
         else buf_send[ij+1] = carray[(2*ij)+1]+ (carray[(2*ij)+2]<<16);
         send_array[ij+1] = buf_send[ij+1];
        }
       }
       else ik=1;

           for (ij=ik-10; ij< ik+1; ij++) {
            printf("Last data = %d, %x\n",ij,buf_send[ij]);
           }

       nword =ik+1;
       i=1;
       i = pcie_send(hDev, i, nword, px);
      }
      usleep(2000);    // wait for 2ms to cover the packet time plus fpga init time
      fclose(inpf);
      printf(" enter 1 to reset the dram \n");
      scanf("%d",&ik);
 //      ik =1;
      if(ik ==1) {
       imod=11;
       ichip=3;
       buf_send[0]=(imod<<11)+(ichip<<8)+31+(0x1<<16);  // turm the DRAM reset on
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);
       imod=11;
       ichip=3;
       buf_send[0]=(imod<<11)+(ichip<<8)+31+(0x0<<16);  // turm the DRAM reset off
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);

       usleep(5000);    // wait for 5 ms for DRAM to be initialized

       imod=11;
       ichip=3;
       buf_send[0]=(imod<<11)+(ichip<<8)+6+(imod<<16);  // set module number
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);


      }
//
//     work on the ADC -- set reset pulse
//
      imod=11;
      ichip=5;
      buf_send[0]=(imod<<11)+(ichip<<8)+(mb_pmt_adc_reset)+(0x0<<16); // reset goes high
      i=1;
      k=1;
      i = pcie_send(hDev, i, k, px);
      imod=11;
      ichip=5;
      buf_send[0]=(imod<<11)+(ichip<<8)+(mb_pmt_adc_reset)+(0x1<<16); // reset goes low
      i=1;
      k=1;
      i = pcie_send(hDev, i, k, px);
      imod=11;
      ichip=5;
      buf_send[0]=(imod<<11)+(ichip<<8)+(mb_pmt_adc_reset)+(0x0<<16); // reset goes high
      i=1;
      k=1;
      i = pcie_send(hDev, i, k, px);
//
//      enable ADC clock,
//
      imod=11;
      ichip=5;
      buf_send[0]=(imod<<11)+(ichip<<8)+(mb_pmt_spi_add)+(0x7<<16); //set spi address
      i=1;
      k=1;
      i = pcie_send(hDev, i, k, px);
      imod=11;
      ichip=5;
      buf_send[0]=(imod<<11)+(ichip<<8)+(mb_pmt_adc_data_load)+(0xffff<<16); //load spi data, clock gate enable
      i=1;
      k=1;
      i = pcie_send(hDev, i, k, px);
//
//        load fake ADC data pattern  + set MSB 1st
//
      for (is=1; is<7; is++) {
       imod=11;
       ichip=5;
       buf_send[0]=(imod<<11)+(ichip<<8)+(mb_pmt_spi_add)+((is & 0xf)<<16); //set spi address
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);
       imod=11;
       ichip=5;
       buf_send[0]=(imod<<11)+(ichip<<8)+(mb_pmt_adc_data_load)+(0x0300<<16); //sync pattern, b for sync, 7 for skew, 3 for normal
       i=1;
       k=1;
      i = pcie_send(hDev, i, k, px);
       imod=11;
       ichip=5;
       buf_send[0]=(imod<<11)+(ichip<<8)+(mb_pmt_adc_data_load)+(0x1400<<16); //msb 1st
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);
      }
      printf(" enter 1 to continue FPGA ADC receiver reset\n");
      scanf("%d",&ik);
//
//    send FPGA ADC receiver reset
//
      imod=11;
      ichip=3;
      buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_adc_reset+(0x1<<16);  // FPGA ADC receiver reset on
      i=1;
      k=1;
      i = pcie_send(hDev, i, k, px);

      printf(" enter 1 to continue FPGA ADC receiver align\n");
      scanf("%d",&ik);
//
//    send FPGA ADC align
//
      imod=11;
      ichip=3;
      buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_adc_align+(0x0<<16);  // FPGA ADC receiver reset off
      i=1;
      k=1;
      i = pcie_send(hDev, i, k, px);

//       printf(" enter 1 to read system status \n");
//       scanf("%d",&ik);

      ik=1;
      nword =1;
      if(ik ==1) {


       i = pcie_rec(hDev,0,1,nword,iprint,py);     // init the receiver

       imod=11;
       ichip=3;
       buf_send[0]=(imod<<11)+(ichip<<8)+20+(0x0<<16);  // read out status
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);
       py = &read_array;
       i = pcie_rec(hDev,0,2,nword,iprint,py);     // read out 2 32 bits words
       if(iprint == 1) printf("receive data word = %x, %x \n", read_array[0], read_array[1]);
      }

      printf(" enter 1 to continue \n");
      scanf("%d",&ik);

      itrig_delay = 51;
      nword =1;
//
// set frame set to be 1023 --- there will be 1024/8 = 128 adc samples.
//
      imod=0;
      ichip=1;
      iframe= 255;    //1023
      buf_send[0]=(imod<<11)+(ichip<<8)+(mb_cntrl_load_frame)+((iframe & 0xffff)<<16); //enable test mode
      i=1;
      k=1;
      i = pcie_send(hDev, i, k, px);

//
// set to not use any test generator
//
       imod=11;
       ichip=mb_feb_pass_add;
       buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_test_source+(0x0<<16);  // set test source to 0
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);

//
// load trig 1 position relative to the frame..
//
      imod=0;
      ichip=1;
      buf_send[0]=(imod<<11)+(ichip<<8)+(mb_cntrl_load_trig_pos)+((itrig_delay & 0xffff)<<16); //enable test mode
      i=1;
      k=1;
      i = pcie_send(hDev, i, k, px);

      imod=11;
      ichip=3;
      buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_a_nocomp+(0x1<<16);  // set a channel no compression
      i=1;
      k=1;
      i = pcie_send(hDev, i, k, px);

      timesize =4;
      imod=11;
      ichip=3;
      buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_timesize+(timesize<<16);  // set drift time size
      i=1;
      k=1;
      i = pcie_send(hDev, i, k, px);

      a_id =0x20;
      imod=11;
      ichip=3;
      buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_a_id+(a_id<<16);  // set a_id
      i=1;
      k=1;
      i = pcie_send(hDev, i, k, px);

      imod=11;
      ichip=3;
      buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_a_test+(0x1<<16);    // enable a test on
      i=1;
      k=1;
      i = pcie_send(hDev, i, k, px);


      imod=0;
      ichip=1;
      buf_send[0]=(imod<<11)+(ichip<<8)+(mb_cntrl_set_run_on)+(0x0<<16); //enable offline run on
      i=1;
      k=1;
      i = pcie_send(hDev, i, k, px);

      usleep(5000); //wait for 5 ms
      printf(" enter event trigger loop \n");


      for (is=0; is<nevent; is++) {



       imod=0;
       ichip=1;
       buf_send[0]=(imod<<11)+(ichip<<8)+mb_cntrl_set_trig1+(0x0<<16);  // send trigger
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);



//      set module number again to enable the FEB module read back

       imod=11;
       ichip=3;
       buf_send[0]=(imod<<11)+(ichip<<8)+6+(imod<<16);  // set module number
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);

       usleep(5000); // wait for 5 ms


       nword = 5;
       i = pcie_rec(hDev,0,1,nword,iprint,py);     // init the receiver
       imod=11;
       ichip=3;
       buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_a_rdhed+(0x1<<16);  // read a header
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);

       py = &read_array;
       i = pcie_rec(hDev,0,2,nword,iprint,py);     // read out 2 32 bits words
       if(iprint ==1) printf("receive data word = %x, %x, %x, %x, %x\n", read_array[0], read_array[1], read_array[2], read_array[3], read_array[4]);
       nread = (((read_array[1] >>16) & 0xfff)<<12) + (read_array[1] & 0xfff);
       if(iwrite ==1) fprintf(outf," %x, %x, %x, %x, %x\n", read_array[0], read_array[1], read_array[2], read_array[3], read_array[4]);
       if(iprint ==1) printf(" number of data word to read = %d\n",nread);

       ik =  read_array[0] & 0x1f;
       if(iprint ==1) printf(" module number = %d",ik);
       ik =  (read_array[0] >> 5) & 0x7f;
       if(iprint ==1) printf(" data ID = %d",ik);
       ik =  (((read_array[2] >>16) & 0xfff)<<12) + (read_array[2] & 0xfff);
       if(iprint ==1) printf(" event number = %d",ik);
       ik =  (((read_array[3] >>16) & 0xfff)<<12) + (read_array[3] & 0xfff);
       if(iprint ==1) printf(" frame number = %d\n",ik);
       ik =  (((read_array[4] >>16) & 0xfff)<<12) + (read_array[4] & 0xfff);
       if(iprint ==1) printf(" checksum = %x\n",ik);

       if(iprint ==1 ) {
        printf(" enter 1 to continue \n");
        scanf("%d",&ik);
       }
       nword = (nread)/2+1;                    // short words
       i = pcie_rec(hDev,0,1,nword,iprint,py);     // init the receiver

       imod=11;
       ichip=mb_feb_pass_add;
       buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_a_rdbuf+(0x0<<16);  // read a header
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);

       py = &read_array;
       i = pcie_rec(hDev,0,2,nword,iprint,py);     // read out 2 32 bits words

       if(iprint == 1) {
        for (i=0; i< nword; i++) {
         if((i%8) ==0) printf("%4d",i);
         printf(" %8x",read_array[i]);
         if(((i+1)%8) ==0 ) printf("\n");
        }
       }
       if(iwrite == 1) {
        fprintf(outf," %d\n",nword);
        for (i=0; i< nword; i++) {
         if((i%8) ==0) fprintf(outf,"%4d",i);
         fprintf(outf," %8x",read_array[i]);
         if(((i+1)%8) ==0 ) fprintf(outf,"\n");
        }
        if(((i+1)*8) != 0)fprintf(outf,"\n");
       }

       ik=0;
       for (i=0; i< nword; i++) {
        read_array_s[ik] = read_array[i] &0xffff;
        read_array_s[ik+1] = ((read_array[i]>>16) & 0xffff);
        ik=ik+2;
       }

//
//      printout formatted word
//
       if(iprint ==1) {
        iset = 0;
        for(i=0; i< 2*nword; i++) {
         if((read_array_s[i] & 0xf000) == 0x4000) {
           iset=1;
           ncount=0;
           printf(" channel %d\n",(read_array_s[i] & 0xfff));
         }
         else if ((read_array_s[i] & 0xf000) == 0x5000) printf(" channel end %d\n",(read_array_s[i] &0xfff));
         else if (iset ==1) {
           printf(" %4x",read_array_s[i]);
           ncount = ncount+1;
           if((ncount%8) == 0) printf("\n");
         }
         else {
           printf("%x",read_array_s[i]);
           ncount = ncount+1;
           if((ncount%8) == 0) printf("\n");
         }
        }
       }
      }
      if(iprint == 1) {
       printf(" enter 1 to continue \n");
       scanf("%d",&ik);
      }
      if((iwrite == 1)&&((is%100) ==0)) printf("nevent = %d\n",is);

     }

     printf(" 1 to send ADC RESET, 2 turn on sgate , 3 adc chip select\n");
     scanf("%d",&ik);
     if(ik ==1) {
       imod=11;
       ichip=5;
       buf_send[0]=(imod<<11)+(ichip<<8)+(mb_pmt_adc_reset)+(0x1<<16); //pulse reset
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);
       imod=11;
       ichip=5;
       buf_send[0]=(imod<<11)+(ichip<<8)+(mb_pmt_adc_reset)+(0x0<<16); //pulse reset
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);

     }
     else if(ik == 2) {
       imod=11;
       ichip=5;
       buf_send[0]=(imod<<11)+(ichip<<8)+(mb_pmt_spi_add)+(0x7<<16); //set spi address
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);
       imod=11;
       ichip=5;
       buf_send[0]=(imod<<11)+(ichip<<8)+(mb_pmt_adc_data_load)+(0xffff<<16); //load spi data
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);
     }
     else if(ik == 3) {

       imod=11;
       ichip=5;
       buf_send[0]=(imod<<11)+(ichip<<8)+(mb_pmt_adc_reset)+(0x0<<16); // reset goes high
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);
       imod=11;
       ichip=5;
       buf_send[0]=(imod<<11)+(ichip<<8)+(mb_pmt_adc_reset)+(0x1<<16); // reset goes low
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);
       imod=11;
       ichip=5;
       buf_send[0]=(imod<<11)+(ichip<<8)+(mb_pmt_adc_reset)+(0x0<<16); // reset goes high
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);
//
//
//
       imod=11;
       ichip=5;
       buf_send[0]=(imod<<11)+(ichip<<8)+(mb_pmt_spi_add)+(0x7<<16); //set spi address
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);
       imod=11;
       ichip=5;
       buf_send[0]=(imod<<11)+(ichip<<8)+(mb_pmt_adc_data_load)+(0xffff<<16); //load spi data
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);
       scanf("%d",&is);
//
//
//
       imod=11;
       ichip=5;
       buf_send[0]=(imod<<11)+(ichip<<8)+(mb_pmt_spi_add)+(0x1<<16); //set spi address
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);
       imod=11;
       ichip=5;
       buf_send[0]=(imod<<11)+(ichip<<8)+(mb_pmt_adc_data_load)+(0x0b00<<16); //load spi data
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);
     }




    break;

    case 11:
     printf(" XMIT boot test \n");
     printf(" number of boot lopp \n");
     scanf("%d", &nloop);
     printf(" type 1 for neurino event fiber \n");
     scanf("%d", &ineu);
     printf(" number event \n");
     scanf("%d",&nevent);
     printf(" number of fake data word to send \n");
     scanf("%d",&nsend_f);
     printf(" enter 1 to test busy \n");
     scanf("%d",&ibusy_test);
     ifr =0;
     if(ibusy_test == 1) {
//       printf(" number of data word to send \n");
//       scanf("%d",&ibusy_send);
       printf(" number of 16 bits word in FIFO for generate the hold \n");
       scanf("%d",&ihold_word);
     }




// once the fpga is booted we should let system receive fill frame before send any data.
// set system with normal transmitter mode

     dwAddrSpace =2;
     u32Data = 0x20000000;    // initial transmitter, return the hold
     dwOffset = 0x18;
     WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);
     dwAddrSpace =2;
     u32Data = 0x20000000;    // initial transmitter, return the hold
     dwOffset = 0x20;
     WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);

     dwAddrSpace =2;
     u32Data = 0x20000000;
     dwOffset = 0x1c;
     WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);
     dwAddrSpace =2;
     u32Data = 0x20000000;
     dwOffset = 0x24;
     WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);


     dwAddrSpace =2;
     u32Data = 0xfff;    // set mode off with 0xfff...
     dwOffset = 0x28;
     WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);

     imod_xmit=10;
     nsend=500;

     px = &buf_send;
     py = &read_array;
     imod =0;  /* controller module */
/** initialize **/
     buf_send[0]=0x0;
     buf_send[1]=0x0;
     i=1;
     k=1;
     i = pcie_send(hDev, i, k, px);
// set offline test
     imod=0;
     ichip=1;
     buf_send[0]=(imod<<11)+(ichip<<8)+(mb_cntrl_test_on)+(0x0<<16); //enable offline run on
     i=1;
     k=1;
     i = pcie_send(hDev, i, k, px);
 //disable the run command
     imod=0;
     ichip=1;
     buf_send[0]=(imod<<11)+(ichip<<8)+(mb_cntrl_set_run_off)+(0x0<<16); //enable offline run on
     i=1;
     k=1;
     i = pcie_send(hDev, i, k, px);
     for ( j=0; j<nloop; j++) {
      usleep(10000); // wait for 10ms
      inpf = fopen("../../xmit_fpga","r");
      imod=imod_xmit;
      ichip=mb_xmit_conf_add;
      buf_send[0]=(imod<<11)+(ichip<<8)+0x0+(0x0<<16);  // turn conf to be on
      i=1;
      k=1;
      i = pcie_send(hDev, i, k, px);
//      for (i=0; i<100000; i++) {
//          ik= i%2;
//          dummy1= (ik+i)*(ik+i);
//      }


        /* read data as characters (28941) */
      usleep(1000);   // wait fior a while
      count = 0;
      counta= 0;
      ichip_c = 7; // set ichip_c to stay away from any other command in the
      dummy1 =0;
      while (fread(&charchannel,sizeof(char),1,inpf)==1) {
       carray[count] = charchannel;
       count++;
       counta++;
       if((count%(nsend*2)) == 0) {
//        printf(" loop = %d\n",dummy1);
        buf_send[0] = (imod <<11) +(ichip_c <<8)+ (carray[0]<<16);
        send_array[0] =buf_send[0];
        if(dummy1 <= 5 ) printf(" counta = %d, first word = %x, %x, %x %x %x \n",counta,buf_send[0], carray[0], carray[1]
        ,carray[2], carray[3]);
        for (ij=0; ij< nsend; ij++) {
         if(ij== (nsend-1)) buf_send[ij+1] = carray[2*ij+1]+(0x0<<16);
         else buf_send[ij+1] = carray[2*ij+1]+ (carray[2*ij+2]<<16);
//         buf_send[ij+1] = carray[2*ij+1]+ (carray[2*ij+2]<<16);
         send_array[ij+1] = buf_send[ij+1];
        }
        nword =nsend+1;
        i=1;
//       if(dummy1 == 0)
        ij = pcie_send(hDev, i, nword, px);
        nanosleep(&tim , &tim2);
        dummy1 = dummy1+1;
        count =0;
       }
      }
      if(feof(inpf)) {
       printf("You have reached the end-of-file word count= %d %d\n", counta, count);
       buf_send[0] = (imod <<11) +(ichip_c <<8)+ (carray[0]<<16);
       if ( count > 1) {
        if( ((count-1)%2) ==0) {
         ik =(count-1)/2;
        }
        else {
         ik =(count-1)/2+1;
        }
        ik=ik+2;   // add one more for safety
        printf("ik= %d\n",ik);
        for (ij=0; ij<ik; ij++){
         if(ij == (ik-1)) buf_send[ij+1] = carray[(2*ij)+1]+(((imod<<11)+(ichip<<8)+0x0)<<16);
         else buf_send[ij+1] = carray[(2*ij)+1]+ (carray[(2*ij)+2]<<16);
         send_array[ij+1] = buf_send[ij+1];
        }
       }
       else ik=1;

           for (ij=ik-10; ij< ik+1; ij++) {
            printf("Last data = %d, %x\n",ij,buf_send[ij]);
           }

       nword =ik+1;
       i=1;
       i = pcie_send(hDev, i, nword, px);
      }
      usleep(2000);    // wait for 2ms to cover the packet time plus fpga init time
      fclose(inpf);
      printf(" type 1 for continue \n");
      scanf("%d",&i);

/* set tx mode register */

     if(ibusy_test== 1)
      u32Data = 0x00000050;  // set up hold coming back from the XMIT module
     else
      u32Data = 0xfff;
     printf("u32Data = %x\n",u32Data);
     dwOffset = 0x28;
     dwAddrSpace =2;
     WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);
//
//
//
//     dwAddrSpace =2;
//     u32Data =100;
//     dwOffset = 0x28;
//     WDC_ReadAddr32(hDev2, dwAddrSpace, dwOffset, &u32Data);
//     printf("mode control status word = %x\n", u32Data);

//
// now FPGA is booted we can set system to different mode
//
     if(ibusy_test == 1) {
      printf(" set up the hold condition \n");
      dwAddrSpace =2;
      u32Data = 0x8000000;    // initial transmitter, return the hold
      dwOffset = 0x18;
      WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);
      dwAddrSpace =2;
      u32Data = 0x8000000;    // initial transmitter, return the hold
      dwOffset = 0x20;
      WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);
     }

//
// set frame set to be 1023 --- there will be 1024/8 = 128 adc samples.
//
      imod=0;
      ichip=1;
      iframe= 255;    //1023
      buf_send[0]=(imod<<11)+(ichip<<8)+(mb_cntrl_load_frame)+((iframe & 0xffff)<<16); //enable test mode
      i=1;
      k=1;
      i = pcie_send(hDev, i, k, px);
//
// load trig 1 position relative to the frame..
//
      imod=0;
      ichip=1;
      buf_send[0]=(imod<<11)+(ichip<<8)+(mb_cntrl_load_trig_pos)+((itrig_delay & 0xffff)<<16); //enable test mode
      i=1;
      k=1;
      i = pcie_send(hDev, i, k, px);
//
//
//
      imod=0;
      ichip=1;
      buf_send[0]=(imod<<11)+(ichip<<8)+(mb_cntrl_set_run_on)+(0x0<<16); //enable offline run on
      i=1;
      k=1;
      i = pcie_send(hDev, i, k, px);
//
//
//
      imod=imod_xmit;
      ichip=3;
      buf_send[0]=(imod<<11)+(ichip<<8)+mb_xmit_modcount+(0x0<<16);  // set number of module to 1 to enable output
      i=1;
      k=1;
      i = pcie_send(hDev, i, k, px);


      for (is=0; is<nevent; is++) {
       iprint=1;
       nword = 1;
       py = &read_array;
       i = pcie_rec(hDev,0,1,nword,iprint,py);     // init the receiver
       imod=imod_xmit;
       ichip=3;
       buf_send[0]=(imod<<11)+(ichip<<8)+mb_xmit_rdstatus+(0x0<<16);  // read a header
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);
       i = pcie_rec(hDev,0,2,nword,iprint,py);     // read out 2 32 bits words
       printf("receive data word = %x, %x \n", read_array[0], read_array[1]);
//
//
//
       imod=imod_xmit;
       ichip=3;
       if(ineu == 1)
        buf_send[0]=(imod<<11)+(ichip<<8)+mb_xmit_test1+(0x1<<16);  // enable test fiber 1
       else
        buf_send[0]=(imod<<11)+(ichip<<8)+mb_xmit_test2+(0x1<<16);  // enable test fiber 1
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);
//
//
       imod=imod_xmit;
       ichip=3;
       buf_send[0]=(imod<<11)+(ichip<<8)+mb_opt_dig_reset+(0x1<<16);  // set optical reset on
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);
//
//     set up for busy test read 20 words first then reset of the words
//
//     buffer allocation
//           (8 bytes header + 8 bytes trailer) + nsend_f * 4 bytes)/(2 fibers * 2 bytes per allocation on DMA)
//     single word read is done through 64 bits data read per fiber
//     pcie_rec_6_x set up to receive (nword/4+1) * 64 bits read per fiber
//
//
       nword = nsend_f+2;
       for (i=0; i< nword+2; i++) {
         read_array[i]=0;
         read_array1[i]=0;
       }
//
//
       py = &read_array;
       py1 = &read_array1;
       i = pcie_rec_6_1(hDev2,0,1,nword,iprint,py);
       i = pcie_rec_6_2(hDev2,0,1,nword,iprint,py1);
//
//
       imod=imod_xmit;
       ichip=3;
       nsend=nsend_f;
       for (k=0; k<nsend; k++) {
         if(k==0) buf_send[k] = (imod<<11)+(ichip<<8)+mb_xmit_testdata+(k<<16);
         else buf_send[k]=((2*k)-1)+((2*k)<<16);
       }
       i=1;
       k=nsend;
       i = pcie_send(hDev, i, k, px);
       usleep(1000);
//       i=1;
//       k=nsend;
//       if(ibusy_test != 1) i = pcie_send_6_1(hDev2, i, k, px);
       printf(" sending data,, type 1 to continue \n");
       scanf("%d",&i);
//
//     buffer allocation
//           (8 bytes header + 8 bytes trailer) + nsend_f * 4 bytes)/(2 fibers * 2 bytes per allocation on DMA)
//     single word read is done through 64 bits data read per fiber
//     pcie_rec_6_x set up to receive (nword/4+1) * 64 bits read per fiber
//
//
//       nword = nsend_f+2;
       i = pcie_rec_6_1(hDev2,0,2,nword,iprint,py);
       i = pcie_rec_6_2(hDev2,0,2,nword,iprint,py1);

       for (k=0; k< (nword/2); k++) {
//         printf(" %x %x \n", read_array[k], read_array1[k]);
        for (i=0; i<2; i++) {
         ik= 2*k+i;
         if(i==0) read_array_c[ik] = (read_array[k] & 0xffff)+ ((read_array1[k] &0xffff)<<16);
         if(i==1) read_array_c[ik] = ((read_array[k]>>16) & 0xffff)+ (((read_array1[k]>>16) &0xffff)<<16);
//         printf(" 2*k+1 = %d, read_array_c= %x \n", ik, read_array_c[ik]);
        }
       }
//
//
//       printf(" receive 1st block of data, type 1 to continue \n");
//       scanf("%d",&i);

       for (k=0; k < nsend_f+2; k++) {
        printf(" k = %d, read_array_c= %x \n", k, read_array_c[k]);
       }

       dwAddrSpace =2;
       u32Data =100;
       dwOffset = 0x28;
       WDC_ReadAddr32(hDev2, dwAddrSpace, dwOffset, &u32Data);
       printf("mode control status word = %x\n", u32Data);
       printf(" receive data,, type 1 to continue \n");
       scanf("%d",&i);

      }
     }

     break;



    case 12:
     printf(" BNL ADC testing \n");
//     printf(" enter number of words per packet \n");
//     scanf("%d",&nsend);
     printf(" enable number of loop\n");
     scanf("%d",&nloop);
     printf(" number event \n");
     scanf("%d",&nevent);
     printf(" type 1 to use trigger board\n");
     scanf("%d",&itrig_c);
//     printf(" type 1 to write dat to file \n");
//     scanf("%d",&iwrite);
     iwrite =0;
     if(iwrite == 1) {
       iprint = 0;
       outf = fopen("/home/ub/test.dat","w");
     }
     else iprint = 1;

     nsend=500;

     px = &buf_send;
     py = &read_array;
     imod =0;  /* controller module */
/** initialize **/
     buf_send[0]=0x0;
     buf_send[1]=0x0;
     i=1;
     k=1;
     i = pcie_send(hDev, i, k, px);
// set offline test   --- from the controoller
     imod=0;
     ichip=1;
     buf_send[0]=(imod<<11)+(ichip<<8)+(mb_cntrl_test_on)+(0x0<<16); //enable offline run on
     i=1;
     k=1;
     i = pcie_send(hDev, i, k, px);
//
//
//
     imod_trig=4;
     if(itrig_c == 1) {
//disable the run command   --- from the trigger board
       imod=imod_trig;
       buf_send[0]=(imod<<11)+(mb_trig_run)+((0x0)<<16); //set up run off
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);
      }
     else {
//disable the run command   --- from the controller
       imod=0;
       ichip=1;
       buf_send[0]=(imod<<11)+(ichip<<8)+(mb_cntrl_set_run_off)+(0x0<<16); //enable offline run off
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);
     }
 //
 //     set the trigger board deadtime size
 //
     imod_trig=4;
     if(itrig_c == 1) {
 // set offline test off   --- from the controoller
      imod=0;
      ichip=1;
      buf_send[0]=(imod<<11)+(ichip<<8)+(mb_cntrl_test_off)+(0x0<<16); //enable offline run on
      i=1;
      k=1;
      i = pcie_send(hDev, i, k, px);
 //
 //
 //
      imod=imod_trig;
      buf_send[0]=(imod<<11)+(mb_trig_deadtime_size)+((0x1)<<16); //set trigger deadtime size
      i=1;
      k=1;
      i = pcie_send(hDev, i, k, px);
     }
 // turn on the Stratix III power supply
     imod=11;
     ichip =1;
     buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_power_add+(0x0<<16); //turn module 11 power on
     i=1;
     k=1;
     i = pcie_send(hDev, i, k, px);
     usleep(200000);  // wait for 200 ms
//     printf(" enable number of loop\n");
//     scanf("%d",&nloop);
     for ( j=0; j<nloop; j++) {
      usleep(10000); // wait for 10ms
      inpf = fopen("/home/ub/feb_fpga_bnl","r");
      imod=11;
      ichip=mb_feb_conf_add;
      buf_send[0]=(imod<<11)+(ichip<<8)+0x0+(0x0<<16);  // turn conf to be on
      i=1;
      k=1;
      i = pcie_send(hDev, i, k, px);
//      for (i=0; i<100000; i++) {
//          ik= i%2;
//          dummy1= (ik+i)*(ik+i);
//      }


        /* read data as characters (28941) */
      usleep(1000);   // wait fior a while
      count = 0;
      counta= 0;
      ichip_c = 7; // set ichip_c to stay away from any other command in the
      dummy1 =0;
      while (fread(&charchannel,sizeof(char),1,inpf)==1) {
       carray[count] = charchannel;
       count++;
       counta++;
       if((count%(nsend*2)) == 0) {
//        printf(" loop = %d\n",dummy1);
        buf_send[0] = (imod <<11) +(ichip_c <<8)+ (carray[0]<<16);
        send_array[0] =buf_send[0];
        if(dummy1 <= 5 ) printf(" counta = %d, first word = %x, %x, %x %x %x \n",counta,buf_send[0], carray[0], carray[1]
        ,carray[2], carray[3]);
        for (ij=0; ij< nsend; ij++) {
         if(ij== (nsend-1)) buf_send[ij+1] = carray[2*ij+1]+(0x0<<16);
         else buf_send[ij+1] = carray[2*ij+1]+ (carray[2*ij+2]<<16);
//         buf_send[ij+1] = carray[2*ij+1]+ (carray[2*ij+2]<<16);
         send_array[ij+1] = buf_send[ij+1];
        }
        nword =nsend+1;
        i=1;
//       if(dummy1 == 0)
        ij = pcie_send(hDev, i, nword, px);
        nanosleep(&tim , &tim2);
        dummy1 = dummy1+1;
        count =0;
       }
      }
      if(feof(inpf)) {
       printf("You have reached the end-of-file word count= %d %d\n", counta, count);
       buf_send[0] = (imod <<11) +(ichip_c <<8)+ (carray[0]<<16);
       if ( count > 1) {
        if( ((count-1)%2) ==0) {
         ik =(count-1)/2;
        }
        else {
         ik =(count-1)/2+1;
        }
        ik=ik+2;   // add one more for safety
        printf("ik= %d\n",ik);
        for (ij=0; ij<ik; ij++){
         if(ij == (ik-1)) buf_send[ij+1] = carray[(2*ij)+1]+(((imod<<11)+(ichip<<8)+0x0)<<16);
         else buf_send[ij+1] = carray[(2*ij)+1]+ (carray[(2*ij)+2]<<16);
         send_array[ij+1] = buf_send[ij+1];
        }
       }
       else ik=1;

           for (ij=ik-10; ij< ik+1; ij++) {
            printf("Last data = %d, %x\n",ij,buf_send[ij]);
           }

       nword =ik+1;
       i=1;
       i = pcie_send(hDev, i, nword, px);
      }
      usleep(2000);    // wait for 2ms to cover the packet time plus fpga init time
      fclose(inpf);
      printf(" enter 1 to reset the dram \n");
      scanf("%d",&ik);
 //      ik =1;
      if(ik ==1) {
       imod=11;
       ichip=3;
       buf_send[0]=(imod<<11)+(ichip<<8)+31+(0x1<<16);  // turm the DRAM reset on
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);
       imod=11;
       ichip=3;
       buf_send[0]=(imod<<11)+(ichip<<8)+31+(0x0<<16);  // turm the DRAM reset off
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);

       usleep(5000);    // wait for 5 ms for DRAM to be initialized

       imod=11;
       ichip=3;
       buf_send[0]=(imod<<11)+(ichip<<8)+6+(imod<<16);  // set module number
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);


      }
//
//        set adc operatio -- soft reset
//
      for (is=0; is<8; is++) {
       imod=11;
       ichip=5;
       buf_send[0]=(imod<<11)+(ichip<<8)+(mb_pmt_spi_add)+((is & 0xf)<<16); //set spi address
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);
//       printf(" spi port %d \n",is);
//       scanf("%d",&ik);

       imod=11;
       ichip=5;
       buf_send[0]=(imod<<11)+(ichip<<8)+(mb_pmt_adc_data_load)+(0x0300<<16); //1st next word will be overwrite by the next next word
       buf_send[1]=(((0x0)<<13)+(0x0))+((0x3c)<<24)+((0x0)<<16);
//
//  set /w =0, w1,w2 =0, a12-a0 = 0x0, data =0x3c;
//

       i=1;
       k=2;
//       i = pcie_send(hDev, i, k, px);
      }
      usleep(2000);   // sleep for 2ms
      printf(" enter 1 to continue after soft reset\n");
      scanf("%d",&ik);
//
//    the ADC spi stream.. The 16 bits data before the last word is r/w, w1, w2 and 13 bits address
//                         the last 16 bits.upper byte = 8 bits data and lower 8 bits ignored.
//
      for (is=0; is<8; is++) {
       imod=11;
       ichip=5;
       buf_send[0]=(imod<<11)+(ichip<<8)+(mb_pmt_spi_add)+((is & 0xf)<<16); //set spi address
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);
       usleep(2000);   // sleep for 2ms
       printf(" spi port %d \n",is);
//       scanf("%d",&ik);

       imod=11;
       ichip=5;
       buf_send[0]=(imod<<11)+(ichip<<8)+(mb_pmt_adc_data_load)+(0x0300<<16); //1st next word will be overwrite by the next next word
//       buf_send[1]=(((0x0)<<13)+(0xd))+((0xb)<<24)+((0x0)<<16);
       buf_send[1]=(((0x0)<<13)+(0xd))+((0x0)<<24)+((0x0)<<16);
//
//  set /w =0, w1,w2 =0, a12-a0 = 0xd, data =0x0;
//

       i=1;
       k=2;
       i = pcie_send(hDev, i, k, px);
       usleep(2000);   // sleep for 2ms
       printf(" spi port 2nd command %d \n",is);
//       scanf("%d",&ik);

       imod=11;
       ichip=5;
       buf_send[0]=(imod<<11)+(ichip<<8)+(mb_pmt_adc_data_load)+(0x0300<<16); //1st next word will be overwrite by the next next word
       buf_send[1]=(((0x0)<<13)+(0xff))+((0x1)<<24)+((0x0)<<16);
//
//  set /w =0, w1,w2 =0, a12-a0 = 0xd, data =0x0;
//

       i=1;
       k=2;
       i = pcie_send(hDev, i, k, px);
       usleep(2000);   // sleep for 2ms

      }

      printf(" enter 1 to continue FPGA ADC receiver reset\n");
      scanf("%d",&ik);
//
//    send FPGA ADC receiver reset
//
      imod=11;
      ichip=3;
      buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_adc_reset+(0x1<<16);  // FPGA ADC receiver reset on
      i=1;
      k=1;
      i = pcie_send(hDev, i, k, px);


      printf(" enter 1 to continue FPGA ADC receiver align\n");
      scanf("%d",&ik);
//
//    send FPGA ADC align
//
      imod=11;
      ichip=3;
      buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_adc_align+(0x0<<16);  // FPGA ADC receiver reset off
      i=1;
      k=1;
      i = pcie_send(hDev, i, k, px);

//       printf(" enter 1 to read system status \n");
//       scanf("%d",&ik);

      ik=1;
      nword =1;
      if(ik ==1) {


       i = pcie_rec(hDev,0,1,nword,iprint,py);     // init the receiver

       imod=11;
       ichip=3;
       buf_send[0]=(imod<<11)+(ichip<<8)+20+(0x0<<16);  // read out status
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);
       py = &read_array;
       i = pcie_rec(hDev,0,2,nword,iprint,py);     // read out 2 32 bits words
       if(iprint == 1) printf("receive data word = %x, %x \n", read_array[0], read_array[1]);
      }

      printf(" enter 1 to continue \n");
      scanf("%d",&ik);

      itrig_delay = 51;
      nword =1;
//
// set frame set to be 1023 --- there will be 1024/8 = 128 adc samples.
//
      if(itrig_c == 1) {
       imod=imod_trig;
       iframe= 255;    //1023
       buf_send[0]=(imod<<11)+(mb_trig_frame_size)+((iframe & 0xffff)<<16); //set up frame size.
       printf("buf_send =%x\n",buf_send[0]);
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);
      }
      else {
       imod=0;
       ichip=1;
       iframe= 255;    //1023
       buf_send[0]=(imod<<11)+(ichip<<8)+(mb_cntrl_load_frame)+((iframe & 0xffff)<<16); //enable test mode
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);
      }

//
// set to not use any test generator
//
       imod=11;
       ichip=mb_feb_pass_add;
       buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_test_source+(0x0<<16);  // set test source to 0
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);

//
// load trig 1 position relative to the frame..
//
      if(itrig_c != 1) {
       imod=0;
       ichip=1;
       buf_send[0]=(imod<<11)+(ichip<<8)+(mb_cntrl_load_trig_pos)+((itrig_delay & 0xffff)<<16); //enable test mode
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);
      }

      imod=11;
      ichip=3;
      buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_a_nocomp+(0x1<<16);  // set a channel no compression
      i=1;
      k=1;
      i = pcie_send(hDev, i, k, px);

      timesize =4;
      imod=11;
      ichip=3;
      buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_timesize+(timesize<<16);  // set drift time size
      i=1;
      k=1;
      i = pcie_send(hDev, i, k, px);

      a_id =0x20;
      imod=11;
      ichip=3;
      buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_a_id+(a_id<<16);  // set a_id
      i=1;
      k=1;
      i = pcie_send(hDev, i, k, px);

      imod=11;
      ichip=3;
      buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_a_test+(0x1<<16);    // enable a test on
      i=1;
      k=1;
      i = pcie_send(hDev, i, k, px);

      if(itrig_c == 1) {
       imod=imod_trig;
       buf_send[0]=(imod<<11)+(mb_trig_run)+((0x1)<<16); //set up run
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);
      }
      else {
       imod=0;
       ichip=1;
       buf_send[0]=(imod<<11)+(ichip<<8)+(mb_cntrl_set_run_on)+(0x0<<16); //enable offline run on
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);
      }

      printf(" enter 1 to continue (run on sync on \n");
      scanf("%d",&ik);
      usleep(5000); //wait for 5 ms
      printf(" enter event trigger loop \n");


      for (is=0; is<nevent; is++) {


       if(itrig_c == 1) {
        imod =imod_trig;  /* trigger module */
        buf_send[0]=(imod<<11)+mb_trig_pctrig+((0x0)<<16);
        i=1;
        k=1;
        i = pcie_send(hDev, i, k, px);
       }
       else {
        imod=0;
        ichip=1;
        buf_send[0]=(imod<<11)+(ichip<<8)+mb_cntrl_set_trig1+(0x0<<16);  // send trigger
        i=1;
        k=1;
        i = pcie_send(hDev, i, k, px);
       }



//      set module number again to enable the FEB module read back

       imod=11;
       ichip=3;
       buf_send[0]=(imod<<11)+(ichip<<8)+6+(imod<<16);  // set module number
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);

       usleep(5000); // wait for 5 ms


       nword = 5;
       i = pcie_rec(hDev,0,1,nword,iprint,py);     // init the receiver
       imod=11;
       ichip=3;
       buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_a_rdhed+(0x1<<16);  // read a header
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);

       py = &read_array;
       i = pcie_rec(hDev,0,2,nword,iprint,py);     // read out 2 32 bits words
       if(iprint ==1) printf("receive data word = %x, %x, %x, %x, %x\n", read_array[0], read_array[1], read_array[2], read_array[3], read_array[4]);
       nread = (((read_array[1] >>16) & 0xfff)<<12) + (read_array[1] & 0xfff);
       if(iwrite ==1) fprintf(outf," %x, %x, %x, %x, %x\n", read_array[0], read_array[1], read_array[2], read_array[3], read_array[4]);
       if(iprint ==1) printf(" number of data word to read = %d\n",nread);

       ik =  read_array[0] & 0x1f;
       if(iprint ==1) printf(" module number = %d",ik);
       ik =  (read_array[0] >> 5) & 0x7f;
       if(iprint ==1) printf(" data ID = %d",ik);
       ik =  (((read_array[2] >>16) & 0xfff)<<12) + (read_array[2] & 0xfff);
       if(iprint ==1) printf(" event number = %d",ik);
       ik =  (((read_array[3] >>16) & 0xfff)<<12) + (read_array[3] & 0xfff);
       if(iprint ==1) printf(" frame number = %d\n",ik);
       ik =  (((read_array[4] >>16) & 0xfff)<<12) + (read_array[4] & 0xfff);
       if(iprint ==1) printf(" checksum = %x\n",ik);

       if(iprint ==1 ) {
        printf(" enter 1 to continue \n");
        scanf("%d",&ik);
       }
       nword = (nread)/2+1;                    // short words
       i = pcie_rec(hDev,0,1,nword,iprint,py);     // init the receiver

       imod=11;
       ichip=mb_feb_pass_add;
       buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_a_rdbuf+(0x0<<16);  // read a header
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);

       py = &read_array;
       i = pcie_rec(hDev,0,2,nword,iprint,py);     // read out 2 32 bits words

       if(iprint == 1) {
        for (i=0; i< nword; i++) {
         if((i%8) ==0) printf("%4d",i);
         printf(" %8x",read_array[i]);
         if(((i+1)%8) ==0 ) printf("\n");
        }
       }
       if(iwrite == 1) {
        fprintf(outf," %d\n",nword);
        for (i=0; i< nword; i++) {
         if((i%8) ==0) fprintf(outf,"%4d",i);
         fprintf(outf," %8x",read_array[i]);
         if(((i+1)%8) ==0 ) fprintf(outf,"\n");
        }
        if(((i+1)*8) != 0)fprintf(outf,"\n");
       }

       ik=0;
       for (i=0; i< nword; i++) {
        read_array_s[ik] = read_array[i] &0xffff;
        read_array_s[ik+1] = ((read_array[i]>>16) & 0xffff);
        ik=ik+2;
       }

//
//      printout formatted word
//
       if(iprint ==1) {
        iset = 0;
        for(i=0; i< 2*nword; i++) {
         if((read_array_s[i] & 0xf000) == 0x4000) {
           iset=1;
           ncount=0;
           printf(" channel %d\n",(read_array_s[i] & 0xfff));
         }
         else if ((read_array_s[i] & 0xf000) == 0x5000) printf(" channel end %d\n",(read_array_s[i] &0xfff));
         else if (iset ==1) {
           printf(" %4x",read_array_s[i]);
           ncount = ncount+1;
           if((ncount%8) == 0) printf("\n");
         }
         else {
           printf("%x",read_array_s[i]);
           ncount = ncount+1;
           if((ncount%8) == 0) printf("\n");
         }
        }
       }
      }
      if(iprint == 1) {
       printf(" enter 1 to continue \n");
       scanf("%d",&ik);
      }
      if((iwrite == 1)&&((is%100) ==0)) printf("nevent = %d\n",is);

     }

     printf(" 1 to send ADC RESET, 2 turn on sgate , 3 adc chip select\n");
     scanf("%d",&ik);
     if(ik ==1) {
       imod=11;
       ichip=5;
       buf_send[0]=(imod<<11)+(ichip<<8)+(mb_pmt_adc_reset)+(0x1<<16); //pulse reset
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);
       imod=11;
       ichip=5;
       buf_send[0]=(imod<<11)+(ichip<<8)+(mb_pmt_adc_reset)+(0x0<<16); //pulse reset
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);

     }
     else if(ik == 2) {
       imod=11;
       ichip=5;
       buf_send[0]=(imod<<11)+(ichip<<8)+(mb_pmt_spi_add)+(0x7<<16); //set spi address
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);
       imod=11;
       ichip=5;
       buf_send[0]=(imod<<11)+(ichip<<8)+(mb_pmt_adc_data_load)+(0xffff<<16); //load spi data
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);
     }
     else if(ik == 3) {

       imod=11;
       ichip=5;
       buf_send[0]=(imod<<11)+(ichip<<8)+(mb_pmt_adc_reset)+(0x0<<16); // reset goes high
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);
       imod=11;
       ichip=5;
       buf_send[0]=(imod<<11)+(ichip<<8)+(mb_pmt_adc_reset)+(0x1<<16); // reset goes low
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);
       imod=11;
       ichip=5;
       buf_send[0]=(imod<<11)+(ichip<<8)+(mb_pmt_adc_reset)+(0x0<<16); // reset goes high
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);
//
//
//
       imod=11;
       ichip=5;
       buf_send[0]=(imod<<11)+(ichip<<8)+(mb_pmt_spi_add)+(0x7<<16); //set spi address
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);
       imod=11;
       ichip=5;
       buf_send[0]=(imod<<11)+(ichip<<8)+(mb_pmt_adc_data_load)+(0xffff<<16); //load spi data
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);
       scanf("%d",&is);
//
//
//
       imod=11;
       ichip=5;
       buf_send[0]=(imod<<11)+(ichip<<8)+(mb_pmt_spi_add)+(0x1<<16); //set spi address
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);
       imod=11;
       ichip=5;
       buf_send[0]=(imod<<11)+(ichip<<8)+(mb_pmt_adc_data_load)+(0x0b00<<16); //load spi data
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);
     }




    break;


    case 14:
     printf(" feb boot test \n");
     printf(" enable number of loop\n");
     scanf("%d",&nloop);
     printf(" 1 for checking the event \n");
     scanf("%d",&icheck);
     printf(" type 1 to use random number \n");
     scanf("%d",&irand);
//     icheck =0;
//     irand = 0;
     islow_read =0;
     if(icheck != 1) {
      printf(" 1 for print event\n");
      scanf("%d",&iprint);
     }
     else iprint =0;
     printf(" number event \n");
     scanf("%d",&nevent);

//     printf(" enter number of words per packet \n");
//     scanf("%d",&nsend);
     nsend=500;
     imod_xmit=10;

     px = &buf_send;
     py = &read_array;
     imod =0;  /* controller module */
/** initialize **/
     buf_send[0]=0x0;
     buf_send[1]=0x0;
     i=1;
     k=1;
     i = pcie_send(hDev, i, k, px);
// set offline test
     imod=0;
     ichip=1;
     buf_send[0]=(imod<<11)+(ichip<<8)+(mb_cntrl_test_on)+(0x0<<16); //enable offline run on
     i=1;
     k=1;
     i = pcie_send(hDev, i, k, px);
 //disable the run command
     imod=0;
     ichip=1;
     buf_send[0]=(imod<<11)+(ichip<<8)+(mb_cntrl_set_run_off)+(0x0<<16); //enable offline run on
     i=1;
     k=1;
     i = pcie_send(hDev, i, k, px);
 // turn on the Stratix III power supply
     imod=11;
     ichip =1;
     buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_power_add+(0x0<<16); //turn module 11 power on
     i=1;
     k=1;
     i = pcie_send(hDev, i, k, px);
     usleep(200000);  // wait for 200 ms
//     printf(" enable number of loop\n");
//     scanf("%d",&nloop);
     for ( j=0; j<nloop; j++) {
      usleep(10000); // wait for 10ms

//
//    boot up xmit module 1st
//
      printf(" boot xmit module \n");
      inpf = fopen("../../xmit_fpga","r");
      imod=imod_xmit;
      ichip=mb_xmit_conf_add;
      buf_send[0]=(imod<<11)+(ichip<<8)+0x0+(0x0<<16);  // turn conf to be on
      i=1;
      k=1;
      i = pcie_send(hDev, i, k, px);
//      for (i=0; i<100000; i++) {
//          ik= i%2;
//          dummy1= (ik+i)*(ik+i);
//      }


        /* read data as characters (28941) */
      usleep(1000);   // wait fior a while
      count = 0;
      counta= 0;
      ichip_c = 7; // set ichip_c to stay away from any other command in the
      dummy1 =0;
      while (fread(&charchannel,sizeof(char),1,inpf)==1) {
       carray[count] = charchannel;
       count++;
       counta++;
       if((count%(nsend*2)) == 0) {
//        printf(" loop = %d\n",dummy1);
        buf_send[0] = (imod <<11) +(ichip_c <<8)+ (carray[0]<<16);
        send_array[0] =buf_send[0];
        if(dummy1 <= 5 ) printf(" counta = %d, first word = %x, %x, %x %x %x \n",counta,buf_send[0], carray[0], carray[1]
        ,carray[2], carray[3]);
        for (ij=0; ij< nsend; ij++) {
         if(ij== (nsend-1)) buf_send[ij+1] = carray[2*ij+1]+(0x0<<16);
         else buf_send[ij+1] = carray[2*ij+1]+ (carray[2*ij+2]<<16);
//         buf_send[ij+1] = carray[2*ij+1]+ (carray[2*ij+2]<<16);
         send_array[ij+1] = buf_send[ij+1];
        }
        nword =nsend+1;
        i=1;
//       if(dummy1 == 0)
        ij = pcie_send(hDev, i, nword, px);
        nanosleep(&tim , &tim2);
        dummy1 = dummy1+1;
        count =0;
       }
      }
      if(feof(inpf)) {
       printf("You have reached the end-of-file word count= %d %d\n", counta, count);
       buf_send[0] = (imod <<11) +(ichip_c <<8)+ (carray[0]<<16);
       if ( count > 1) {
        if( ((count-1)%2) ==0) {
         ik =(count-1)/2;
        }
        else {
         ik =(count-1)/2+1;
        }
        ik=ik+2;   // add one more for safety
        printf("ik= %d\n",ik);
        for (ij=0; ij<ik; ij++){
         if(ij == (ik-1)) buf_send[ij+1] = carray[(2*ij)+1]+(((imod<<11)+(ichip<<8)+0x0)<<16);
         else buf_send[ij+1] = carray[(2*ij)+1]+ (carray[(2*ij)+2]<<16);
         send_array[ij+1] = buf_send[ij+1];
        }
       }
       else ik=1;

           for (ij=ik-10; ij< ik+1; ij++) {
            printf("Last data = %d, %x\n",ij,buf_send[ij]);
           }

       nword =ik+1;
       i=1;
       i = pcie_send(hDev, i, nword, px);
      }
      usleep(2000);    // wait for 2ms to cover the packet time plus fpga init time
      fclose(inpf);
//
      printf(" xmit done, booting FEM \n");
      scanf("%d",&ik);

//
//    Boot stratix after XMIT module
//
      inpf = fopen("/home/ub/feb_fpga_test","r");
      imod=11;
      ichip=mb_feb_conf_add;
      buf_send[0]=(imod<<11)+(ichip<<8)+0x0+(0x0<<16);  // turn conf to be on
      i=1;
      k=1;
      i = pcie_send(hDev, i, k, px);
//      for (i=0; i<100000; i++) {
//          ik= i%2;
//          dummy1= (ik+i)*(ik+i);
//      }


        /* read data as characters (28941) */
      usleep(1000);   // wait fior a while
      count = 0;
      counta= 0;
      ichip_c = 7; // set ichip_c to stay away from any other command in the
      dummy1 =0;
      while (fread(&charchannel,sizeof(char),1,inpf)==1) {
       carray[count] = charchannel;
       count++;
       counta++;
       if((count%(nsend*2)) == 0) {
//        printf(" loop = %d\n",dummy1);
        buf_send[0] = (imod <<11) +(ichip_c <<8)+ (carray[0]<<16);
        send_array[0] =buf_send[0];
        if(dummy1 <= 5 ) printf(" counta = %d, first word = %x, %x, %x %x %x \n",counta,buf_send[0], carray[0], carray[1]
        ,carray[2], carray[3]);
        for (ij=0; ij< nsend; ij++) {
         if(ij== (nsend-1)) buf_send[ij+1] = carray[2*ij+1]+(0x0<<16);
         else buf_send[ij+1] = carray[2*ij+1]+ (carray[2*ij+2]<<16);
//         buf_send[ij+1] = carray[2*ij+1]+ (carray[2*ij+2]<<16);
         send_array[ij+1] = buf_send[ij+1];
        }
        nword =nsend+1;
        i=1;
//       if(dummy1 == 0)
        ij = pcie_send(hDev, i, nword, px);
        nanosleep(&tim , &tim2);
        dummy1 = dummy1+1;
        count =0;
       }
      }
      if(feof(inpf)) {
       printf("You have reached the end-of-file word count= %d %d\n", counta, count);
       buf_send[0] = (imod <<11) +(ichip_c <<8)+ (carray[0]<<16);
       if ( count > 1) {
        if( ((count-1)%2) ==0) {
         ik =(count-1)/2;
        }
        else {
         ik =(count-1)/2+1;
        }
        ik=ik+2;   // add one more for safety
        printf("ik= %d\n",ik);
        for (ij=0; ij<ik; ij++){
         if(ij == (ik-1)) buf_send[ij+1] = carray[(2*ij)+1]+(((imod<<11)+(ichip<<8)+0x0)<<16);
         else buf_send[ij+1] = carray[(2*ij)+1]+ (carray[(2*ij)+2]<<16);
         send_array[ij+1] = buf_send[ij+1];
        }
       }
       else ik=1;

           for (ij=ik-10; ij< ik+1; ij++) {
            printf("Last data = %d, %x\n",ij,buf_send[ij]);
           }

       nword =ik+1;
       i=1;
       i = pcie_send(hDev, i, nword, px);
      }
      usleep(2000);    // wait for 2ms to cover the packet time plus fpga init time
      fclose(inpf);
//
//    start testing routine
//
       printf(" enter 1 to reset the dram \n");
       scanf("%d",&ik);
 //      ik =1;
       if(ik ==1) {
         imod=11;
         ichip=3;
         buf_send[0]=(imod<<11)+(ichip<<8)+31+(0x1<<16);  // turm the DRAM reset on
         i=1;
         k=1;
         i = pcie_send(hDev, i, k, px);
         imod=11;
         ichip=3;
         buf_send[0]=(imod<<11)+(ichip<<8)+31+(0x0<<16);  // turm the DRAM reset off
         i=1;
         k=1;
         i = pcie_send(hDev, i, k, px);

         usleep(5000);    // wait for 5 ms for DRAM to be initialized

         imod=11;
         ichip=3;
         buf_send[0]=(imod<<11)+(ichip<<8)+6+(imod<<16);  // set module number
         i=1;
         k=1;
         i = pcie_send(hDev, i, k, px);


       }
//       printf(" enter 1 to read system status \n");
//       scanf("%d",&ik);
       ik=1;
       nword =1;
       if(ik ==1) {


         i = pcie_rec(hDev,0,1,nword,iprint,py);     // init the receiver

         imod=11;
         ichip=3;
         buf_send[0]=(imod<<11)+(ichip<<8)+20+(0x0<<16);  // read out status
         i=1;
         k=1;
         i = pcie_send(hDev, i, k, px);
         py = &read_array;
         i = pcie_rec(hDev,0,2,nword,iprint,py);     // read out 2 32 bits words
         printf("receive data word = %x, %x \n", read_array[0], read_array[1]);
       }
//       printf(" enter L1 trigger delay \n");
//       scanf("%d",&itrig_delay);
       itrig_delay = 51;
       nword =1;
//
// set to use test generator 2, set test =2
//
       imod=11;
       ichip=mb_feb_pass_add;
       buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_test_source+(0x2<<16);  // set test source to 2
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);
//
// set frame set to be 1023 --- there will be 1024/8 = 128 adc samples.
//
       imod=0;
       ichip=1;
       iframe= 8192;    //1023
       buf_send[0]=(imod<<11)+(ichip<<8)+(mb_cntrl_load_frame)+((iframe & 0xffff)<<16); //enable test mode
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);
//
//
//
       timesize =50;
       imod=11;
       ichip=3;
       buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_timesize+(timesize<<16);  // set drift time size
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);




//
// load trig 1 position relative to the frame..
//
       imod=0;
       ichip=1;
       buf_send[0]=(imod<<11)+(ichip<<8)+(mb_cntrl_load_trig_pos)+((itrig_delay & 0xffff)<<16); //enable test mode
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);
//
//    start loading the test 2 data memory
//
       imod =11;
       ichip=3;
       for (is=0; is<64; is++) {
        ik = 0x4000+is;                        // load channel address
        buf_send[0]=(imod<<11)+(ichip<<8)+(mb_feb_test_ram_data)+((ik & 0xffff)<<16); //enable test mode
        i = pcie_send(hDev, 1, 1, px);
        ibase = 32*is;
        il = is%8;
        if(il == 0) printf(" loading channel %d\n",is);
        for (ik=0; ik< 256; ik++) {                 // loop over all possible address
         if(irand ==1) ijk = rand() & 0xfff ;        // use random number
         else ijk= (ibase+ik*8) & 0xfff;
         k = 0x8000+ ijk;        // make sure bit 15-12 is clear for the data
         buf_send[0]=(imod<<11)+(ichip<<8)+(mb_feb_test_ram_data)+((k & 0xffff)<<16); //enable test mode
         i = pcie_send(hDev, 1, 1, px);
         send_array[is*256+ik]=ijk;           //load up data map
        }
       }

       imod=11;
       ichip=3;
       buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_a_nocomp+(0x1<<16);  // set a channel no compression
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);

       a_id =0x20;
       imod=11;
       ichip=3;
       buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_a_id+(a_id<<16);  // set a_id
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);

       imod=11;
       ichip=4;
       buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_a_id+(a_id<<16);  // set a_id
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);

       imod=11;
       ichip=3;
       buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_a_test+(0x1<<16);    // enable a test on
       i=1;
       k=1;
       if(islow_read == 1) i = pcie_send(hDev, i, k, px);


       imod=11;
       ichip=4;
       buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_lst_on+(0x0<<16);    // set last module on
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);

       imod=11;
       ichip=4;
       buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_rxreset+(0x0<<16);    // reset LINKIN DPA
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);

//
//     set up xmit module  -- module count
//
       imod=imod_xmit;
       ichip=3;
       buf_send[0]=(imod<<11)+(ichip<<8)+mb_xmit_modcount+(0x0<<16);  // set number of module to 1 to enable output
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);
//
//     rest optical
//
       imod=imod_xmit;
       ichip=3;
       buf_send[0]=(imod<<11)+(ichip<<8)+mb_opt_dig_reset+(0x1<<16);  // set optical reset on
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);
//
//     enable teken one data pass
//
       imod=imod_xmit;
       ichip=3;
       buf_send[0]=(imod<<11)+(ichip<<8)+mb_xmit_enable_1+(0x1<<16);  // enable token 1 pass
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);
//
//
       printf(" enter 1 to reset the DPA \n");
       scanf("%d",&ik);

//
//     reset XMIT LINK IN DPA
//
       imod=imod_xmit;
       ichip=3;
       buf_send[0]=(imod<<11)+(ichip<<8)+mb_xmit_link_reset+(0x1<<16);  //  reset XMIT LINK IN DPA
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);
//
//     wait for 10ms just in case
//
       usleep(10000);
//
//     reset XMIT FIFO reset
//
       imod=imod_xmit;
       ichip=3;
       buf_send[0]=(imod<<11)+(ichip<<8)+mb_xmit_dpa_fifo_reset+(0x1<<16);  //  reset XMIT LINK IN DPA
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);

//
//
//
       printf(" enter 1 to set the RUN on \n");
       scanf("%d",&ik);

       imod=0;
       ichip=1;
       buf_send[0]=(imod<<11)+(ichip<<8)+(mb_cntrl_set_run_on)+(0x0<<16); //enable offline run on
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);

       for (is=0; is<1; is++) {
//
//      test re-align circuit
//
        imod=imod_xmit;
        ichip=3;
        buf_send[0]=(imod<<11)+(ichip<<8)+mb_xmit_dpa_word_align+(0x1<<16);  //  send alignment pulse
        i=1;
        k=1;
        i = pcie_send(hDev, i, k, px);

        printf(" enter 1 to set continue on re-align circuit \n");
        scanf("%d",&ik);
       }

       usleep(5000); //wait for 5 ms


       for (is=0; is<nevent; is++) {
        nword =391;
        nword = (12+ timesize*3*64+2)/2;  // 12 word heaqder + 2 trailer
        nread = (nword/2)+1;
        if((nword%2) ==0) nread = nword/2;
        for (i=0; i< nread; i++) {
         read_array[i]=0;
         read_array1[i]=0;
        }
        py = &read_array;
        py1 = &read_array1;
        i = pcie_rec_6_1(hDev2,0,1,nword,iprint,py);
        i = pcie_rec_6_2(hDev2,0,1,nword,iprint,py1);

        imod=0;
        ichip=1;
        buf_send[0]=(imod<<11)+(ichip<<8)+mb_cntrl_set_trig1+(0x0<<16);  // send trigger
        i=1;
        k=1;
        i = pcie_send(hDev, i, k, px);

        usleep(5000);
        i = pcie_rec_6_1(hDev2,0,2,nword,iprint,py);
        i = pcie_rec_6_2(hDev2,0,2,nword,iprint,py1);
        for (ik=0; ik< nread; ik++) {
          k=ik*4;
          read_array_s[k] = (read_array[ik] & 0xffff);
          read_array_s[k+1]= (read_array1[ik] &0xffff);
          read_array_s[k+2] = ((read_array[ik]>>16) & 0xffff);
          read_array_s[k+3] = ((read_array1[ik]>>16) & 0xffff);
        }
        if(iprint == 1) {
         for (ik=0; ik<nword*2; ik++){
          printf(" %4x", read_array_s[ik]);
          if(((ik+1)%8) ==0) printf("\n");
         }
         printf("\n");
         printf(" packet header = %8x\n", (read_array_s[0]+ (read_array_s[1] << 16)));
         printf(" module header = %4x\n", read_array_s[2]);
         printf(" address word = %4x, aid = %2x, module numebr %3d\n", read_array_s[3], ((read_array_s[3]>>5) &0x7f), (read_array_s[3] &0x1f));
         ik= (read_array_s[4]<<16)+ (read_array_s[5]);
         k=  ((read_array_s[4] & 0xfff) << 12)+ (read_array_s[5] & 0xfff);
         printf(" word count word = %8x, word count = %8d \n", ik,k);
         ik= (read_array_s[6]<<16)+ (read_array_s[7]);
         k=  ((read_array_s[6] & 0xfff) << 12)+ (read_array_s[7] & 0xfff);
         printf(" event number word = %8x, event number = %8d \n", ik,k);
         ik= (read_array_s[8]<<16)+ (read_array_s[9]);
         k=  ((read_array_s[8] & 0xfff) << 12)+ (read_array_s[9] & 0xfff);
         printf(" frame number word = %8x, frame number = %8d \n", ik,k);
         ik= (read_array_s[10]<<16)+ (read_array_s[11]);
         k=  ((read_array_s[10] & 0xfff) << 12)+ (read_array_s[11] & 0xfff);
         printf(" checksum word = %8x, checksum = %8x \n", ik,k);
         k=0;
         ijk=(nword*2)-2;
         checksum=0;
         for (ik=12; ik< ijk; ik++) {
          checksum =checksum + read_array_s[ik];
          if((read_array_s[ik] & 0x7000) == 0x4000) {
            printf(" chanenl %d\n", (read_array_s[ik] & 0xff));
            k=0;
          }
          else if ((read_array_s[ik] & 0x7000) == 0x5000) printf(" chanenl end %d\n", (read_array_s[ik] &0xff));
          else {
            k=k+1;
            printf(" %4x",(read_array_s[ik]&0xfff));
          }
          if((k%8) ==0) printf("\n");
         }
         printf(" packet trailer = %8x, checksum = %8x\n", (read_array_s[(nword*2)-2]+ (read_array_s[(2*nword)-1] << 16)), checksum);
        }

        if(icheck ==1 ){
         if((read_array_s[0]+ (read_array_s[1] << 16)) != 0xffffffff)
           printf(" wrong packet header, event = %6d, %8x\n", is,(read_array_s[0]+ (read_array_s[1] << 16)));
         if(read_array_s[2] != 0xffff)
           printf(" wrong module header= %6d %4x\n", is, read_array_s[2]);
         k=  ((read_array_s[6] & 0xfff) << 12)+ (read_array_s[7] & 0xfff);
         if(k != is) printf(" wrong event number word = %6d, %8d \n",is,k);
         if((2*nword) == ((64*timesize*3)+14)){                             // 14 = 2 header +10 header+ 2 trailer
          for (i=0; i<64; i++){
           k=i*(timesize*3)+12;                                             // 12 = 2 header + 10 header
           ij= i*256;
           if(read_array_s[k] != (0x4000+i))
            printf(" first word error, event %d data received %x, data expected %x\n", is, read_array_s[k], (0x4000+i));
           for (ik=0; ik< ((3*timesize)-2); ik++) {
            dummy1 = (4-timesize)+ik;
            if(dummy1 <= -1) iv = 256+dummy1;  // deal with fake data pointer wrap around
            else iv =dummy1;
            iv =iv+ij;
//            printf("i = %d, ik = %d, iv = %d, dummy1 = %d k = %d\n",i,ik, iv, dummy1,k);
//            scanf("%d",&is);
            if(read_array_s[k+1+ik] != send_array[iv])
             printf(" data word error, event %d ch = %d, received %x, expected %x\n",is,i,read_array_s[k+1+ik], send_array[iv]);
//             scanf("%d",&is);
           }
           k=(i+1)*(timesize*3)-1+12;
           if(read_array_s[k] != (0x5000+i))
            printf(" last word error, event %d data received %x, data expected %x\n", is, read_array_s[k], (0x5000+i));
          }
         }
         else {
          printf(" event %d number word receive = %d, expected=  %d \n", is, (2*nword), (64*timesize*3));
         }
        }
       if(icheck ==1) {
          k = is%50;
          if(k ==0) {
            printf("event %d\n",is);
//            printf(" type 1 to continue \n");
//            scanf("%d",&iv);
          }  
       }

       if(iprint == 1) scanf("%d",&ik);
       }

       imod=0;
       ichip=1;
       buf_send[0]=(imod<<11)+(ichip<<8)+(mb_cntrl_set_run_off)+(0x0<<16); //enable offline run off
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);
       scanf("%d",&ik);
      }

     break;


    case 15:
     printf(" feb boot test \n");
     printf(" enable number of loop\n");
     scanf("%d",&nloop);
//     printf(" 1 for checking the event \n");
//     scanf("%d",&icheck);
//     printf(" type 1 to use random number \n");
//     scanf("%d",&irand);
     icheck =0;
     irand = 0;
     islow_read =0;
//     if(icheck != 1) {
//      printf(" 1 for print event\n");
//      scanf("%d",&iprint);
//     }
//     else iprint =0;
     iprint = 1;
     printf(" number event \n");
     scanf("%d",&nevent);

//     printf(" enter number of words per packet \n");
//     scanf("%d",&nsend);
     nsend=500;
     imod_xmit=10;

     px = &buf_send;
     py = &read_array;
//
//   controller
//
     imod =0;  /* controller module */
/** initialize **/
     buf_send[0]=0x0;
     buf_send[1]=0x0;
     i=1;
     k=1;
     i = pcie_send(hDev, i, k, px);
// set offline test
     imod=0;
     ichip=1;
     buf_send[0]=(imod<<11)+(ichip<<8)+(mb_cntrl_test_on)+(0x0<<16); //enable offline run on
     i=1;
     k=1;
     i = pcie_send(hDev, i, k, px);
 //disable the run command
     imod=0;
     ichip=1;
     buf_send[0]=(imod<<11)+(ichip<<8)+(mb_cntrl_set_run_off)+(0x0<<16); //enable offline run on
     i=1;
     k=1;
     i = pcie_send(hDev, i, k, px);

// turn on the Stratix III power supply for module 11
     imod=11;
     ichip =1;
     buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_power_add+(0x1<<16); //turn module 11 power on
     i=1;
     k=1;
     i = pcie_send(hDev, i, k, px);
     printf(" turn on stratix III power for module 11 \n");
//     scanf("%d",&ik);

// turn on the Stratix III power supply for module 12
     imod=12;
     ichip =1;
     buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_power_add+(0x1<<16); //turn module 11 power on
     i=1;
     k=1;
     i = pcie_send(hDev, i, k, px);
     printf(" turn on stratix III power for module 11 \n");
//     scanf("%d",&ik);
     usleep(200000);  // wait for 200 ms

//     printf(" enable number of loop\n");
//     scanf("%d",&nloop);
     for ( j=0; j<nloop; j++) {
      usleep(10000); // wait for 10ms
//
//    boot up xmit module 1st
//
      printf(" boot xmit module \n");
      i = xmit_boot(hDev, imod_xmit);
      printf(" xmit done, booting FEM \n");
      scanf("%d",&ik);

//
//    Boot stratix after XMIT module
//    module 11
//
      imod = 11;
      i = fem_boot(hDev, imod) ;
      printf(" boot FEM module 11\n");
      scanf("%d",&ik);
//
//    module 12;
//
      imod = 12;
      i = fem_boot(hDev, imod);
      printf(" boot FEM module 12\n");
      scanf("%d",&ik);
//
//    start testing routine
//
      printf(" enter 1 to reset the dram \n");
      scanf("%d",&ik);
      if(ik ==1) {
       for (is=0; is<2; is++) {
 //      ik =1;
         imod=11+is;
         ichip=3;
         buf_send[0]=(imod<<11)+(ichip<<8)+31+(0x1<<16);  // turm the DRAM reset on
         i=1;
         k=1;
         i = pcie_send(hDev, i, k, px);
         ichip=3;
         buf_send[0]=(imod<<11)+(ichip<<8)+31+(0x0<<16);  // turm the DRAM reset off
         i=1;
         k=1;
         i = pcie_send(hDev, i, k, px);
       }

       usleep(5000);    // wait for 5 ms for DRAM to be initialized
       for (is=0; is<2; is++) {
         imod=11+is;
         ichip=3;
         buf_send[0]=(imod<<11)+(ichip<<8)+6+(imod<<16);  // set module number
         i=1;
         k=1;
         i = pcie_send(hDev, i, k, px);

         nword =3;
         i = pcie_rec_16b(hDev,0,1,nword,iprint,py);     // init the receiver

         ichip=3;
         buf_send[0]=(imod<<11)+(ichip<<8)+20+((imod<<11)<<16);  // read out status
         i=1;
         k=1;
         i = pcie_send(hDev, i, k, px);
         py = &read_array;
         i = pcie_rec_16b(hDev,0,2,nword,iprint,py);     // read out 2 32 bits words

         printf("module %d receive data word = %x, %x \n", (is+11), read_array[0], read_array[1]);

       }
      }
//       printf(" enter 1 to read system status \n");
//       scanf("%d",&ik);
//       printf(" enter L1 trigger delay \n");
//       scanf("%d",&itrig_delay);
      itrig_delay = 51;
      nword =1;

//
// set frame set to be 1023 --- there will be 1024/8 = 128 adc samples.
//
      imod=0;
      ichip=1;
      iframe= 255;    //1023
      buf_send[0]=(imod<<11)+(ichip<<8)+(mb_cntrl_load_frame)+((iframe & 0xffff)<<16); //enable test mode
      i=1;
      k=1;
      i = pcie_send(hDev, i, k, px);


//
// load trig 1 position relative to the frame..
//
      imod=0;
      ichip=1;
      buf_send[0]=(imod<<11)+(ichip<<8)+(mb_cntrl_load_trig_pos)+((itrig_delay & 0xffff)<<16); //enable test mode
      i=1;
      k=1;
      i = pcie_send(hDev, i, k, px);

      for (ib=0; ib<2; ib++) {
//
// set to use test generator 2, set test =2
//
       imod=11+ib;
       ichip=mb_feb_pass_add;
       buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_test_source+(0x2<<16);  // set test source to 2
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);


//
//    start loading the test 2 data memory
//
       ichip=3;
       for (is=0; is<64; is++) {
        ik = 0x4000+is;                        // load channel address
        buf_send[0]=(imod<<11)+(ichip<<8)+(mb_feb_test_ram_data)+((ik & 0xffff)<<16); //enable test mode
        i = pcie_send(hDev, 1, 1, px);
        ibase = 32*is+(0x4*ib);
        il = is%8;
        if(il == 0) printf(" loading channel %d\n",is);
        for (ik=0; ik< 256; ik++) {                 // loop over all possible address
         if(irand ==1) ijk = rand() & 0xfff ;        // use random number
         else ijk= (ibase+ik*8) & 0xfff;
         k = 0x8000+ ijk;        // make sure bit 15-12 is clear for the data
         buf_send[0]=(imod<<11)+(ichip<<8)+(mb_feb_test_ram_data)+((k & 0xffff)<<16); //enable test mode
         i = pcie_send(hDev, 1, 1, px);
         send_array[is*256+ik]=ijk;           //load up data map
        }
       }

       ichip=3;
       buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_a_nocomp+(0x1<<16);  // set a channel no compression
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);

       timesize =4;
       ichip=3;
       buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_timesize+(timesize<<16);  // set drift time size
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);

       a_id =0x20;
       ichip=3;
       buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_a_id+(a_id<<16);  // set a_id
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);

       ichip=4;
       buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_a_id+(a_id<<16);  // set a_id
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);


       ichip=3;
       buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_a_test+(0x1<<16);    // enable a test on
       i=1;
       k=1;
       if(islow_read == 1) i = pcie_send(hDev, i, k, px);

     }
      printf(" sending last \n");
      scanf("%d",&ik);
      imod=11;
      ichip=4;
      buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_lst_off+(0x0<<16);    // set last module on
//      buf_send[0]=(imod<<11)+(ichip<<8)+(0x0<<16);    // set last module on
      i=1;
      k=1;
      i = pcie_send(hDev, i, k, px);

      imod=12;
      ichip=4;
      buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_lst_on+(0x1<<16);    // set last module on
      i=1;
      k=1;
      i = pcie_send(hDev, i, k, px);
      printf(" send last \n");
      scanf("%d",&ik);


      for (ib=0; ib<2; ib++) {
       imod=11+ib;
       ichip=4;
       buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_rxreset+(0x0<<16);    // reset LINKIN DPA
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);
       printf(" link reset done, module = %d \n", (ib+11));
       scanf("%d",&ik);
      }
//
//
//
      imod=11;
      ichip=4;
      buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_align+(0x0<<16);    // reset LINKIN DPA
      i=1;
      k=1;
      i = pcie_send(hDev, i, k, px);
//
      printf(" link align done \n");
      scanf("%d",&ik);

//
//     set up xmit module  -- module count
//
      imod=imod_xmit;
      ichip=3;
      buf_send[0]=(imod<<11)+(ichip<<8)+mb_xmit_modcount+(0x1<<16);  // set number of module to 2 to enable output
      i=1;
      k=1;
      i = pcie_send(hDev, i, k, px);
//
//     rest optical
//
      imod=imod_xmit;
      ichip=3;
      buf_send[0]=(imod<<11)+(ichip<<8)+mb_opt_dig_reset+(0x1<<16);  // set optical reset on
      i=1;
      k=1;
      i = pcie_send(hDev, i, k, px);
//
//     enable teken one data pass
//
      imod=imod_xmit;
      ichip=3;
      buf_send[0]=(imod<<11)+(ichip<<8)+mb_xmit_enable_1+(0x1<<16);  // enable token 1 pass
      i=1;
      k=1;
      i = pcie_send(hDev, i, k, px);
//
//
      printf(" enter 1 to reset the DPA \n");
      scanf("%d",&ik);

//
//     reset XMIT LINK IN DPA
//
      imod=imod_xmit;
      ichip=3;
      buf_send[0]=(imod<<11)+(ichip<<8)+mb_xmit_link_reset+(0x1<<16);  //  reset XMIT LINK IN DPA
      i=1;
      k=1;
      i = pcie_send(hDev, i, k, px);
//
//     wait for 10ms just in case
//
      usleep(10000);
//
//     reset XMIT FIFO reset
//
      imod=imod_xmit;
      ichip=3;
      buf_send[0]=(imod<<11)+(ichip<<8)+mb_xmit_dpa_fifo_reset+(0x1<<16);  //  reset XMIT LINK IN DPA
      i=1;
      k=1;
      i = pcie_send(hDev, i, k, px);

//
//
//
      printf(" enter 1 to set the RUN on \n");
      scanf("%d",&ik);

      imod=0;
      ichip=1;
      buf_send[0]=(imod<<11)+(ichip<<8)+(mb_cntrl_set_run_on)+(0x0<<16); //enable offline run on
      i=1;
      k=1;
      i = pcie_send(hDev, i, k, px);

      for (is=0; is<1; is++) {
//
//      test re-align circuit
//
        imod=imod_xmit;
        ichip=3;
        buf_send[0]=(imod<<11)+(ichip<<8)+mb_xmit_dpa_word_align+(0x1<<16);  //  send alignment pulse
        i=1;
        k=1;
        i = pcie_send(hDev, i, k, px);

        printf(" enter 1 to set continue on re-align circuit \n");
        scanf("%d",&ik);
      }

      usleep(5000); //wait for 5 ms


      for (is=0; is<nevent; is++) {
        nword =780;
        nread = (nword/2)+1;
        if((nword%2) ==0) nread = nword/2;
        for (i=0; i< nread; i++) {
         read_array[i]=0;
         read_array1[i]=0;
        }
        py = &read_array;
        py1 = &read_array1;
        i = pcie_rec_6_1(hDev2,0,1,nword,iprint,py);
        i = pcie_rec_6_2(hDev2,0,1,nword,iprint,py1);

        imod=0;
        ichip=1;
        buf_send[0]=(imod<<11)+(ichip<<8)+mb_cntrl_set_trig1+(0x0<<16);  // send trigger
        i=1;
        k=1;
        i = pcie_send(hDev, i, k, px);

        usleep(5000);
        i = pcie_rec_6_1(hDev2,0,2,nword,iprint,py);
        i = pcie_rec_6_2(hDev2,0,2,nword,iprint,py1);
        for (ik=0; ik< nread; ik++) {
          k=ik*4;
          read_array_s[k] = (read_array[ik] & 0xffff);
          read_array_s[k+1]= (read_array1[ik] &0xffff);
          read_array_s[k+2] = ((read_array[ik]>>16) & 0xffff);
          read_array_s[k+3] = ((read_array1[ik]>>16) & 0xffff);
        }
        if(iprint == 1) {
         for (ik=0; ik<nword*2; ik++){
          printf(" %4x", read_array_s[ik]);
          if(((ik+1)%8) ==0) printf("\n");
         }
         printf("\n");
         printf(" packet header = %8x\n", (read_array_s[0]+ (read_array_s[1] << 16)));
         printf(" module header = %4x\n", read_array_s[2]);
         printf(" address word = %4x, aid = %2x, module numebr %3d\n", read_array_s[3], ((read_array_s[3]>>5) &0x7f), (read_array_s[3] &0x1f));
         ik= (read_array_s[4]<<16)+ (read_array_s[5]);
         k=  ((read_array_s[4] & 0xfff) << 12)+ (read_array_s[5] & 0xfff);
         printf(" word count word = %8x, word count = %8d \n", ik,k);
         ik= (read_array_s[6]<<16)+ (read_array_s[7]);
         k=  ((read_array_s[6] & 0xfff) << 12)+ (read_array_s[7] & 0xfff);
         printf(" event number word = %8x, event number = %8d \n", ik,k);
         ik= (read_array_s[8]<<16)+ (read_array_s[9]);
         k=  ((read_array_s[8] & 0xfff) << 12)+ (read_array_s[9] & 0xfff);
         printf(" frame number word = %8x, frame number = %8d \n", ik,k);
         ik= (read_array_s[10]<<16)+ (read_array_s[11]);
         k=  ((read_array_s[10] & 0xfff) << 12)+ (read_array_s[11] & 0xfff);
         printf(" checksum word = %8x, checksum = %8x \n", ik,k);
         k=0;
         ijk=(nword*2)-2;
         checksum=0;
         for (ik=12; ik< ijk; ik++) {
          checksum =checksum + read_array_s[ik];
          if((read_array_s[ik] & 0x7000) == 0x4000) {
            printf(" chanenl %d\n", (read_array_s[ik] & 0xff));
            k=0;
          }
          else if ((read_array_s[ik] & 0x7000) == 0x5000) printf(" chanenl end %d\n", (read_array_s[ik] &0xff));
          else {
            k=k+1;
            printf(" %4x",(read_array_s[ik]&0xfff));
          }
          if((k%8) ==0) printf("\n");
         }
         printf(" packet trailer = %8x, checksum = %8x\n", (read_array_s[(nword*2)-2]+ (read_array_s[(2*nword)-1] << 16)), checksum);
        }


        if(icheck ==1 ){
         if((read_array_s[0]+ (read_array_s[1] << 16)) != 0xffffffff)
           printf(" wrong packet header, event = %6d, %8x\n", is,(read_array_s[0]+ (read_array_s[1] << 16)));
         if(read_array_s[2] != 0xffff)
           printf(" wrong module header= %6d %4x\n", is, read_array_s[2]);
         k=  ((read_array_s[6] & 0xfff) << 12)+ (read_array_s[7] & 0xfff);
         if((k-2) != is) printf(" wrong event number word = %6d, %8d \n",is,k);
         if((2*nword) == ((64*timesize*3)+14)){                             // 14 = 2 header +10 header+ 2 trailer
          for (i=0; i<64; i++){
           k=i*(timesize*3)+12;                                             // 12 = 2 header + 10 header
           ij= i*256;
           if(read_array_s[k] != (0x4000+i))
            printf(" first word error, event %d data received %x, data expected %x\n", is, read_array_s[k], (0x4000+i));
           for (ik=0; ik< ((3*timesize)-2); ik++) {
            if(read_array_s[k+1+ik] != send_array[ij+ik])
             printf(" data word error, event %d ch = %d, received %x, expected %x\n",is,i,read_array_s[k+1+ik], send_array[ij+ik]);
           }
           k=(i+1)*(timesize*3)-1+12;
           if(read_array_s[k] != (0x5000+i))
            printf(" last word error, event %d data received %x, data expected %x\n", is, read_array_s[k], (0x5000+i));
          }
         }
         else {
          printf(" event %d number word receive = %d, expected=  %d \n", is, (2*nword), (64*timesize*3));
         }
        }
        if(icheck ==1) {
          k = is%1000;
          if(k ==0) printf("event %d\n",is);
        }

        if(iprint == 1) scanf("%d",&ik);
       }

       imod=0;
       ichip=1;
       buf_send[0]=(imod<<11)+(ichip<<8)+(mb_cntrl_set_run_off)+(0x0<<16); //enable offline run off
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);
       scanf("%d",&ik);

     }

     break;

    case 16:
     printf(" trigger borad test \n");
     printf(" enable number of loop\n");
     scanf("%d",&nloop);
     printf(" enter 1 to pulse test, 2 for GPS readout test, 3 for trigger data opt out \n");
     scanf("%d",&is);
     if(is == 1) {
      printf(" enter pulse 1 delay \n");
      scanf("%d", &p1_delay);
      printf(" enter pulse 1 width \n");
      scanf("%d", &p1_width);
      printf(" enter pulse 2 delay \n");
      scanf("%d", &p2_delay);
      printf(" enter pulse 2 width \n");
      scanf("%d", &p2_width);
      printf(" enter pulse 2 delay \n");
      scanf("%d", &p3_delay);
      printf(" enter pulse 2 width \n");
      scanf("%d", &p3_width);

      printf(" enter trigger delay (<7)\n");
      scanf("%d", &pulse_trig_delay);
//      printf(" enter pulse 2 delay \n");
//      scanf("%d", p2_delay);
//      printf(" enter pulse 2 width \n");
//      scanf("%d", p2_width);
     }
//     printf(" 1 for checking the event \n");
//     scanf("%d",&icheck);
//     printf(" type 1 to use random number \n");
//     scanf("%d",&irand);
     icheck =0;
     irand = 0;
     islow_read =0;
//     if(icheck != 1) {
//      printf(" 1 for print event\n");
//      scanf("%d",&iprint);
//     }
//     else iprint =0;
//     iprint = 1;
//     printf(" number event \n");
//     scanf("%d",&nevent);

//     printf(" enter number of words per packet \n");
//     scanf("%d",&nsend);
     nsend=500;
     imod_trig=18;

     px = &buf_send;
     py = &read_array;
//
//   controller
//
     imod =0;  /* controller module */
/** initialize **/
     buf_send[0]=0x0;
     buf_send[1]=0x0;
     i=1;
     k=1;
     i = pcie_send(hDev, i, k, px);

     imod=imod_trig;
     buf_send[0]=(imod<<11)+(mb_trig_deadtime_size)+((0x1)<<16); //set trigger deadtime size
     i=1;
     k=1;
     i = pcie_send(hDev, i, k, px);

//    for (j=1; j<nloop; j++) {
      imod=imod_trig;
      iframe= 255;    //1023
      buf_send[0]=(imod<<11)+(mb_trig_frame_size)+((iframe & 0xffff)<<16); //set up frame size.
      i=1;
      k=1;
      i = pcie_send(hDev, i, k, px);

      usleep(5000);
      imod=imod_trig;         //fack module
      iframe= 255;    //1023
      buf_send[0]=(imod<<11)+(50)+((iframe & 0xffff)<<16); //set up frame size.
      i=1;
      k=1;
      i = pcie_send(hDev, i, k, px);
//     }


     imod=imod_trig;
     buf_send[0]=(imod<<11)+(mb_trig_run)+((0x1)<<16); //set up run
     i=1;
     k=1;
     i = pcie_send(hDev, i, k, px);

     if(is == 1) {
      for (j=0; j<nloop; j++) {
       imod = imod_trig;
       buf_send[0]=(imod<<11)+(mb_trig_p1_delay)+((p1_delay)<<16); // set up p1 delay;
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);

       imod = imod_trig;
       buf_send[0]=(imod<<11)+(mb_trig_p1_width)+((p1_width)<<16); // set up p1 width;
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);

       imod = imod_trig;
       buf_send[0]=(imod<<11)+(mb_trig_p2_delay)+((p2_delay)<<16); // set up p2 delay;
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);

       imod = imod_trig;
       buf_send[0]=(imod<<11)+(mb_trig_p2_width)+((p2_width)<<16); // set up p2 width;
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);

       imod = imod_trig;
       buf_send[0]=(imod<<11)+(mb_trig_p3_delay)+((p3_delay)<<16); // set up p2 delay;
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);

       imod = imod_trig;
       buf_send[0]=(imod<<11)+(mb_trig_p3_width)+((p3_width)<<16); // set up p2 width;
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);


       imod = imod_trig;
       buf_send[0]=(imod<<11)+(mb_trig_pulse_delay)+((pulse_trig_delay)<<16); // set up triger delay;
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);



       usleep(10);

       imod = imod_trig;
       buf_send[0]=(imod<<11)+(mb_trig_pulse1)+((0x1)<<16); // fire pulse 1;
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);
//
//
       usleep(1000);
      }
     }


     else if (is == 2) {
      ia=0;
      for (j=1; j<nloop; j++) {

       iprint=0;
       nread = 5;
       i = pcie_rec_2(hDev,0,1,nread,iprint,py);     // init the receiver

       imod =imod_trig;  /* trigger module */
       buf_send[0]=(imod<<11)+mb_trig_pctrig+((0x0)<<16);
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);
       usleep(1000);

//      printf(" enter 1 to read system status \n");
//---      scanf("%d",&ik);

//      nword = 7;
       nword =2;

       i = pcie_rec(hDev,0,1,nword,iprint,py);     // init the receiver


//---      scanf("%d",&ik);

       imod=imod_trig;
       ichip=3;   // don't care about ichip #
//      buf_send[0]=(imod<<11)+(ichip<<8)+mb_trig_rd_param+(0x0<<16);  // read out status
       buf_send[0]=(imod<<11)+(ichip<<8)+mb_trig_rd_gps+(0x0<<16);  // read out status
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);
       py = &read_array;
       i = pcie_rec(hDev,0,2,nword,iprint,py);     // read out 2 32 bits words
//
//      printf("receive data word = %x, %x, %x, %x \n", read_array[0], read_array[1],read_array[2], read_array[3]);
//      printf("receive data word = %x, %x, %x\n", read_array[4], read_array[5],read_array[6]);
//
       cframe = (read_array[0] & 0xffffff);
       csample = (read_array[1] & 0xfff);
       cdiv = ((read_array[1] & 0x70000) >> 16);
       if((cframe-oframe) != 0) {
        printf(" %d %d gps frame dif = %d, sample dif = %d, div dif = %d %d\n", j, ia,
(cframe-oframe), (csample-osample), (cdiv-odiv),((cframe-oframe)*256+(csample-osample)*8+(cdiv-odiv)));
        ia = ia+1;
        }
//      printf(" GPS frame difference = %d \n", ((read_array[0] & 0xffffff)- oframe));
//      printf(" GPS sample number difference = %d \n", ((read_array[1] & 0xfff)- osample));
//      printf(" GPS divider number difference = %d \n", (((read_array[1] & 0x70000) >> 16)- odiv));
//      printf("GPS frame word = %x, data word = %x\n", (read_array[0] & 0xffffff), read_array[0]);
//      printf("GPS sample number = %x, divider number = %x, data word = %x\n", (read_array[1] & 0xfff),
//      ((read_array[1] & 0x70000) >> 16), read_array[1]);
       oframe = (read_array[0] & 0xffffff);
       osample = (read_array[1] & 0xfff);
       odiv = ((read_array[1] & 0x70000) >> 16);

//
//
//
//      py = &read_array;
//      i = pcie_rec_2(hDev,0,2,nread,iprint,py);     // read out 2 32 bits words
//      printf("optical receive data word = %x, %x, %x\n", read_array[0], read_array[1],read_array[2]);

//---      scanf("%d",&ik);
       usleep(250000);

      }
     }
     else if (is== 3) {

      py = &read_array;
      for (j=0; j<nloop; j++) {
       nread = 8;
       i = pcie_rec_2(hDev,1,1,nread,iprint,py);     // init the receiver

       imod =imod_trig;  /* trigger module */
       buf_send[0]=(imod<<11)+mb_trig_pctrig+((0x0)<<16);
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);
       usleep(1000);

       i = pcie_rec_2(hDev,1,2,nread,iprint,py);     // read out 2 32 bits words
       printf("optical receive data word = %x, %x, %x, %x\n", read_array[0], read_array[1],read_array[2], read_array[3]);
       printf("busy   %d \n", (read_array[0] & 0x1));
       printf("sample number %d \n", ((read_array[0]>>4) & 0xfff));
       printf("16 MHz clock remine %d\n", ((read_array[0]>>1) & 0x7));
       ik = ((read_array[1] & 0xff)<<16) + ((read_array[0] >>16));
       printf("frame number %x \n",ik);
       ik = (read_array[1] >> 8);
       printf("trigger number %x\n",ik);
       printf("PMT trigger data %x\n", (read_array[2] & 0xff));
       printf("PC trig          %x\n", ((read_array[2]>>8) & 0x1));
       printf("External Trig    %x\n", ((read_array[2]>>9) & 0x1));
       printf("Active           %x\n", ((read_array[2]>>10) & 0x1));
       printf("Gate2 In         %x\n", ((read_array[2]>>11) & 0x1));
       printf("Gate1 In         %x\n", ((read_array[2]>>12) & 0x1));
       printf("Veto in          %x\n", ((read_array[2]>>13) & 0x1));
       printf("Calib trig       %x\n", ((read_array[2]>>14) & 0x1));
       printf("64MHz remine     %x\n", ((read_array[2]>>15) & 0x3));
      }
     }
     else if (is== 4) {
      imod =imod_trig;  /* trigger module */
      buf_send[0]=(imod<<11)+mb_trig_g1_allow_min+((0x10)<<16);
      i=1;
      k=1;
      i = pcie_send(hDev, i, k, px);
      usleep(1000);
      imod =imod_trig;  /* trigger module */
      buf_send[0]=(imod<<11)+mb_trig_g1_allow_max+((0x20)<<16);
      i=1;
      k=1;
      i = pcie_send(hDev, i, k, px);
      usleep(1000);
      imod =imod_trig;  /* trigger module */
      buf_send[0]=(imod<<11)+mb_trig_g2_allow_min+((0x8)<<16);
      i=1;
      k=1;
      i = pcie_send(hDev, i, k, px);
      usleep(1000);
      imod =imod_trig;  /* trigger module */
      buf_send[0]=(imod<<11)+mb_trig_g2_allow_max+((0x18)<<16);
      i=1;
      k=1;
      i = pcie_send(hDev, i, k, px);
      usleep(1000);
      scanf("%d",&i);
     }

     break;

    case 17:
     printf(" shaper board test \n");
     printf(" enable number of loop\n");
     scanf("%d",&nloop);
//     printf(" 1 for checking the event \n");
//     scanf("%d",&icheck);
//     printf(" type 1 to use random number \n");
//     scanf("%d",&irand);
     icheck =0;
     irand = 0;
     islow_read =0;
//     if(icheck != 1) {
//      printf(" 1 for print event\n");
//      scanf("%d",&iprint);
//     }
//     else iprint =0;
//     iprint = 1;
//     printf(" number event \n");
//     scanf("%d",&nevent);

//     printf(" enter number of words per packet \n");
//     scanf("%d",&nsend);
     nsend=500;
     imod_shaper=12;

     px = &buf_send;
     py = &read_array;
//
//   controller
//
     imod =0;  /* controller module */
/** initialize **/
     buf_send[0]=0x0;
     buf_send[1]=0x0;
     i=1;
     k=1;
     i = pcie_send(hDev, i, k, px);
// set offline test
     imod=0;
     ichip=1;
     buf_send[0]=(imod<<11)+(ichip<<8)+(mb_cntrl_test_on)+(0x0<<16); //enable offline run on
     i=1;
     k=1;
     i = pcie_send(hDev, i, k, px);
 //disable the run command
     imod=0;
     ichip=1;
     buf_send[0]=(imod<<11)+(ichip<<8)+(mb_cntrl_set_run_off)+(0x0<<16); //enable offline run on
     i=1;
     k=1;
     i = pcie_send(hDev, i, k, px);
//
// set frame set to be 1023 --- there will be 1024/8 = 128 adc samples.
//
      imod=0;
      ichip=1;
      iframe= 255;    //1023
      buf_send[0]=(imod<<11)+(ichip<<8)+(mb_cntrl_load_frame)+((iframe & 0xffff)<<16); //enable test mode
      i=1;
      k=1;
      i = pcie_send(hDev, i, k, px);







     printf(" enter dac value in hex (fff full scale)\n");
     scanf("%x",&ik);
//     ik= 0xfff;

      imod =imod_shaper;  /* set shaper module DAC value */
      buf_send[0]=(imod<<11)+mb_shaper_dac+(ik<<16);
      i=1;
      k=1;
      i = pcie_send(hDev, i, k, px);
//      if(ik == 0xfff) ik=0;
//      else if(ik == 0x800) ik=0xfff;
//      else ik=0x800;
      usleep(100);
      printf(" write DAC value module %d\n", imod);
      imod =imod_shaper;  /* write to the DAC */
      buf_send[0]=(imod<<11)+mb_shaper_write+((0x3ff)<<16);
      i=1;
      k=1;
      i = pcie_send(hDev, i, k, px);
      usleep(1000);
 //
 //
 //

      imod =imod_shaper;  /* write pulse time */
      idiv =1;
      isample =1;
      buf_send[0]=(imod<<11)+mb_shaper_pulsetime+(((idiv&0x7)+(isample&0xfff)<<3)<<16);  // all bits on
      i=1;
      k=1;
      i = pcie_send(hDev, i, k, px);
      usleep(1000);


      imod =imod_shaper;  /* write to test pattern register */
      buf_send[0]=(imod<<11)+mb_shaper_pattern+((0xf)<<16);  // all bits on
      i=1;
      k=1;
      i = pcie_send(hDev, i, k, px);
      usleep(1000);

      imod=0;
      ichip=1;
      buf_send[0]=(imod<<11)+(ichip<<8)+(mb_cntrl_set_run_on)+(0x0<<16); //enable offline run on
      i=1;
      k=1;
      i = pcie_send(hDev, i, k, px);
      usleep(10);


     for (j=1; j<nloop; j++) {
      imod =imod_shaper;  /* arm test pulse firing*/
      buf_send[0]=(imod<<11)+mb_shaper_pulse+((0xf)<<16);  // all bits on
      i=1;
      k=1;
      i = pcie_send(hDev, i, k, px);
      usleep(10000);



     }

     break;

    case 18:
     printf(" feb boot test \n");
     printf(" enable number of loop\n");
//***     scanf("%d",&nloop);
//     printf(" 1 for checking the event \n");
//     scanf("%d",&icheck);
//     printf(" type 1 to use random number \n");
//     scanf("%d",&irand);
     icheck = 0;
     irand =0;
     if(icheck != 1) {
      printf(" 1 for print event\n");
//***      scanf("%d",&iprint);
     }
     else iprint =0;
     printf(" number event \n");
//***     scanf("%d",&nevent);
     iprint =1;
     nloop=10;
     nevent=10;
//****

//****

//     printf(" enter number of words per packet \n");
//     scanf("%d",&nsend);
     nsend=500;

     px = &buf_send;
     py = &read_array;
     imod =0;  /* controller module */
/** initialize **/
     buf_send[0]=0x0;
     buf_send[1]=0x0;
     i=1;
     k=1;
     i = pcie_send(hDev, i, k, px);
// set offline test
     imod=0;
     ichip=1;
     buf_send[0]=(imod<<11)+(ichip<<8)+(mb_cntrl_test_on)+(0x0<<16); //enable offline run on
     i=1;
     k=1;
     i = pcie_send(hDev, i, k, px);
 //disable the run command
     imod=0;
     ichip=1;
     buf_send[0]=(imod<<11)+(ichip<<8)+(mb_cntrl_set_run_off)+(0x0<<16); //enable offline run on
     i=1;
     k=1;
     i = pcie_send(hDev, i, k, px);
 // turn on the Stratix III power supply
     imod=11;
     ichip =1;
     buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_power_add+(0x0<<16); //turn module 11 power on
     i=1;
     k=1;
     i = pcie_send(hDev, i, k, px);
     usleep(200000);  // wait for 200 ms
//     printf(" enable number of loop\n");
//     scanf("%d",&nloop);
     for ( j=0; j<nloop; j++) {
      usleep(10000); // wait for 10ms
      inpf = fopen("/home/ub/feb_fpga_test","r");
      imod=11;
      ichip=mb_feb_conf_add;
      buf_send[0]=(imod<<11)+(ichip<<8)+0x0+(0x0<<16);  // turn conf to be on
      i=1;
      k=1;
      i = pcie_send(hDev, i, k, px);
//      for (i=0; i<100000; i++) {
//          ik= i%2;
//          dummy1= (ik+i)*(ik+i);
//      }


        /* read data as characters (28941) */
      usleep(1000);   // wait fior a while
      count = 0;
      counta= 0;
      ichip_c = 7; // set ichip_c to stay away from any other command in the
      dummy1 =0;
      while (fread(&charchannel,sizeof(char),1,inpf)==1) {
       carray[count] = charchannel;
       count++;
       counta++;
       if((count%(nsend*2)) == 0) {
//        printf(" loop = %d\n",dummy1);
        buf_send[0] = (imod <<11) +(ichip_c <<8)+ (carray[0]<<16);
        send_array[0] =buf_send[0];
        if(dummy1 <= 5 ) printf(" counta = %d, first word = %x, %x, %x %x %x \n",counta,buf_send[0], carray[0], carray[1]
        ,carray[2], carray[3]);
        for (ij=0; ij< nsend; ij++) {
         if(ij== (nsend-1)) buf_send[ij+1] = carray[2*ij+1]+(0x0<<16);
         else buf_send[ij+1] = carray[2*ij+1]+ (carray[2*ij+2]<<16);
//         buf_send[ij+1] = carray[2*ij+1]+ (carray[2*ij+2]<<16);
         send_array[ij+1] = buf_send[ij+1];
        }
        nword =nsend+1;
        i=1;
//       if(dummy1 == 0)
        ij = pcie_send(hDev, i, nword, px);
        nanosleep(&tim , &tim2);
        dummy1 = dummy1+1;
        count =0;
       }
      }
      if(feof(inpf)) {
       printf("You have reached the end-of-file word count= %d %d\n", counta, count);
       buf_send[0] = (imod <<11) +(ichip_c <<8)+ (carray[0]<<16);
       if ( count > 1) {
        if( ((count-1)%2) ==0) {
         ik =(count-1)/2;
        }
        else {
         ik =(count-1)/2+1;
        }
        ik=ik+2;   // add one more for safety
        printf("ik= %d\n",ik);
        for (ij=0; ij<ik; ij++){
         if(ij == (ik-1)) buf_send[ij+1] = carray[(2*ij)+1]+(((imod<<11)+(ichip<<8)+0x0)<<16);
         else buf_send[ij+1] = carray[(2*ij)+1]+ (carray[(2*ij)+2]<<16);
         send_array[ij+1] = buf_send[ij+1];
        }
       }
       else ik=1;

           for (ij=ik-10; ij< ik+1; ij++) {
            printf("Last data = %d, %x\n",ij,buf_send[ij]);
           }

       nword =ik+1;
       i=1;
       i = pcie_send(hDev, i, nword, px);
       usleep(2000);    // wait for 2ms to cover the packet time plus fpga init time
       fclose(inpf);
       printf(" enter 1 to reset the dram \n");
 //****      scanf("%d",&ik);
       ik =1;
       if(ik ==1) {
         imod=11;
         ichip=3;
         buf_send[0]=(imod<<11)+(ichip<<8)+31+(0x1<<16);  // turm the DRAM reset on
         i=1;
         k=1;
         i = pcie_send(hDev, i, k, px);
         imod=11;
         ichip=3;
         buf_send[0]=(imod<<11)+(ichip<<8)+31+(0x0<<16);  // turm the DRAM reset off
         i=1;
         k=1;
         i = pcie_send(hDev, i, k, px);

         usleep(5000);    // wait for 5 ms for DRAM to be initialized

         imod=11;
         ichip=3;
         buf_send[0]=(imod<<11)+(ichip<<8)+6+(imod<<16);  // set module number
         i=1;
         k=1;
         i = pcie_send(hDev, i, k, px);


       }
//       printf(" enter 1 to read system status \n");
//       scanf("%d",&ik);
       ik=1;
       nword =1;
       if(ik ==1) {


         i = pcie_rec(hDev,0,1,nword,iprint,py);     // init the receiver

         imod=11;
         ichip=3;
         buf_send[0]=(imod<<11)+(ichip<<8)+20+(0x0<<16);  // read out status
         i=1;
         k=1;
         i = pcie_send(hDev, i, k, px);
         py = &read_array;
         i = pcie_rec(hDev,0,2,nword,iprint,py);     // read out 2 32 bits words
         printf("receive data word = %x, %x \n", read_array[0], read_array[1]);
       }
//       printf(" enter L1 trigger delay \n");
//       scanf("%d",&itrig_delay);

//
//        set adc operatio -- soft reset
//
       for (is=0; is<8; is++) {
        imod=11;
        ichip=5;
        buf_send[0]=(imod<<11)+(ichip<<8)+(mb_pmt_spi_add)+((is & 0xf)<<16); //set spi address
        i=1;
        k=1;
        i = pcie_send(hDev, i, k, px);
//       printf(" spi port %d \n",is);
//       scanf("%d",&ik);

        imod=11;
        ichip=5;
        buf_send[0]=(imod<<11)+(ichip<<8)+(mb_pmt_adc_data_load)+(0x0300<<16); //1st next word will be overwrite by the next next word
        buf_send[1]=(((0x0)<<13)+(0x0))+((0x3c)<<24)+((0x0)<<16);
//
//  set /w =0, w1,w2 =0, a12-a0 = 0x0, data =0x3c;
//

        i=1;
        k=2;
//       i = pcie_send(hDev, i, k, px);
        usleep(2000);   // sleep for 2ms
       }
//       usleep(2000);   // sleep for 2ms
       printf(" enter 1 to continue after soft reset\n");
//***       scanf("%d",&ik);
//
//    the ADC spi stream.. The 16 bits data before the last word is r/w, w1, w2 and 13 bits address
//                         the last 16 bits.upper byte = 8 bits data and lower 8 bits ignored.
//
       for (is=0; is<8; is++) {
        imod=11;
        ichip=5;
        buf_send[0]=(imod<<11)+(ichip<<8)+(mb_pmt_spi_add)+((is & 0xf)<<16); //set spi address
        i=1;
        k=1;
        i = pcie_send(hDev, i, k, px);
        usleep(2000);   // sleep for 2ms
        printf(" spi port %d \n",is);
//       scanf("%d",&ik);

        imod=11;
        ichip=5;
        buf_send[0]=(imod<<11)+(ichip<<8)+(mb_pmt_adc_data_load)+(0x0300<<16); //1st next word will be overwrite by the next next word
        buf_send[1]=(((0x0)<<13)+(0xd))+((0xa)<<24)+((0x0)<<16);
//        buf_send[1]=(((0x0)<<13)+(0xd))+((0xa)<<24)+((0x0)<<16);
//
//  set /w =0, w1,w2 =0, a12-a0 = 0xd, data =0xb;
//

        i=1;
        k=2;
        i = pcie_send(hDev, i, k, px);
        usleep(2000);   // sleep for 2ms
        printf(" spi port 2nd command %d \n",is);
//       scanf("%d",&ik);

        imod=11;
        ichip=5;
        buf_send[0]=(imod<<11)+(ichip<<8)+(mb_pmt_adc_data_load)+(0x0300<<16); //1st next word will be overwrite by the next next word
        buf_send[1]=(((0x0)<<13)+(0xff))+((0x1)<<24)+((0x0)<<16);
//
//  set /w =0, w1,w2 =0, a12-a0 = 0xff, data =0x1;
//  write to transfer register
//

        i=1;
        k=2;
        i = pcie_send(hDev, i, k, px);
        usleep(2000);   // sleep for 2ms

       }

       printf(" enter 1 to continue FPGA ADC receiver reset\n");
//***       scanf("%d",&ik);
//
//    send FPGA ADC receiver reset
//
       imod=11;
       ichip=3;
       buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_adc_reset+(0x1<<16);  // FPGA ADC receiver reset on
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);


       printf(" enter 1 to continue FPGA ADC receiver align\n");
//***       scanf("%d",&ik);
//
//    send FPGA ADC align
//
       imod=11;
       ichip=3;
       buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_adc_align+(0x0<<16);  // FPGA ADC receiver reset off
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);
       usleep(2000);   // sleep for 2ms

       printf(" finish align \n");
//****       scanf("%d",&ik);
//
//    the ADC spi stream.. The 16 bits data before the last word is r/w, w1, w2 and 13 bits address
//                         the last 16 bits.upper byte = 8 bits data and lower 8 bits ignored.
//
       for (is=0; is<8; is++) {
        imod=11;
        ichip=5;
        buf_send[0]=(imod<<11)+(ichip<<8)+(mb_pmt_spi_add)+((is & 0xf)<<16); //set spi address
        i=1;
        k=1;
        i = pcie_send(hDev, i, k, px);
        usleep(2000);   // sleep for 2ms
        printf(" spi port %d \n",is);
//       scanf("%d",&ik);

        imod=11;
        ichip=5;
        buf_send[0]=(imod<<11)+(ichip<<8)+(mb_pmt_adc_data_load)+(0x0300<<16); //1st next word will be overwrite by the next next word
        buf_send[1]=(((0x0)<<13)+(0xd))+((0xb)<<24)+((0x0)<<16);          // send 1 bit high
//        buf_send[1]=(((0x0)<<13)+(0xd))+((0x0)<<24)+((0x0)<<16);
//
//  set /w =0, w1,w2 =0, a12-a0 = 0xd, data =0xb;
//

        i=1;
        k=2;
        i = pcie_send(hDev, i, k, px);
        usleep(2000);   // sleep for 2ms
        printf(" spi port 2nd command %d \n",is);
//       scanf("%d",&ik);

        imod=11;
        ichip=5;
        buf_send[0]=(imod<<11)+(ichip<<8)+(mb_pmt_adc_data_load)+(0x0300<<16); //1st next word will be overwrite by the next next word
        buf_send[1]=(((0x0)<<13)+(0xff))+((0x1)<<24)+((0x0)<<16);
//
//  set /w =0, w1,w2 =0, a12-a0 = 0xff, data =0x1;
//  write to transfer register
//

        i=1;
        k=2;
        i = pcie_send(hDev, i, k, px);
        usleep(2000);   // sleep for 2ms

       }




       itrig_delay = 51;
       nword =1;
//
// set to not use test generator 2, set test =2
//
       imod=11;
       ichip=mb_feb_pass_add;
       buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_test_source+(0x0<<16);  // set test source to 0
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);
//
// set frame set to be 1023 --- there will be 1024/8 = 128 adc samples.
//
       imod=0;
       ichip=1;
       iframe= 255;    //1023
       buf_send[0]=(imod<<11)+(ichip<<8)+(mb_cntrl_load_frame)+((iframe & 0xffff)<<16); //enable test mode
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);


//
// load trig 1 position relative to the frame..
//
       imod=0;
       ichip=1;
       buf_send[0]=(imod<<11)+(ichip<<8)+(mb_cntrl_load_trig_pos)+((itrig_delay & 0xffff)<<16); //enable test mode
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);


       imod=11;
       ichip=3;
       buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_a_nocomp+(0x1<<16);  // set a channel no compression
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);

       timesize =4;
       imod=11;
       ichip=3;
       buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_timesize+(timesize<<16);  // set drift time size
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);

       a_id =0x20;
       imod=11;
       ichip=3;
       buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_a_id+(a_id<<16);  // set a_id
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);


       imod=11;
       ichip=3;
       buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_a_test+(0x1<<16);    // enable a test on
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);

       imod=0;
       ichip=1;
       buf_send[0]=(imod<<11)+(ichip<<8)+(mb_cntrl_set_run_on)+(0x0<<16); //enable offline run on
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);

       usleep(5000); //wait for 5 ms


       for (is=0; is<nevent; is++) {



        imod=0;
        ichip=1;
        buf_send[0]=(imod<<11)+(ichip<<8)+mb_cntrl_set_trig1+(0x0<<16);  // send trigger
        i=1;
        k=1;
        i = pcie_send(hDev, i, k, px);



//      set module number again to enable the FEB module read back

        imod=11;
        ichip=3;
        buf_send[0]=(imod<<11)+(ichip<<8)+6+(imod<<16);  // set module number
        i=1;
        k=1;
        i = pcie_send(hDev, i, k, px);

        usleep(5000); // wait for 5 ms


        nword = 5;
        i = pcie_rec(hDev,0,1,nword,iprint,py);     // init the receiver

        imod=11;
        ichip=3;
        buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_a_rdhed+(0x1<<16);  // read a header
        i=1;
        k=1;
        i = pcie_send(hDev, i, k, px);

        py = &read_array;
        i = pcie_rec(hDev,0,2,nword,iprint,py);     // read out 2 32 bits words
        if(iprint ==1) printf("receive data word = %x, %x, %x, %x, %x\n", read_array[0], read_array[1], read_array[2], read_array[3], read_array[4]);
        if(iprint == 1) {
          printf(" header word %x \n",(read_array[0] & 0xffff));
          k=(read_array[0]>>16) & 0xfff;
          printf(" module adress %d, id number %d\n", (k & 0x1f), ((k>>5) & 0x7f));
          printf(" number of data word to read %d\n", (((read_array[1]>>16) & 0xfff)+((read_array[1] &0xfff) <<12)));
          printf(" event number %d\n", (((read_array[2]>>16) & 0xfff)+((read_array[2] &0xfff) <<12)));
          printf(" frame number %d\n", (((read_array[3]>>16) & 0xfff)+((read_array[3] &0xfff) <<12)));
          printf(" checksum %x\n", (((read_array[4]>>16) & 0xfff)+((read_array[4] &0xfff) <<12)));
        }
        nread = ((read_array[1]>>16) & 0xfff)+((read_array[1] &0xfff) <<12);
//        if(iprint ==1) printf(" number of data word to read = %d\n",nread);

//        ik =  read_array[0] & 0x1f;
//        if(iprint ==1) printf(" module number = %d",ik);
//        ik =  (read_array[0] >> 5) & 0x7f;
//        if(iprint ==1) printf(" data ID = %d",ik);
//        ik =  (((read_array[2] >>16) & 0xfff)<<12) + (read_array[2] & 0xfff);
//        if(iprint ==1) printf(" event number = %d",ik);
//        ik =  (((read_array[3] >>16) & 0xfff)<<12) + (read_array[3] & 0xfff);
//        if(iprint ==1) printf(" frame number = %d\n",ik);
//        ik =  (((read_array[4] >>16) & 0xfff)<<12) + (read_array[4] & 0xfff);
//        if(iprint ==1) printf(" checksum = %x\n",ik);

        if(iprint ==1 )scanf("%d",&ik);
        nword = (nread+1)/2;                    // short words
        i = pcie_rec(hDev,0,1,nword,iprint,py);     // init the receiver

        imod=11;
        ichip=mb_feb_pass_add;
        buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_a_rdbuf+(0x0<<16);  // read a header
        i=1;
        k=1;
        i = pcie_send(hDev, i, k, px);

        py = &read_array;
        i = pcie_rec(hDev,0,2,nword,iprint,py);     // read out 2 32 bits words

        if(iprint == 1) {
         for (i=0; i< nword; i++) {
          if((i%8) ==0) printf("%4d",i);
          printf(" %8x",read_array[i]);
          if(((i+1)%8) ==0 ) printf("\n");
         }
        }

        ik=0;
        for (i=0; i< nword; i++) {
          read_array_s[ik] = read_array[i] &0xffff;
          read_array_s[ik+1] = ((read_array[i]>>16) & 0xffff);
          ik=ik+2;
        }

//
//      printout formatted word
//
        if(iprint ==1) {
         iset = 0;
         for(i=0; i< 2*nword; i++) {
          if((read_array_s[i] & 0xf000) == 0x4000) {
            iset=1;
            ncount=0;
            printf(" channel %d\n",(read_array_s[i] & 0xfff));
          }
          else if ((read_array_s[i] & 0xf000) == 0x5000) printf(" channel end %d\n",(read_array_s[i] &0xfff));
          else if (iset ==1) {
            printf(" %4x",read_array_s[i]);
            ncount = ncount+1;
            if((ncount%8) == 0) printf("\n");
          }
          else {
            printf("%x",read_array_s[i]);
            ncount = ncount+1;
            if((ncount%8) == 0) printf("\n");
          }
         }
        }

        if(icheck ==1 ){
         if((2*nword) == (64*timesize*3)){
          for (i=0; i<64; i++){
           k=i*(timesize*3);
           ij= i*256;
           if(read_array_s[k] != (0x4000+i))
            printf(" first word error, event %d data received %x, data expected %x\n", is, read_array_s[k], (0x4000+i));
           for (ik=0; ik< ((3*timesize)-2); ik++) {
            if(read_array_s[k+1+ik] != send_array[ij+ik])
             printf(" data word error, event %d ch = %d, received %x, expected %x\n",is,i,read_array_s[k+1+ik], send_array[ij+ik]);
           }
           k=(i+1)*(timesize*3)-1;
           if(read_array_s[k] != (0x5000+i))
            printf(" last word error, event %d data received %x, data expected %x\n", is, read_array_s[k], (0x5000+i));
          }
         }
         else {
          printf(" event %d number word receive = %d, expected=  %d \n", is, (2*nword), (64*timesize*3));
         }
        }
        if(icheck ==1) {
          k = is%1000;
          if(k ==0) printf("event %d\n",is);
        }
        if(iprint == 1) scanf("%d",&ik);
       }

       imod=0;
       ichip=1;
       buf_send[0]=(imod<<11)+(ichip<<8)+(mb_cntrl_set_run_off)+(0x0<<16); //enable offline run off
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);
       scanf("%d",&ik);
      }





     }

     break;

    case 19:
     printf(" feb boot test \n");
     printf(" enable number of loop\n");
     scanf("%d",&nloop);
     printf(" frame length \n");
     scanf("%d",&iframe_length);
     ik=iframe_length%64;
     if(ik != 0) printf(" frame_length problem \n");

     printf(" drift time (< %d) \n", iframe_length/8);
     scanf("%d",&idrift_time);
     printf(" enter triger delay \n");
     scanf("%d",&itrig_delay);
     printf("number of triggers per loop \n");
     scanf("%d",&itrig);
//     printf(" 1 for checking the event \n");
//     scanf("%d",&icheck);
//     printf(" type 1 to use random number \n");
//     scanf("%d",&irand);
     icheck=0;
     irand=0;
     if(icheck != 1) {
      printf(" 1 for print event\n");
      scanf("%d",&iprint);
     }
     else iprint =0;
     printf(" number event \n");
     scanf("%d",&nevent);

//     printf(" enter number of words per packet \n");
//     scanf("%d",&nsend);
     nsend=500;

     px = &buf_send;
     py = &read_array;
     imod =0;  /* controller module */
/** initialize **/
     buf_send[0]=0x0;
     buf_send[1]=0x0;
     i=1;
     k=1;
     i = pcie_send(hDev, i, k, px);
// set offline test
     imod=0;
     ichip=1;
     buf_send[0]=(imod<<11)+(ichip<<8)+(mb_cntrl_test_on)+(0x0<<16); //enable offline run on
     i=1;
     k=1;
     i = pcie_send(hDev, i, k, px);
 //disable the run command
     imod=0;
     ichip=1;
     buf_send[0]=(imod<<11)+(ichip<<8)+(mb_cntrl_set_run_off)+(0x0<<16); //enable offline run on
     i=1;
     k=1;
     i = pcie_send(hDev, i, k, px);
 // turn on the Stratix III power supply
     imod=11;
     ichip =1;
     buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_power_add+(0x0<<16); //turn module 11 power on
     i=1;
     k=1;
     i = pcie_send(hDev, i, k, px);
     usleep(200000);  // wait for 200 ms
//     printf(" enable number of loop\n");
//     scanf("%d",&nloop);
     for ( j=0; j<nloop; j++) {
      usleep(10000); // wait for 10ms
      inpf = fopen("/home/ub/feb_fpga_test","r");
      imod=11;
      ichip=mb_feb_conf_add;
      buf_send[0]=(imod<<11)+(ichip<<8)+0x0+(0x0<<16);  // turn conf to be on
      i=1;
      k=1;
      i = pcie_send(hDev, i, k, px);
//      for (i=0; i<100000; i++) {
//          ik= i%2;
//          dummy1= (ik+i)*(ik+i);
//      }


        /* read data as characters (28941) */
      usleep(1000);   // wait fior a while
      count = 0;
      counta= 0;
      ichip_c = 7; // set ichip_c to stay away from any other command in the
      dummy1 =0;
      while (fread(&charchannel,sizeof(char),1,inpf)==1) {
       carray[count] = charchannel;
       count++;
       counta++;
       if((count%(nsend*2)) == 0) {
//        printf(" loop = %d\n",dummy1);
        buf_send[0] = (imod <<11) +(ichip_c <<8)+ (carray[0]<<16);
        send_array[0] =buf_send[0];
        if(dummy1 <= 5 ) printf(" counta = %d, first word = %x, %x, %x %x %x \n",counta,buf_send[0], carray[0], carray[1]
        ,carray[2], carray[3]);
        for (ij=0; ij< nsend; ij++) {
         if(ij== (nsend-1)) buf_send[ij+1] = carray[2*ij+1]+(0x0<<16);
         else buf_send[ij+1] = carray[2*ij+1]+ (carray[2*ij+2]<<16);
//         buf_send[ij+1] = carray[2*ij+1]+ (carray[2*ij+2]<<16);
         send_array[ij+1] = buf_send[ij+1];
        }
        nword =nsend+1;
        i=1;
//       if(dummy1 == 0)
        ij = pcie_send(hDev, i, nword, px);
        nanosleep(&tim , &tim2);
        dummy1 = dummy1+1;
        count =0;
       }
      }
      if(feof(inpf)) {
       printf("You have reached the end-of-file word count= %d %d\n", counta, count);
       buf_send[0] = (imod <<11) +(ichip_c <<8)+ (carray[0]<<16);
       if ( count > 1) {
        if( ((count-1)%2) ==0) {
         ik =(count-1)/2;
        }
        else {
         ik =(count-1)/2+1;
        }
        ik=ik+2;   // add one more for safety
        printf("ik= %d\n",ik);
        for (ij=0; ij<ik; ij++){
         if(ij == (ik-1)) buf_send[ij+1] = carray[(2*ij)+1]+(((imod<<11)+(ichip<<8)+0x0)<<16);
         else buf_send[ij+1] = carray[(2*ij)+1]+ (carray[(2*ij)+2]<<16);
         send_array[ij+1] = buf_send[ij+1];
        }
       }
       else ik=1;

           for (ij=ik-10; ij< ik+1; ij++) {
            printf("Last data = %d, %x\n",ij,buf_send[ij]);
           }

       nword =ik+1;
       i=1;
       i = pcie_send(hDev, i, nword, px);
       usleep(2000);    // wait for 2ms to cover the packet time plus fpga init time
       fclose(inpf);
       printf(" enter 1 to reset the dram \n");
       scanf("%d",&ik);
 //      ik =1;
       if(ik ==1) {
         imod=11;
         ichip=3;
         buf_send[0]=(imod<<11)+(ichip<<8)+31+(0x1<<16);  // turm the DRAM reset on
         i=1;
         k=1;
         i = pcie_send(hDev, i, k, px);
         imod=11;
         ichip=3;
         buf_send[0]=(imod<<11)+(ichip<<8)+31+(0x0<<16);  // turm the DRAM reset off
         i=1;
         k=1;
         i = pcie_send(hDev, i, k, px);

         usleep(5000);    // wait for 5 ms for DRAM to be initialized

         imod=11;
         ichip=3;
         buf_send[0]=(imod<<11)+(ichip<<8)+6+(imod<<16);  // set module number
         i=1;
         k=1;
         i = pcie_send(hDev, i, k, px);


       }
//       printf(" enter 1 to read system status \n");
//       scanf("%d",&ik);
       ik=1;
       nword =1;
       if(ik ==1) {


         i = pcie_rec(hDev,0,1,nword,iprint,py);     // init the receiver

         imod=11;
         ichip=3;
         buf_send[0]=(imod<<11)+(ichip<<8)+20+(0x0<<16);  // read out status
         i=1;
         k=1;
         i = pcie_send(hDev, i, k, px);
         py = &read_array;
         i = pcie_rec(hDev,0,2,nword,iprint,py);     // read out 2 32 bits words
         printf("receive data word = %x, %x \n", read_array[0], read_array[1]);
       }
//       printf(" enter L1 trigger delay \n");
//       scanf("%d",&itrig_delay);
//       itrig_delay = 51;
       nword =1;
//
// set to use test generator 2, set test =2
//
       imod=11;
       ichip=mb_feb_pass_add;
       buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_test_source+(0x2<<16);  // set test source to 2
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);
//
// set frame set to be 1023 --- there will be 1024/8 = 128 adc samples.
//
       imod=0;
       ichip=1;
//       iframe= 255;    //1023
       iframe = iframe_length-1;
       buf_send[0]=(imod<<11)+(ichip<<8)+(mb_cntrl_load_frame)+((iframe & 0xffff)<<16); //enable test mode
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);


//
// load trig 1 position relative to the frame..
//
       imod=0;
       ichip=1;
       buf_send[0]=(imod<<11)+(ichip<<8)+(mb_cntrl_load_trig_pos)+((itrig_delay & 0xffff)<<16); //enable test mode
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);
//
//    start loading the test 2 data memory
//
       imod =11;
       ichip=3;
       for (is=0; is<64; is++) {
        ik = 0x4000+is;                        // load channel address
        buf_send[0]=(imod<<11)+(ichip<<8)+(mb_feb_test_ram_data)+((ik & 0xffff)<<16); //enable test mode
        i = pcie_send(hDev, 1, 1, px);
        ibase = 32*is;
        il = is%8;
        if(il == 0) printf(" loading channel %d\n",is);
        for (ik=0; ik< 256; ik++) {                 // loop over all possible address
         if(irand ==1) ijk = rand() & 0xfff ;        // use random number
         else ijk= (ibase+ik*8) & 0xfff;
         k = 0x8000+ ijk;        // make sure bit 15-12 is clear for the data
         buf_send[0]=(imod<<11)+(ichip<<8)+(mb_feb_test_ram_data)+((k & 0xffff)<<16); //enable test mode
         i = pcie_send(hDev, 1, 1, px);
         send_array[is*256+ik]=ijk;           //load up data map
        }
       }

       imod=11;
       ichip=3;
       buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_a_nocomp+(0x1<<16);  // set a channel no compression
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);

//       timesize =4;
       timesize = idrift_time;
       imod=11;
       ichip=3;
       buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_timesize+(timesize<<16);  // set drift time size
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);

       a_id =0x20;
       imod=11;
       ichip=3;
       buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_a_id+(a_id<<16);  // set a_id
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);


       imod=11;
       ichip=3;
       buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_a_test+(0x1<<16);    // enable a test on
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);

       imod=0;
       ichip=1;
       buf_send[0]=(imod<<11)+(ichip<<8)+(mb_cntrl_set_run_on)+(0x0<<16); //enable offline run on
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);

       usleep(5000); //wait for 5 ms
       scanf("%d",&ik);


       for (is=0; is<nevent; is++) {


//
//     send out multiple triggers
//
        for (ijtrig=0; ijtrig<itrig; ijtrig++) {
         printf(" itrig %d, itrig_delay %d\n", ijtrig,itrig_delay);
         imod=0;
         ichip=1;
         buf_send[0]=(imod<<11)+(ichip<<8)+mb_cntrl_set_trig1+(0x0<<16);  // send trigger
         i=1;
         k=1;
         i = pcie_send(hDev, i, k, px);
         usleep(10000);  //put some space between triggers
//
// load trig 1 position relative to the frame..
//
         itrig_delay = itrig_delay+2;
         imod=0;
         ichip=1;
         buf_send[0]=(imod<<11)+(ichip<<8)+(mb_cntrl_load_trig_pos)+((itrig_delay & 0xffff)<<16); //enable test mode
         i=1;
         k=1;
         i = pcie_send(hDev, i, k, px);
         scanf("%d",&ik);

         usleep(10000);

        }



//      set module number again to enable the FEB module read back

        imod=11;
        ichip=3;
        buf_send[0]=(imod<<11)+(ichip<<8)+6+(imod<<16);  // set module number
        i=1;
        k=1;
        i = pcie_send(hDev, i, k, px);

        usleep(5000); // wait for 5 ms

        for (ijtrig=0; ijtrig<itrig; ijtrig++) {
         nword = 5;
         i = pcie_rec(hDev,0,1,nword,iprint,py);     // init the receiver

         imod=11;
         ichip=3;
         buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_a_rdhed+(0x1<<16);  // read a header
         i=1;
         k=1;
         i = pcie_send(hDev, i, k, px);

         py = &read_array;
         i = pcie_rec(hDev,0,2,nword,iprint,py);     // read out 2 32 bits words

         if(iprint ==1) printf("receive data word = %x, %x, %x, %x, %x\n", read_array[0], read_array[1], read_array[2], read_array[3], read_array[4]);
         if(iprint == 1) {
          printf(" header word %x \n",(read_array[0] & 0xffff));
          k=(read_array[0]>>16) & 0xfff;
          printf(" module adress %d, id number %d\n", (k & 0x1f), ((k>>5) & 0x7f));
          printf(" number of data word to read %d\n", (((read_array[1]>>16) & 0xfff)+((read_array[1] &0xfff) <<12)));
          printf(" event number %d\n", (((read_array[2]>>16) & 0xfff)+((read_array[2] &0xfff) <<12)));
          printf(" frame number %d\n", (((read_array[3]>>16) & 0xfff)+((read_array[3] &0xfff) <<12)));
          printf(" checksum %x\n", (((read_array[4]>>16) & 0xfff)+((read_array[4] &0xfff) <<12)));
         }
         nread = ((read_array[1]>>16) & 0xfff)+((read_array[1] &0xfff) <<12);
         if(iprint ==1 )scanf("%d",&ik);
         nword = (nread+1)/2;                    // short words
         i = pcie_rec(hDev,0,1,nword,iprint,py);     // init the receiver

         imod=11;
         ichip=mb_feb_pass_add;
         buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_a_rdbuf+(0x0<<16);  // read a header
         i=1;
         k=1;
         i = pcie_send(hDev, i, k, px);

         py = &read_array;
         i = pcie_rec(hDev,0,2,nword,iprint,py);     // read out 2 32 bits words

         if(iprint == 1) {
          for (i=0; i< nword; i++) {
           if((i%8) ==0) printf("%4d",i);
           printf(" %8x",read_array[i]);
           if(((i+1)%8) ==0 ) printf("\n");
          }
         }

         ik=0;
         for (i=0; i< nword; i++) {
          read_array_s[ik] = read_array[i] &0xffff;
          read_array_s[ik+1] = ((read_array[i]>>16) & 0xffff);
          ik=ik+2;
         }

//
//      printout formatted word
//
         if(iprint ==1) {
          iset = 0;
          for(i=0; i< 2*nword; i++) {
           if((read_array_s[i] & 0xf000) == 0x4000) {
            iset=1;
            ncount=0;
            printf(" channel %d\n",(read_array_s[i] & 0xfff));
           }
           else if ((read_array_s[i] & 0xf000) == 0x5000) printf(" channel end %d\n",(read_array_s[i] &0xfff));
           else if (iset ==1) {
            printf(" %4x",read_array_s[i]);
            ncount = ncount+1;
            if((ncount%8) == 0) printf("\n");
           }
           else {
            printf("%x",read_array_s[i]);
            ncount = ncount+1;
            if((ncount%8) == 0) printf("\n");
           }
          }
         }

         if(icheck ==1 ){
          if((2*nword) == (64*timesize*3)){
           for (i=0; i<64; i++){
            k=i*(timesize*3);
            ij= i*256;
            if(read_array_s[k] != (0x4000+i))
             printf(" first word error, event %d data received %x, data expected %x\n", is, read_array_s[k], (0x4000+i));
            for (ik=0; ik< ((3*timesize)-2); ik++) {
             if(read_array_s[k+1+ik] != send_array[ij+ik])
              printf(" data word error, event %d ch = %d, received %x, expected %x\n",is,i,read_array_s[k+1+ik], send_array[ij+ik]);
            }
            k=(i+1)*(timesize*3)-1;
            if(read_array_s[k] != (0x5000+i))
             printf(" last word error, event %d data received %x, data expected %x\n", is, read_array_s[k], (0x5000+i));
           }
          }
          else {
           printf(" event %d number word receive = %d, expected=  %d \n", is, (2*nword), (64*timesize*3));
          }
         }
        }
        if(icheck ==1) {
          k = is%1000;
          if(k ==0) printf("event %d\n",is);
        }
        if(iprint == 1) scanf("%d",&ik);
       }

       imod=0;
       ichip=1;
       buf_send[0]=(imod<<11)+(ichip<<8)+(mb_cntrl_set_run_off)+(0x0<<16); //enable offline run off
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);
       scanf("%d",&ik);
      }





     }

     break;

    case 20:
     printf(" BNL ADC testing \n");
//     printf(" enter number of words per packet \n");
//     scanf("%d",&nsend);
//     printf(" enable number of loop\n");
//     scanf("%d",&nloop);
     nloop = 1;
     printf(" number event \n");
     scanf("%d",&nevent);
     printf(" type 1 to use trigger board\n");
     scanf("%d",&itrig_c);
     printf(" type 1 to write dat to file \n");
     scanf("%d",&iwrite);
//    iwrite =0;
     if(iwrite == 1) {
       iprint = 0;
       outf = fopen("/home/ub/test.dat","w");
     }
     else {
       printf(" type 1 for scope loop \n");
       scanf("%d",&is);
       if(is == 0) iprint=1;
       else iprint=0;
     }
     nsend=500;

     px = &buf_send;
     py = &read_array;
     imod =0;  /* controller module */
/** initialize **/
     buf_send[0]=0x0;
     buf_send[1]=0x0;
     i=1;
     k=1;
     i = pcie_send(hDev, i, k, px);
// set offline test   --- from the controoller
     imod=0;
     ichip=1;
     buf_send[0]=(imod<<11)+(ichip<<8)+(mb_cntrl_test_on)+(0x0<<16); //enable offline run on
     i=1;
     k=1;
     i = pcie_send(hDev, i, k, px);
//
//
//
     imod_trig=4;
     if(itrig_c == 1) {
//disable the run command   --- from the trigger board
       imod=imod_trig;
       buf_send[0]=(imod<<11)+(mb_trig_run)+((0x0)<<16); //set up run off
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);
      }
     else {
//disable the run command   --- from the controller
       imod=0;
       ichip=1;
       buf_send[0]=(imod<<11)+(ichip<<8)+(mb_cntrl_set_run_off)+(0x0<<16); //enable offline run off
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);
     }
 //
 //     set the trigger board deadtime size
 //
     imod_trig=4;
     if(itrig_c == 1) {
 // set offline test off   --- from the controoller
      imod=0;
      ichip=1;
      buf_send[0]=(imod<<11)+(ichip<<8)+(mb_cntrl_test_off)+(0x0<<16); //enable offline run on
      i=1;
      k=1;
      i = pcie_send(hDev, i, k, px);
 //
 //
 //
      imod=imod_trig;
      buf_send[0]=(imod<<11)+(mb_trig_deadtime_size)+((0x1)<<16); //set trigger deadtime size
      i=1;
      k=1;
      i = pcie_send(hDev, i, k, px);
     }
 // turn on the Stratix III power supply
     imod=11;
     ichip =1;
     buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_power_add+(0x0<<16); //turn module 11 power on
     i=1;
     k=1;
     i = pcie_send(hDev, i, k, px);
     usleep(200000);  // wait for 200 ms
//     printf(" enable number of loop\n");
//     scanf("%d",&nloop);
     for ( j=0; j<nloop; j++) {
      usleep(10000); // wait for 10ms
      inpf = fopen("/home/ub/feb_fpga_test","r");
      imod=11;
      ichip=mb_feb_conf_add;
      buf_send[0]=(imod<<11)+(ichip<<8)+0x0+(0x0<<16);  // turn conf to be on
      i=1;
      k=1;
      i = pcie_send(hDev, i, k, px);
//      for (i=0; i<100000; i++) {
//          ik= i%2;
//          dummy1= (ik+i)*(ik+i);
//      }


        /* read data as characters (28941) */
      usleep(1000);   // wait fior a while
      count = 0;
      counta= 0;
      ichip_c = 7; // set ichip_c to stay away from any other command in the
      dummy1 =0;
      while (fread(&charchannel,sizeof(char),1,inpf)==1) {
       carray[count] = charchannel;
       count++;
       counta++;
       if((count%(nsend*2)) == 0) {
//        printf(" loop = %d\n",dummy1);
        buf_send[0] = (imod <<11) +(ichip_c <<8)+ (carray[0]<<16);
        send_array[0] =buf_send[0];
        if(dummy1 <= 5 ) printf(" counta = %d, first word = %x, %x, %x %x %x \n",counta,buf_send[0], carray[0], carray[1]
        ,carray[2], carray[3]);
        for (ij=0; ij< nsend; ij++) {
         if(ij== (nsend-1)) buf_send[ij+1] = carray[2*ij+1]+(0x0<<16);
         else buf_send[ij+1] = carray[2*ij+1]+ (carray[2*ij+2]<<16);
//         buf_send[ij+1] = carray[2*ij+1]+ (carray[2*ij+2]<<16);
         send_array[ij+1] = buf_send[ij+1];
        }
        nword =nsend+1;
        i=1;
//       if(dummy1 == 0)
        ij = pcie_send(hDev, i, nword, px);
        nanosleep(&tim , &tim2);
        dummy1 = dummy1+1;
        count =0;
       }
      }
      if(feof(inpf)) {
       printf("You have reached the end-of-file word count= %d %d\n", counta, count);
       buf_send[0] = (imod <<11) +(ichip_c <<8)+ (carray[0]<<16);
       if ( count > 1) {
        if( ((count-1)%2) ==0) {
         ik =(count-1)/2;
        }
        else {
         ik =(count-1)/2+1;
        }
        ik=ik+2;   // add one more for safety
        printf("ik= %d\n",ik);
        for (ij=0; ij<ik; ij++){
         if(ij == (ik-1)) buf_send[ij+1] = carray[(2*ij)+1]+(((imod<<11)+(ichip<<8)+0x0)<<16);
         else buf_send[ij+1] = carray[(2*ij)+1]+ (carray[(2*ij)+2]<<16);
         send_array[ij+1] = buf_send[ij+1];
        }
       }
       else ik=1;

           for (ij=ik-10; ij< ik+1; ij++) {
            printf("Last data = %d, %x\n",ij,buf_send[ij]);
           }

       nword =ik+1;
       i=1;
       i = pcie_send(hDev, i, nword, px);
      }
      usleep(2000);    // wait for 2ms to cover the packet time plus fpga init time
      fclose(inpf);
 //     printf(" enter 1 to reset the dram \n");
 //     scanf("%d",&ik);
      ik =1;
      if(ik ==1) {
       imod=11;
       ichip=3;
       buf_send[0]=(imod<<11)+(ichip<<8)+31+(0x1<<16);  // turm the DRAM reset on
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);
       imod=11;
       ichip=3;
       buf_send[0]=(imod<<11)+(ichip<<8)+31+(0x0<<16);  // turm the DRAM reset off
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);

       usleep(5000);    // wait for 5 ms for DRAM to be initialized

       imod=11;
       ichip=3;
       buf_send[0]=(imod<<11)+(ichip<<8)+6+(imod<<16);  // set module number
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);


      }
      ik=1;
      nword =1;
      if(ik ==1) {


       i = pcie_rec(hDev,0,1,nword,iprint,py);     // init the receiver

       imod=11;
       ichip=3;
       buf_send[0]=(imod<<11)+(ichip<<8)+20+(0x0<<16);  // read out status
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);
       py = &read_array;
       i = pcie_rec(hDev,0,2,nword,iprint,py);     // read out 2 32 bits words
       if(iprint == 1) printf("receive data word = %x, %x \n", read_array[0], read_array[1]);
      }

//**

//
//    the ADC spi stream.. The 16 bits data before the last word is r/w, w1, w2 and 13 bits address
//                         the last 16 bits.upper byte = 8 bits data and lower 8 bits ignored.
//
       for (is=0; is<8; is++) {
        imod=11;
        ichip=5;
        buf_send[0]=(imod<<11)+(ichip<<8)+(mb_pmt_spi_add)+((is & 0xf)<<16); //set spi address
        i=1;
        k=1;
        i = pcie_send(hDev, i, k, px);
        usleep(2000);   // sleep for 2ms
        printf(" spi port %d \n",is);
//       scanf("%d",&ik);

        imod=11;
        ichip=5;
        buf_send[0]=(imod<<11)+(ichip<<8)+(mb_pmt_adc_data_load)+(0x0300<<16); //1st next word will be overwrite by the next next word
        buf_send[1]=(((0x0)<<13)+(0xd))+((0xa)<<24)+((0x0)<<16);
//        buf_send[1]=(((0x0)<<13)+(0xd))+((0x0)<<24)+((0x0)<<16);
//
//  set /w =0, w1,w2 =0, a12-a0 = 0xd, data =0xb;
//

        i=1;
        k=2;
        i = pcie_send(hDev, i, k, px);
        usleep(2000);   // sleep for 2ms
        printf(" spi port 2nd command %d \n",is);
//       scanf("%d",&ik);

        imod=11;
        ichip=5;
        buf_send[0]=(imod<<11)+(ichip<<8)+(mb_pmt_adc_data_load)+(0x0300<<16); //1st next word will be overwrite by the next next word
        buf_send[1]=(((0x0)<<13)+(0xff))+((0x1)<<24)+((0x0)<<16);
//
//  set /w =0, w1,w2 =0, a12-a0 = 0xff, data =0x1;
//  write to transfer register
//

        i=1;
        k=2;
        i = pcie_send(hDev, i, k, px);
        usleep(2000);   // sleep for 2ms

       }

//       printf(" enter 1 to continue FPGA ADC receiver reset\n");
//       scanf("%d",&ik);
//
//    send FPGA ADC receiver reset
//
       imod=11;
       ichip=3;
       buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_adc_reset+(0x1<<16);  // FPGA ADC receiver reset on
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);


//       printf(" enter 1 to continue FPGA ADC receiver align\n");
//       scanf("%d",&ik);
//
//    send FPGA ADC align
//
       imod=11;
       ichip=3;
       buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_adc_align+(0x0<<16);  // FPGA ADC receiver reset off
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);
       usleep(1000);

//       printf(" finish align \n");
//       scanf("%d",&ik);
//
//    the ADC spi stream.. The 16 bits data before the last word is r/w, w1, w2 and 13 bits address
//                         the last 16 bits.upper byte = 8 bits data and lower 8 bits ignored.
//
       for (is=0; is<8; is++) {
        imod=11;
        ichip=5;
        buf_send[0]=(imod<<11)+(ichip<<8)+(mb_pmt_spi_add)+((is & 0xf)<<16); //set spi address
        i=1;
        k=1;
        i = pcie_send(hDev, i, k, px);
        usleep(2000);   // sleep for 2ms
        printf(" spi port %d \n",is);
//       scanf("%d",&ik);

        imod=11;
        ichip=5;
        buf_send[0]=(imod<<11)+(ichip<<8)+(mb_pmt_adc_data_load)+(0x0300<<16); //1st next word will be overwrite by the next next word
//        buf_send[1]=(((0x0)<<13)+(0xd))+((0x9)<<24)+((0x0)<<16);
        buf_send[1]=(((0x0)<<13)+(0xd))+((0x0)<<24)+((0x0)<<16);
//
//  set /w =0, w1,w2 =0, a12-a0 = 0xd, data =0xb;
//

        i=1;
        k=2;
        i = pcie_send(hDev, i, k, px);
        usleep(2000);   // sleep for 2ms
        printf(" spi port 2nd command %d \n",is);
//       scanf("%d",&ik);

        imod=11;
        ichip=5;
        buf_send[0]=(imod<<11)+(ichip<<8)+(mb_pmt_adc_data_load)+(0x0300<<16); //1st next word will be overwrite by the next next word
        buf_send[1]=(((0x0)<<13)+(0xff))+((0x1)<<24)+((0x0)<<16);
//
//  set /w =0, w1,w2 =0, a12-a0 = 0xff, data =0x1;
//  write to transfer register
//

        i=1;
        k=2;
        i = pcie_send(hDev, i, k, px);
        usleep(2000);   // sleep for 2ms

       }




//**


//      printf(" enter 1 to continue \n");
//      scanf("%d",&ik);

      itrig_delay = 51;
      nword =1;
//
// set frame set to be 1023 --- there will be 1024/8 = 128 adc samples.
//
      if(itrig_c == 1) {
       imod=imod_trig;
       iframe= 1023;    //1023
       buf_send[0]=(imod<<11)+(mb_trig_frame_size)+((iframe & 0xffff)<<16); //set up frame size.
//       printf("buf_send =%x\n",buf_send[0]);
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);
      }
      else {
       imod=0;
       ichip=1;
       iframe= 1023;    //1023
       buf_send[0]=(imod<<11)+(ichip<<8)+(mb_cntrl_load_frame)+((iframe & 0xffff)<<16); //enable test mode
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);
      }

//
// set to not use any test generator
//
       imod=11;
       ichip=mb_feb_pass_add;
       buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_test_source+(0x0<<16);  // set test source to 0
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);

//
// load trig 1 position relative to the frame..
//
      if(itrig_c != 1) {
       imod=0;
       ichip=1;
       buf_send[0]=(imod<<11)+(ichip<<8)+(mb_cntrl_load_trig_pos)+((itrig_delay & 0xffff)<<16); //enable test mode
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);
      }

      imod=11;
      ichip=3;
      buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_a_nocomp+(0x1<<16);  // set a channel no compression
      i=1;
      k=1;
      i = pcie_send(hDev, i, k, px);

      timesize =40;
      imod=11;
      ichip=3;
      buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_timesize+(timesize<<16);  // set drift time size
      i=1;
      k=1;
      i = pcie_send(hDev, i, k, px);

      a_id =0x20;
      imod=11;
      ichip=3;
      buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_a_id+(a_id<<16);  // set a_id
      i=1;
      k=1;
      i = pcie_send(hDev, i, k, px);

      imod=11;
      ichip=3;
      buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_a_test+(0x1<<16);    // enable a test on
      i=1;
      k=1;
      i = pcie_send(hDev, i, k, px);

      if(itrig_c == 1) {
       imod=imod_trig;
       buf_send[0]=(imod<<11)+(mb_trig_run)+((0x1)<<16); //set up run
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);
      }
      else {
       imod=0;
       ichip=1;
       buf_send[0]=(imod<<11)+(ichip<<8)+(mb_cntrl_set_run_on)+(0x0<<16); //enable offline run on
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);
      }

//      printf(" enter 1 to continue (run on sync on \n");
//      scanf("%d",&ik);
      usleep(5000); //wait for 5 ms
      printf(" enter event trigger loop \n");


      for (is=0; is<nevent; is++) {


       if(itrig_c == 1) {
        imod =imod_trig;  /* trigger module */
        buf_send[0]=(imod<<11)+mb_trig_pctrig+((0x0)<<16);
        i=1;
        k=1;
        i = pcie_send(hDev, i, k, px);
       }
       else {
        imod=0;
        ichip=1;
        buf_send[0]=(imod<<11)+(ichip<<8)+mb_cntrl_set_trig1+(0x0<<16);  // send trigger
        i=1;
        k=1;
        i = pcie_send(hDev, i, k, px);
       }



//      set module number again to enable the FEB module read back

       imod=11;
       ichip=3;
       buf_send[0]=(imod<<11)+(ichip<<8)+6+(imod<<16);  // set module number
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);

       usleep(5000); // wait for 5 ms


       nword = 5;
       i = pcie_rec(hDev,0,1,nword,iprint,py);     // init the receiver
       imod=11;
       ichip=3;
       buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_a_rdhed+(0x1<<16);  // read a header
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);

       py = &read_array;
       i = pcie_rec(hDev,0,2,nword,iprint,py);     // read out 2 32 bits words
       
       if(iwrite ==1) fprintf(outf," %x, %x, %x, %x, %x\n", read_array[0], read_array[1], read_array[2], read_array[3], read_array[4]);        if(iprint ==1) printf("receive data word = %x, %x, %x, %x, %x\n", read_array[0], read_array[1], read_array[2], read_array[3], read_array[4]);
       if(iprint == 1) {
         printf(" header word %x \n",(read_array[0] & 0xffff));
         k=(read_array[0]>>16) & 0xfff;
         printf(" module adress %d, id number %d\n", (k & 0x1f), ((k>>5) & 0x7f));
         printf(" number of data word to read %d\n", (((read_array[1]>>16) & 0xfff)+((read_array[1] &0xfff) <<12)));
         printf(" event number %d\n", (((read_array[2]>>16) & 0xfff)+((read_array[2] &0xfff) <<12)));
         printf(" frame number %d\n", (((read_array[3]>>16) & 0xfff)+((read_array[3] &0xfff) <<12)));
         printf(" checksum %x\n", (((read_array[4]>>16) & 0xfff)+((read_array[4] &0xfff) <<12)));
       }
       nread = ((read_array[1]>>16) & 0xfff)+((read_array[1] &0xfff) <<12);
//        if(iprint ==1) printf(" number of data word to read = %d\n",nread);

//        ik =  read_array[0] & 0x1f;
//        if(iprint ==1) printf(" module number = %d",ik);
//        ik =  (read_array[0] >> 5) & 0x7f;
//        if(iprint ==1) printf(" data ID = %d",ik);
//        ik =  (((read_array[2] >>16) & 0xfff)<<12) + (read_array[2] & 0xfff);
//        if(iprint ==1) printf(" event number = %d",ik);
//        ik =  (((read_array[3] >>16) & 0xfff)<<12) + (read_array[3] & 0xfff);
//        if(iprint ==1) printf(" frame number = %d\n",ik);
//        ik =  (((read_array[4] >>16) & 0xfff)<<12) + (read_array[4] & 0xfff);
//        if(iprint ==1) printf(" checksum = %x\n",ik);

       if(iprint ==1 ) {
        printf(" enter 1 to continue \n");
        scanf("%d",&ik);
       }
       nword = (nread+1)/2;                    // short words
       i = pcie_rec(hDev,0,1,nword,iprint,py);     // init the receiver

       imod=11;
       ichip=mb_feb_pass_add;
       buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_a_rdbuf+(0x0<<16);  // read a header
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);

       py = &read_array;
       i = pcie_rec(hDev,0,2,nword,iprint,py);     // read out 2 32 bits words

       if(iprint == 1) {
        for (i=0; i< nword; i++) {
         if((i%8) ==0) printf("%4d",i);
         printf(" %8x",read_array[i]);
         if(((i+1)%8) ==0 ) printf("\n");
        }
       }
       if(iwrite == 1) {
        fprintf(outf," %d\n",nword);
        for (i=0; i< nword; i++) {
         if((i%8) ==0) fprintf(outf,"%4d",i);
         fprintf(outf," %8x",read_array[i]);
         if(((i+1)%8) ==0 ) fprintf(outf,"\n");
        }
        if(((i+1)*8) != 0)fprintf(outf,"\n");
       }

       ik=0;
       for (i=0; i< nword; i++) {
        read_array_s[ik] = read_array[i] &0xffff;
        read_array_s[ik+1] = ((read_array[i]>>16) & 0xffff);
        ik=ik+2;
       }

//
//      printout formatted word
//
       if(iprint ==1) {
        iset = 0;
        for(i=0; i< 2*nword; i++) {
         if((read_array_s[i] & 0xf000) == 0x4000) {
           iset=1;
           ncount=0;
           printf(" channel %d\n",(read_array_s[i] & 0xfff));
         }
         else if ((read_array_s[i] & 0xf000) == 0x5000) printf(" channel end %d\n",(read_array_s[i] &0xfff));
         else if (iset ==1) {
           printf(" %4x",read_array_s[i]);
           ncount = ncount+1;
           if((ncount%8) == 0) printf("\n");
         }
         else {
           printf("%x",read_array_s[i]);
           ncount = ncount+1;
           if((ncount%8) == 0) printf("\n");
         }
        }
       }
       if((iwrite == 1)&&((is%100) ==0)) printf("nevent = %d\n",is);
      }
      if(iprint == 1) {
       printf(" enter 1 to continue \n");
       scanf("%d",&ik);
      }
      if((iwrite == 1)&&((is%100) ==0)) printf("nevent = %d\n",is);

     }





    break;


    case 21:
     printf(" SuperNova readout test \n");
     printf(" enable number of loop\n");
     scanf("%d",&nloop);
     printf(" enter 1 to turn on huffman encoding \n");
     scanf("%d",&ihuff);
     printf("tyep 1 to compare with the 1st event\n");
     scanf("%d",&comp_s);

//     printf(" 1 for checking the event \n");
//     scanf("%d",&icheck);
//     printf(" type 1 to use random number \n");
//     scanf("%d",&irand);
     icheck =0;
     ifr=0;
     irand = 0;
     islow_read =0;
//     if(icheck != 1) {
//      printf(" 1 for print event\n");
//      scanf("%d",&iprint);
//    }
//     else iprint =0;
     iprint = 1;
//     printf(" number event \n");
//     scanf("%d",&nevent);

//     printf(" enter number of words per packet \n");
//     scanf("%d",&nsend);
     nsend=500;
     imod_xmit=10;

     px = &buf_send;
     py = &read_array;
     imod =0;  /* controller module */
/** initialize **/
     buf_send[0]=0x0;
     buf_send[1]=0x0;
     i=1;
     k=1;
     i = pcie_send(hDev, i, k, px);
// set offline test
     imod=0;
     ichip=1;
     buf_send[0]=(imod<<11)+(ichip<<8)+(mb_cntrl_test_on)+(0x0<<16); //enable offline run on
     i=1;
     k=1;
     i = pcie_send(hDev, i, k, px);
 //disable the run command
     imod=0;
     ichip=1;
     buf_send[0]=(imod<<11)+(ichip<<8)+(mb_cntrl_set_run_off)+(0x0<<16); //trun off run
     i=1;
     k=1;
     i = pcie_send(hDev, i, k, px);
 // turn on the Stratix III power supply
     imod=11;
     ichip =1;
     buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_power_add+(0x0<<16); //turn module 11 power on
     i=1;
     k=1;
     i = pcie_send(hDev, i, k, px);
     usleep(200000);  // wait for 200 ms
//     printf(" enable number of loop\n");
//     scanf("%d",&nloop);
     for (j=0; j<nloop; j++) {
      usleep(10000); // wait for 10ms

//
//    boot up xmit module 1st
//
      printf(" boot xmit module \n");
      inpf = fopen("../../xmit_fpga","r");
      imod=imod_xmit;
      ichip=mb_xmit_conf_add;
      buf_send[0]=(imod<<11)+(ichip<<8)+0x0+(0x0<<16);  // turn conf to be on
      i=1;
      k=1;
      i = pcie_send(hDev, i, k, px);
//      for (i=0; i<100000; i++) {
//          ik= i%2;
//          dummy1= (ik+i)*(ik+i);
//      }


        /* read data as characters (28941) */
      usleep(1000);   // wait fior a while
      count = 0;
      counta= 0;
      ichip_c = 7; // set ichip_c to stay away from any other command in the
      dummy1 =0;
      while (fread(&charchannel,sizeof(char),1,inpf)==1) {
       carray[count] = charchannel;
       count++;
       counta++;
       if((count%(nsend*2)) == 0) {
//        printf(" loop = %d\n",dummy1);
        buf_send[0] = (imod <<11) +(ichip_c <<8)+ (carray[0]<<16);
        send_array[0] =buf_send[0];
        if(dummy1 <= 5 ) printf(" counta = %d, first word = %x, %x, %x %x %x \n",counta,buf_send[0], carray[0], carray[1]
        ,carray[2], carray[3]);
        for (ij=0; ij< nsend; ij++) {
         if(ij== (nsend-1)) buf_send[ij+1] = carray[2*ij+1]+(0x0<<16);
         else buf_send[ij+1] = carray[2*ij+1]+ (carray[2*ij+2]<<16);
//         buf_send[ij+1] = carray[2*ij+1]+ (carray[2*ij+2]<<16);
         send_array[ij+1] = buf_send[ij+1];
        }
        nword =nsend+1;
        i=1;
//       if(dummy1 == 0)
        ij = pcie_send(hDev, i, nword, px);
        nanosleep(&tim , &tim2);
        dummy1 = dummy1+1;
        count =0;
       }
      }
      if(feof(inpf)) {
       printf("You have reached the end-of-file word count= %d %d\n", counta, count);
       buf_send[0] = (imod <<11) +(ichip_c <<8)+ (carray[0]<<16);
       if ( count > 1) {
        if( ((count-1)%2) ==0) {
         ik =(count-1)/2;
        }
        else {
         ik =(count-1)/2+1;
        }
        ik=ik+2;   // add one more for safety
        printf("ik= %d\n",ik);
        for (ij=0; ij<ik; ij++){
         if(ij == (ik-1)) buf_send[ij+1] = carray[(2*ij)+1]+(((imod<<11)+(ichip<<8)+0x0)<<16);
         else buf_send[ij+1] = carray[(2*ij)+1]+ (carray[(2*ij)+2]<<16);
         send_array[ij+1] = buf_send[ij+1];
        }
       }
       else ik=1;

           for (ij=ik-10; ij< ik+1; ij++) {
            printf("Last data = %d, %x\n",ij,buf_send[ij]);
           }

       nword =ik+1;
       i=1;
       i = pcie_send(hDev, i, nword, px);
      }
      usleep(2000);    // wait for 2ms to cover the packet time plus fpga init time
      fclose(inpf);
//
      printf(" xmit done, booting FEM \n");
      scanf("%d",&ik);

//
//    Boot stratix after XMIT module
//
      inpf = fopen("/home/ub/feb_fpga_test","r");
      imod=11;
      ichip=mb_feb_conf_add;
      buf_send[0]=(imod<<11)+(ichip<<8)+0x0+(0x0<<16);  // turn conf to be on
      i=1;
      k=1;
      i = pcie_send(hDev, i, k, px);
//      for (i=0; i<100000; i++) {
//          ik= i%2;
//          dummy1= (ik+i)*(ik+i);
//      }


        /* read data as characters (28941) */
      usleep(1000);   // wait fior a while
      count = 0;
      counta= 0;
      ichip_c = 7; // set ichip_c to stay away from any other command in the
      dummy1 =0;
      while (fread(&charchannel,sizeof(char),1,inpf)==1) {
       carray[count] = charchannel;
       count++;
       counta++;
       if((count%(nsend*2)) == 0) {
//        printf(" loop = %d\n",dummy1);
        buf_send[0] = (imod <<11) +(ichip_c <<8)+ (carray[0]<<16);
        send_array[0] =buf_send[0];
        if(dummy1 <= 5 ) printf(" counta = %d, first word = %x, %x, %x %x %x \n",counta,buf_send[0], carray[0], carray[1]
        ,carray[2], carray[3]);
        for (ij=0; ij< nsend; ij++) {
         if(ij== (nsend-1)) buf_send[ij+1] = carray[2*ij+1]+(0x0<<16);
         else buf_send[ij+1] = carray[2*ij+1]+ (carray[2*ij+2]<<16);
//         buf_send[ij+1] = carray[2*ij+1]+ (carray[2*ij+2]<<16);
         send_array[ij+1] = buf_send[ij+1];
        }
        nword =nsend+1;
        i=1;
//       if(dummy1 == 0)
        ij = pcie_send(hDev, i, nword, px);
        nanosleep(&tim , &tim2);
        dummy1 = dummy1+1;
        count =0;
       }
      }
      if(feof(inpf)) {
       printf("You have reached the end-of-file word count= %d %d\n", counta, count);
       buf_send[0] = (imod <<11) +(ichip_c <<8)+ (carray[0]<<16);
       if ( count > 1) {
        if( ((count-1)%2) ==0) {
         ik =(count-1)/2;
        }
        else {
         ik =(count-1)/2+1;
        }
        ik=ik+2;   // add one more for safety
        printf("ik= %d\n",ik);
        for (ij=0; ij<ik; ij++){
         if(ij == (ik-1)) buf_send[ij+1] = carray[(2*ij)+1]+(((imod<<11)+(ichip<<8)+0x0)<<16);
         else buf_send[ij+1] = carray[(2*ij)+1]+ (carray[(2*ij)+2]<<16);
         send_array[ij+1] = buf_send[ij+1];
        }
       }
       else ik=1;

           for (ij=ik-10; ij< ik+1; ij++) {
            printf("Last data = %d, %x\n",ij,buf_send[ij]);
           }

       nword =ik+1;
       i=1;
       i = pcie_send(hDev, i, nword, px);
      }
      usleep(2000);    // wait for 2ms to cover the packet time plus fpga init time
      fclose(inpf);
//
//    start testing routine
//
       printf(" enter 1 to reset the dram \n");
       scanf("%d",&ik);
 //      ik =1;
       if(ik ==1) {
         imod=11;
         ichip=3;
         buf_send[0]=(imod<<11)+(ichip<<8)+31+(0x1<<16);  // turm the DRAM reset on
         i=1;
         k=1;
         i = pcie_send(hDev, i, k, px);
         imod=11;
         ichip=3;
         buf_send[0]=(imod<<11)+(ichip<<8)+31+(0x0<<16);  // turm the DRAM reset off
         i=1;
         k=1;
         i = pcie_send(hDev, i, k, px);

         usleep(5000);    // wait for 5 ms for DRAM to be initialized

         imod=11;
         ichip=3;
         buf_send[0]=(imod<<11)+(ichip<<8)+6+(imod<<16);  // set module number
         i=1;
         k=1;
         i = pcie_send(hDev, i, k, px);


       }
//       printf(" enter 1 to read system status \n");
//       scanf("%d",&ik);
       ik=1;
       nword =1;
       if(ik ==1) {


         i = pcie_rec(hDev,0,1,nword,iprint,py);     // init the receiver

         imod=11;
         ichip=3;
         buf_send[0]=(imod<<11)+(ichip<<8)+20+(0x0<<16);  // read out status
         i=1;
         k=1;
         i = pcie_send(hDev, i, k, px);
         py = &read_array;
         i = pcie_rec(hDev,0,2,nword,iprint,py);     // read out 2 32 bits words
         printf("receive data word = %x, %x \n", read_array[0], read_array[1]);
       }
//       printf(" enter L1 trigger delay \n");
//       scanf("%d",&itrig_delay);
       itrig_delay = 51;
       nword =1;
//
// set to use test generator 2, set test =2
//
       imod=11;
       ichip=mb_feb_pass_add;
       buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_test_source+(0x2<<16);  // set test source to 2
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);
//
// set frame set to be 255 --- there will be 256/8 = 32 adc samples.
//
       imod=0;
       ichip=1;
       iframe= 255;    //1023
       buf_send[0]=(imod<<11)+(ichip<<8)+(mb_cntrl_load_frame)+((iframe & 0xffff)<<16); //enable test mode
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);


//
// load trig 1 position relative to the frame..
//
       imod=0;
       ichip=1;
       buf_send[0]=(imod<<11)+(ichip<<8)+(mb_cntrl_load_trig_pos)+((itrig_delay & 0xffff)<<16); //enable test mode
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);
//
//    start loading the test 2 data memory
//
       imod =11;
       ichip=3;
       for (is=0; is<64; is++) {
        ik = 0x4000+is;                        // load channel address
        buf_send[0]=(imod<<11)+(ichip<<8)+(mb_feb_test_ram_data)+((ik & 0xffff)<<16); //enable test mode
        i = pcie_send(hDev, 1, 1, px);
        ibase = 32*is;
        il = is%8;
        if(il == 0) printf(" loading channel %d\n",is);
        for (ik=0; ik< 256; ik++) {                 // loop over all possible address
         if(irand ==1) ijk = rand() & 0xfff ;        // use random number
         else ijk= (ibase+ik*8) & 0xfff;
//         if(ihuff == 1) {
           if((ik%4) ==0) ic =ijk;        // set data to repeat for 4 samples....
           ijk=ic;
//         }
         k = 0x8000+ ijk;        // make sure bit 15-12 is clear for the data
         buf_send[0]=(imod<<11)+(ichip<<8)+(mb_feb_test_ram_data)+((k & 0xffff)<<16); //enable test mode
         i = pcie_send(hDev, 1, 1, px);
         send_array[is*256+ik]=ijk;           //load up data map
        }
       }

       imod=11;
       ichip=3;
       if(ihuff == 1) buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_b_nocomp+(0x0<<16);  // turn the compression
       else buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_b_nocomp+(0x1<<16);  // set b channel no compression
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);

       timesize =4;
       imod=11;
       ichip=3;
       buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_timesize+(timesize<<16);  // set drift time size
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);

       a_id =0xf;
       imod=11;
       ichip=3;
       buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_b_id+(a_id<<16);  // set a_id
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);

       imod=11;
       ichip=4;
       buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_b_id+(a_id<<16);  // set a_id
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);
//
//     set max word in the pre-buffer memory
//
       ik=8000;
       imod=11;
       ichip=3;
       buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_max+(ik<<16);  // set pre-buffer max word
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);

//       imod=11;
//       ichip=3;
//       buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_a_test+(0x1<<16);    // enable a test on
//       i=1;
//       k=1;
//       if(islow_read == 1) i = pcie_send(hDev, i, k, px);


       imod=11;
       ichip=4;
       buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_lst_on+(0x0<<16);    // set last module on
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);

       imod=11;
       ichip=4;
       buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_rxreset+(0x0<<16);    // reset LINKIN DPA
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);

//
//     set up xmit module  -- module count
//
       imod=imod_xmit;
       ichip=3;
       buf_send[0]=(imod<<11)+(ichip<<8)+mb_xmit_modcount+(0x0<<16);  // set number of module to 1 to enable output
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);
//
//     rest optical
//
       imod=imod_xmit;
       ichip=3;
       buf_send[0]=(imod<<11)+(ichip<<8)+mb_opt_dig_reset+(0x1<<16);  // set optical reset on
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);
//
//     enable superNova Token Passing
//
       imod=imod_xmit;
       ichip=3;
       buf_send[0]=(imod<<11)+(ichip<<8)+mb_xmit_enable_2+(0x1<<16);  // enable token 1 pass
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);
//
//
       printf(" enter 1 to reset the DPA \n");
       scanf("%d",&ik);

//
//     reset XMIT LINK IN DPA
//
       imod=imod_xmit;
       ichip=3;
       buf_send[0]=(imod<<11)+(ichip<<8)+mb_xmit_link_reset+(0x1<<16);  //  reset XMIT LINK IN DPA
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);
//
//     wait for 10ms just in case
//
       usleep(10000);
       printf(" XMIT FIFO reset \n");
//
//     reset XMIT FIFO reset
//
       imod=imod_xmit;
       ichip=3;
       buf_send[0]=(imod<<11)+(ichip<<8)+mb_xmit_dpa_fifo_reset+(0x1<<16);  //  reset XMIT LINK IN DPA
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);

//
//
//

       for (is=0; is<1; is++) {
//
//      test re-align circuit
//
        imod=imod_xmit;
        ichip=3;
        buf_send[0]=(imod<<11)+(ichip<<8)+mb_xmit_dpa_word_align+(0x1<<16);  //  send alignment pulse
        i=1;
        k=1;
        i = pcie_send(hDev, i, k, px);

//        printf(" enter 1 to set continue on re-align circuit \n");
//        scanf("%d",&ik);
       }

       usleep(5000); //wait for 5 ms
       printf(" XMIT re-align done \n");

       dwDMABufSize = 200000;
       if(ifr ==0) {
        ifr=1;
        printf(" buffer allocation \n");
        dwStatus = WDC_DMAContigBufLock(hDev2, &pbuf_rec, dwOptions_rec, dwDMABufSize, &pDma_rec);
        if (WD_STATUS_SUCCESS != dwStatus) {
         printf("Failed locking a rec Contiguous DMA buffer. Error 0x%lx - %s\n", dwStatus, Stat2Str(dwStatus));
         printf("enter 1 to continue \n");
         scanf("%d",&is);
        }
       }

/* set tx mode register */

       u32Data = 0xf0000fff;
       dwOffset = tx_md_reg;
       dwAddrSpace =cs_bar;
       WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);

/* write this will abort previous DMA */
       dwAddrSpace =2;
       dwOffset = cs_dma_msi_abort;
       u32Data = dma_abort;
       WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);
/* clear DMA register after the abort */
       dwAddrSpace =2;
       dwOffset = cs_dma_msi_abort;
       u32Data = 0;
       WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);

       buffp_rec32 = pbuf_rec;

/* synch cache */
       WDC_DMASyncCpu(pDma_rec);
       printf(" synch CPU \n");
///
///    set up the DMA size  (half buffer size limit??)
///
       nwrite =(dwDMABufSize/8);  //remove factor 2 
//       nwrite = 4000;

       for (is=1; is<3; is++) {
        tr_bar = t1_tr_bar;
        r_cs_reg = r1_cs_reg;
        dma_tr = dma_tr1;
        if(is == 2) {
         tr_bar = t2_tr_bar;
         r_cs_reg = r2_cs_reg;
         dma_tr = dma_tr2;
        }
        printf(" is = %d\n",is);
/** initialize the receiver ***/
        u32Data = cs_init;
        dwOffset = r_cs_reg;
        dwAddrSpace =cs_bar;
        WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);
/** start the receiver **/
        dwAddrSpace = cs_bar;
        u32Data = cs_start+(nwrite*2)*4;   /* 32 bits mode == 4 bytes per word *2 fibers **/
        dwOffset = r_cs_reg;
        WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);
       }
       printf(" initial receiver \n");
       scanf("%d",&ik);
/** set up DMA for both transceiver together **/

       dwAddrSpace =cs_bar;
       dwOffset = cs_dma_add_low_reg;
       u32Data = pDma_rec->Page->pPhysicalAddr & 0xffffffff;
       WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);

       dwAddrSpace =cs_bar;
       dwOffset = cs_dma_add_high_reg;
       u32Data = (pDma_rec->Page->pPhysicalAddr >> 32) & 0xffffffff;
       WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);

/* byte count */
       dwAddrSpace =cs_bar;
       dwOffset = cs_dma_by_cnt;
       u32Data = (nwrite)*4*2;      /** twice more data - from fiber 1& 2**/
       WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);


/* write this will start DMA */
       dwAddrSpace =2;
       dwOffset = cs_dma_cntrl;
       u32Data = dma_tr12+dma_4dw_rec;
       WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);
       printf(" DMA set up done \n");

//
//      turn the run on to start data flow
//
       printf(" enter 1 to set the RUN on \n");
       scanf("%d",&ik);

       imod=0;
       ichip=1;
       buf_send[0]=(imod<<11)+(ichip<<8)+(mb_cntrl_set_run_on)+(0x0<<16); //enable offline run on
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);

/***    check to see if DMA is done or not **/
       idone =0;
       for (is=0; is<2000; is++) {;
          dwAddrSpace =cs_bar;
 	  u64Data =0;
	  dwOffset = cs_dma_cntrl;
          WDC_ReadAddr32(hDev2, dwAddrSpace, dwOffset, &u32Data);
	  printf(" receive DMA status word %d %X \n", is, u32Data);
	  if((u32Data & dma_in_progress) == 0) {
            idone =1;
            printf(" receive DMA complete %d \n", i);
          }
	  if((u32Data & dma_in_progress) == 0) break;
       }
	/* synch DMA i/O cache **/

       WDC_DMASyncIo(pDma_rec);
//
       dwAddrSpace =cs_bar;
       u64Data =0;
       dwOffset = t1_cs_reg;
       WDC_ReadAddr64(hDev2, dwAddrSpace, dwOffset, &u64Data);
       printf (" status word for channel 1 after read = %x, %x \n",(u64Data>>32), (u64Data &0xffff));
       dwAddrSpace =cs_bar;
       u64Data =0;
       dwOffset = t2_cs_reg;
       WDC_ReadAddr64(hDev2, dwAddrSpace, dwOffset, &u64Data);
       printf (" status word for channel 2 after read = %x, %x \n",(u64Data>>32), (u64Data &0xffff));

//
       for (is=0; is<nwrite*2; is++) {
         read_array[is]= *buffp_rec32++;
       }

       for (is=0; is< nwrite*2; is++) {
        if((is%8) ==0) printf("%4d",is);
        printf(" %8x",read_array[is]);
        if(((is+1)%8) ==0 ) printf("\n");
       }
       if(((is+1)*8) != 0)printf("\n");

       for(is=0; is< nwrite; is++) {
         read_array_s[is*2] = (read_array[is] & 0xffff);
         read_array_s[is*2+1] = ((read_array[is] >>16) & 0xffff);
       }
       nread = ((read_array_s[4] & 0xfff) << 12)+ (read_array_s[5] & 0xfff);
       nread =nread+1;
       nread = nread/2;
       for (is=0; is< nread+7; is++) {       // 6 header + 1 trailer.
        read_comp[is] = read_array[is];
       }

       icomp_l = nwrite/nread; // only compare complete event
       printf(" compare %d of event in the loop \n",icomp_l);
       if(comp_s == 1) {
        for(is=0; is<icomp_l; is++) {
         for (ik=6; ik< nread+6; ik++) {   //for the moment skip header
          k=ik+is*(nread+7);
          if(read_comp[ik] != read_array[k]) {
            printf(" data error %d %d, first event data word = %8x, data = %8x \n", ik,k,read_comp[ik], read_array[k]);
            scanf("%d",&k);
          }
         }
        }
       }

       is=0;
       while (is < nwrite*2) {
         if(((nwrite*2)-is) <= 12) printf(" not enough word header \n");
         if(((nwrite*2)-is) <= 12) break;
         if((read_array_s[is] == 0xffff) && (read_array_s[is+1] == 0xffff)) {
          printf(" event header %8x \n", read_array_s[is]+(read_array_s[is+1] << 16));
          is=is+2;
          printf(" module header = %4x\n", read_array_s[is]);
          is=is+1;
          printf(" address word = %4x, aid = %2x, module numebr %3d\n", read_array_s[is], ((read_array_s[is]>>5) &0x7f), (read_array_s[is] &0x1f));
          is=is+1;
          ik= (read_array_s[is]<<16)+ (read_array_s[is+1]);
          nread=  ((read_array_s[is] & 0xfff) << 12)+ (read_array_s[is+1] & 0xfff);
          nread = nread+1;
          printf(" word count word = %8x, word count = %8d \n", ik,nread);
          is = is+2;
          ik= (read_array_s[is]<<16)+ (read_array_s[is+1]);
          k=  ((read_array_s[is] & 0xfff) << 12)+ (read_array_s[is+1] & 0xfff);
          printf(" event number word = %8x, event number = %8d \n", ik,k);
          is = is+2;
          ik= (read_array_s[is]<<16)+ (read_array_s[is+1]);
          k=  ((read_array_s[is] & 0xfff) << 12)+ (read_array_s[is+1] & 0xfff);
          printf(" frame number word = %8x, frame number = %8d \n", ik,k);
          is =is+2;
          ik= (read_array_s[is]<<16)+ (read_array_s[is+1]);
          k=  ((read_array_s[is] & 0xfff) << 12)+ (read_array_s[is+1] & 0xfff);
          printf(" checksum word = %8x, checksum = %8x \n", ik,k);
          is=is+2;
         if(((nwrite*2)-is) <= (nread+2)) printf(" not enough word for the event \n");
         if(((nwrite*2)-is) <= (nread+2)) break;
          is=is+nread;
          printf("end of packet word, %8x \n", read_array_s[is]+ (read_array_s[is+1]<<16));
          is = is+2;
          scanf("%d", &ik);
         }
       }

       imod=0;
       ichip=1;
       buf_send[0]=(imod<<11)+(ichip<<8)+(mb_cntrl_set_run_off)+(0x0<<16); //enable offline run off
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);
       scanf("%d",&ik);
      }

     break;


    case 22:
     printf(" PMT fake data testing \n");
     printf(" type 1 to use the new code \n");
     scanf("%d",&inewcode);
     printf(" enable number of loop\n");
     scanf("%d",&nloop);
     printf(" number event \n");
     scanf("%d",&nevent);
     printf(" type 1 to use trigger module for pulser\n");
     scanf("%d", &itrig_ext);
     if(itrig_ext == 1) {
      printf(" type 1 to use trigger module as pulse, 2 for fixed frame trigger \n");
      scanf("%d", &itrig_pulse);
      if (itrig_pulse == 1) {
       printf(" enter pulse 1 delay \n");
       scanf("%d", &p1_delay);
       printf(" enter pulse 1 width \n");
       scanf("%d", &p1_width);
       printf(" enter pulse 2 delay \n");
       scanf("%d", &p2_delay);
       printf(" enter pulse 2 width \n");
       scanf("%d", &p2_width);
       printf(" enter trigger delay (<7)\n");
       scanf("%d", &pulse_trig_delay);
      }
     }
     printf(" type 1 to set up PMT ADC \n");
     scanf("%d", &use_pmt);
     if(use_pmt == 1) {
      printf(" type 1 to fire test pulse  \n");
      scanf("%d", &pmt_testpulse);
      if(pmt_testpulse == 1) {
       printf(" type 1 to step through DAC \n");
       scanf("%d", &pmt_dac_scan);
       if(pmt_dac_scan != 1) {
        printf(" enter DAC value \n");
        scanf("%d",&idac_shaper);
       }
      }
      else idac_shaper = 256;
     }

     icheck = 0;
     irand =0;
     iprint=1;
     imod_trig = 2;
     imod_shaper =3;
     itrig_delay = 51;
     imod_fem = 7;
     //imod_fem = 11;
     iframe= 2047; //8191;    //1023
//     pmt_deadtime = 20;
//     pmt_deadtime =  ///set deadtime long so it will not double fired on trailling edge
     pmt_mich_window = 2;
     printf(" PMT ADC module address = %d \n", imod_fem);
     printf(" Shaper address = %d \n", imod_shaper);
     printf(" Trigger module address = %d \n", imod_trig);
//
//
     threshold0 = 100;   // 100 discriminator threshold 0
     threshold1 = 150;   // 150 discriminator threshold 1
     cos_mult = 1;       // cosmic ray multiplicity threshold
     cos_thres = 20;    // cosmic ray sum ph threshold
     pmt_precount=1;   // set PMT precount
     pmt_words=40;     // number of word to read
     pmt_deadtime = 41;
//     pmt_deadtime =  ///set deadtime long so it will not double fired on trailling edge
     pmt_mich_window = 2;
//
//
     printf(" type 1 for write the event \n");
     scanf("%d", &iwrite);
     if(iwrite == 1) {
       iprint = 0;
       outf = fopen("./test_pmt.dat","w");
     }


//     if(icheck != 1) {
//      printf(" 1 for print event\n");
//      scanf("%d",&iprint);
//     }
//     else iprint =0;
//     printf(" enter number of words per packet \n");
//     scanf("%d",&nsend);
     nsend=500;

     px = &buf_send;
     py = &read_array;
     imod =0;  /* controller module */
/** initialize **/
     buf_send[0]=0x0;
     buf_send[1]=0x0;
     i=1;
     k=1;
     i = pcie_send(hDev, i, k, px);
// set offline test
     imod=0;
     ichip=1;
     buf_send[0]=(imod<<11)+(ichip<<8)+(mb_cntrl_test_on)+(0x0<<16); //enable offline run on
     i=1;
     k=1;
     i = pcie_send(hDev, i, k, px);
     printf("Initial PCIE command...\n");

//
//
//
     printf("Turning off trigger...\n");
    if(itrig_ext == 1) {
 //
 //  set trigger module run off
 //
      imod=imod_trig;
      buf_send[0]=(imod<<11)+(mb_trig_run)+((0x0)<<16); //set up run off
      i=1;
      k=1;
      i = pcie_send(hDev, i, k, px);
 //
 //  set trigger module dead time size
 //
      imod=imod_trig;
      buf_send[0]=(imod<<11)+(mb_trig_deadtime_size)+(0x1<<16); //set trigger module deadtime size
      i=1;
      k=1;
      i = pcie_send(hDev, i, k, px);
 // set offline test
      imod=0;
      ichip=1;
      buf_send[0]=(imod<<11)+(ichip<<8)+(mb_cntrl_test_off)+(0x0<<16); //set controller test off
      i=1;
      k=1;
      i = pcie_send(hDev, i, k, px);

     }
     else {
//
//disable the run command
//
      imod=0;
      ichip=1;
      buf_send[0]=(imod<<11)+(ichip<<8)+(mb_cntrl_set_run_off)+(0x0<<16); //enable offline run on
      i=1;
      k=1;
      i = pcie_send(hDev, i, k, px);
//
// load trig 1 position relative to the frame..
//
      imod=0;
      ichip=1;
      buf_send[0]=(imod<<11)+(ichip<<8)+(mb_cntrl_load_trig_pos)+((itrig_delay & 0xffff)<<16); //enable test mode
      i=1;
      k=1;
      i = pcie_send(hDev, i, k, px);
     }
    printf("Trigger turned off...\n");
    printf("Configuring PMT FPGA...\n");
 // turn on the Stratix III power supply
     imod=imod_fem;
     ichip =1;
     buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_power_add+(0x0<<16); //turn module 11 power on
     i=1;
     k=1;
     i = pcie_send(hDev, i, k, px);
     usleep(200000);  // wait for 200 ms
//     printf(" enable number of loop\n");
//     scanf("%d",&nloop);
     for ( iv=0; iv<nloop; iv++) {
      usleep(10000); // wait for 10ms
//      if(inewcode ==1 ) inpf = fopen("/home/ub/feb_pmt_fpga_test_new","r");
      if(inewcode ==1 ) inpf = fopen("../../feb_pmt_fpga_latest","r");
      else inpf = fopen("../../feb_pmt_fpga_default","r");
      imod=imod_fem;
      ichip=mb_feb_conf_add;
      buf_send[0]=(imod<<11)+(ichip<<8)+0x0+(0x0<<16);  // turn conf to be on
      i=1;
      k=1;
      i = pcie_send(hDev, i, k, px);
//      for (i=0; i<100000; i++) {
//          ik= i%2;
//          dummy1= (ik+i)*(ik+i);
//      }


        /* read data as characters (28941) */
      usleep(1000);   // wait fior a while
      count = 0;
      counta= 0;
      ichip_c = 7; // set ichip_c to stay away from any other command in the
      dummy1 =0;
      while (fread(&charchannel,sizeof(char),1,inpf)==1) {
       carray[count] = charchannel;
       count++;
       counta++;
       if((count%(nsend*2)) == 0) {
//        printf(" loop = %d\n",dummy1);
        buf_send[0] = (imod <<11) +(ichip_c <<8)+ (carray[0]<<16);
        send_array[0] =buf_send[0];
        if(dummy1 <= 5 ) printf(" counta = %d, first word = %x, %x, %x %x %x \n",counta,buf_send[0], carray[0], carray[1]
        ,carray[2], carray[3]);
        for (ij=0; ij< nsend; ij++) {
         if(ij== (nsend-1)) buf_send[ij+1] = carray[2*ij+1]+(0x0<<16);
         else buf_send[ij+1] = carray[2*ij+1]+ (carray[2*ij+2]<<16);
//         buf_send[ij+1] = carray[2*ij+1]+ (carray[2*ij+2]<<16);
         send_array[ij+1] = buf_send[ij+1];
        }
        nword =nsend+1;
        i=1;
//       if(dummy1 == 0)
        ij = pcie_send(hDev, i, nword, px);
        nanosleep(&tim , &tim2);
        dummy1 = dummy1+1;
        count =0;
       }
      }
      if(feof(inpf)) {
       printf("You have reached the end-of-file word count= %d %d\n", counta, count);
       buf_send[0] = (imod <<11) +(ichip_c <<8)+ (carray[0]<<16);
       if ( count > 1) {
        if( ((count-1)%2) ==0) {
         ik =(count-1)/2;
        }
        else {
         ik =(count-1)/2+1;
        }
        ik=ik+2;   // add one more for safety
        printf("ik= %d\n",ik);
        for (ij=0; ij<ik; ij++){
         if(ij == (ik-1)) buf_send[ij+1] = carray[(2*ij)+1]+(((imod<<11)+(ichip<<8)+0x0)<<16);
         else buf_send[ij+1] = carray[(2*ij)+1]+ (carray[(2*ij)+2]<<16);
         send_array[ij+1] = buf_send[ij+1];
        }
       }
       else ik=1;

       for (ij=ik-10; ij< ik+1; ij++) {
            printf("Last data = %d, %x\n",ij,buf_send[ij]);
       }

       nword =ik+1;
       i=1;
       i = pcie_send(hDev, i, nword, px);
      }
      usleep(2000);    // wait for 2ms to cover the packet time plus fpga init time
      fclose(inpf);
      printf("Configured PMT FPGA...\n");
//
//
//
      printf(" enter 1 to reset the dram \n");
      scanf("%d",&ik);
 //      ik =1;
      if(ik ==1) {
        imod=imod_fem;
        ichip=3;
        buf_send[0]=(imod<<11)+(ichip<<8)+31+(0x1<<16);  // turm the DRAM reset on
        i=1;
        k=1;
        i = pcie_send(hDev, i, k, px);
        imod=imod_fem;
        ichip=3;
        buf_send[0]=(imod<<11)+(ichip<<8)+31+(0x0<<16);  // turm the DRAM reset off
        i=1;
        k=1;
        i = pcie_send(hDev, i, k, px);

        usleep(5000);    // wait for 5 ms for DRAM to be initialized
        imod=imod_fem;
        ichip=3;
        buf_send[0]=(imod<<11)+(ichip<<8)+6+(imod<<16);  // set module number
        i=1;
        k=1;
        i = pcie_send(hDev, i, k, px);


      }
//       printf(" enter 1 to read system status \n");
//       scanf("%d",&ik);

      ik=1;
      nword =1;
      if(ik ==1) {


        i = pcie_rec(hDev,0,1,nword,iprint,py);     // init the receiver

        imod=imod_fem;
        ichip=3;
        buf_send[0]=(imod<<11)+(ichip<<8)+20+(0x0<<16);  // read out status
        i=1;
        k=1;
        i = pcie_send(hDev, i, k, px);
        py = &read_array;
        i = pcie_rec(hDev,0,2,nword,iprint,py);     // read out 2 32 bits words
        printf("receive data word = %x, %x \n", read_array[0], read_array[1]);
      }
//
//     set PMT inhibit size to 625
//
//      imod=imod_fem;
//      ichip=3;
//      buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_pmt_inhib_size+(625<<16);  // set module number
//      i=1;
//      k=1;
//      i = pcie_send(hDev, i, k, px);
//
      for (is =0; is< 48; is++) {

       imod=imod_fem;
       ichip=3;

       buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_pmt_ch_set+(is<<16);  // set channel number to be download
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);

       usleep(100);

//     set PMT delay 0 to 4
//
       imod=imod_fem;
       ichip=3;
       idelay0=4;
       buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_pmt_delay0+(idelay0<<16);  // set delay0
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);
//
//     set PMT delay1 to 12
//
       imod=imod_fem;
       ichip=3;
       idelay1=12;
       buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_pmt_delay1+(idelay1<<16);  // set delay 1
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);

//
//     set PMT precount
//
       imod=imod_fem;
       ichip=3;
       buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_pmt_precount+(pmt_precount<<16);  // set pmt precount
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);
//
//
//      for (is =0; is< 40; is++) {
//
//     set PMT threshold 0 to 10
//
       imod=imod_fem;
       ichip=3;
//      threshold0=100;
       if(is <= 39) {
         buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_pmt_thresh0+((threshold0+is)<<16);  // set threshold 0
       }
       else {
         buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_pmt_thresh0+((1000)<<16);  // set beam threshold to 1000
       }
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);
//
//     set PMT threshold 1 to 20
//
       imod=imod_fem;
       ichip=3;
//      threshold1=150;
       if(is <= 39) {
        buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_pmt_thresh1+((threshold1+is)<<16);  // set threshold 1
       }
       else {
        buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_pmt_thresh1+((1000)<<16);  // set threshold 1
       }
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);

//
//     set PMT data words to 40
//
       imod=imod_fem;
       ichip=3;
       buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_pmt_words+(pmt_words<<16);  // set pmt_words
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);

//
//     set PMT deadtime
//
       imod=imod_fem;
       ichip=3;
       buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_pmt_deadtime+(pmt_deadtime<<16);  // set pmt_words
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);
//
//     set PMT Michael window
//
       imod=imod_fem;
       ichip=3;
       buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_pmt_window+(pmt_mich_window<<16);  // set pmt_words
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);
      }
//
//     set PMT cosmic ray trigger multiplicity to 2
//
      imod=imod_fem;
      ichip=3;
//      cos_mult=2;
      buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_pmt_cos_mul+(cos_mult<<16);  // set cosmic ray trigger mul
      i=1;
      k=1;
      i = pcie_send(hDev, i, k, px);
//
//     set PMT cosmic ray trigger pulse height
//
      imod=imod_fem;
      ichip=3;
//      cos_thres=20;
      buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_pmt_cos_thres+(cos_thres<<16);  // set cosmic ray trigger peak
      i=1;
      k=1;
      i = pcie_send(hDev, i, k, px);
//
//     disable the top chanell
//
      imod=imod_fem;
      ichip=3;
      en_top=0xff;
      buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_pmt_en_top+(en_top<<16);  // enable/disable channel
      i=1;
      k=1;
      i = pcie_send(hDev, i, k, px);
//
//     disable the upper chanell
//
      imod=imod_fem;
      ichip=3;
      en_upper=0xffff;
      buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_pmt_en_upper+(en_upper<<16);  // enable/disable channel
      i=1;
      k=1;
      i = pcie_send(hDev, i, k, px);
//
//     enable all lower channel
//
      imod=imod_fem;
      ichip=3;
      en_lower=0xffff;
      buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_pmt_en_lower+(en_lower<<16);  // enable/disable channel
      i=1;
      k=1;
      i = pcie_send(hDev, i, k, px);
//
//     set maximum block size
//
      imod=imod_fem;
      ichip=3;
      buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_pmt_blocksize+(0xffff<<16);  // set max block size
      i=1;
      k=1;
      i = pcie_send(hDev, i, k, px);
      if(inewcode != 0) {
//
//    set beam data recording gate size
//
       imod=imod_fem;
       ichip=3;
       buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_pmt_gate_size+(0x50<<16);  // set gate size
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);
//
//    set beam delay
//
       imod=imod_fem;
       ichip=3;
       buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_pmt_beam_delay+(0x30<<16);  // set gate size
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);
//
//    set beam size window
//
       imod=imod_fem;
       ichip=3;
       buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_pmt_beam_size+(0x40<<16);  // set beam size
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);
//
//    set trigger input delay
//
       imod=imod_fem;
       ichip=3;
       buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_pmt_trig_delay+(0x20<<16);  // set beam size
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);
//
//
//
//    set beam data recording gate size
//
       imod=imod_fem;
       ichip=3;
       buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_pmt_gate1_size+(0x50<<16);  // set gate size
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);
//
//    set beam delay
//
       imod=imod_fem;
       ichip=3;
       buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_pmt_beam1_delay+(0x30<<16);  // set gate size
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);
//
//    set beam size window
//
       imod=imod_fem;
       ichip=3;
       buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_pmt_beam1_size+(0x40<<16);  // set beam size
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);
//
//    set trigger input delay
//
       imod=imod_fem;
       ichip=3;
       buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_pmt_trig1_delay+(0x20<<16);  // set beam size
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);

      }

     if(itrig_ext == 1) {
      imod=imod_trig;
//      iframe= 511;    //1023
      buf_send[0]=(imod<<11)+(mb_trig_frame_size)+((iframe & 0xffff)<<16); //set up frame size.
      i=1;
      k=1;
      i = pcie_send(hDev, i, k, px);
     }
     else {
//
// set frame set to be 1023 --- there will be 1023/8 = 128 adc samples.
//
      imod=0;
      ichip=1;
//      iframe= 511;    //1023
      buf_send[0]=(imod<<11)+(ichip<<8)+(mb_cntrl_load_frame)+((iframe & 0xffff)<<16); // set frame length
      i=1;
      k=1;
      i = pcie_send(hDev, i, k, px);
     }
//
//
//
     if(itrig_ext == 1) {
//
//    set mask1 bit 3 high
//
      imod=imod_trig;
      buf_send[0]=(imod<<11)+(mb_trig_mask1)+(0x8<<16); //set mask1[3] on.
      i=1;
      k=1;
      i = pcie_send(hDev, i, k, px);
//
//    set prescale1 to 0
//
      imod=imod_trig;
      buf_send[0]=(imod<<11)+(mb_trig_prescale1)+(0x0<<16); //set prescale1 0
      i=1;
      k=1;
      i = pcie_send(hDev, i, k, px);
     }

//
//     set a channel no compression
//
      imod=imod_fem;
      ichip=3;
      buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_a_nocomp+(0x1<<16);  // set a channel no compression
      i=1;
      k=1;
      i = pcie_send(hDev, i, k, px);
 //
 //     set a_test on  -- slow readback
 //
      imod=imod_fem;
      ichip=3;
      buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_a_test+(0x1<<16);    // enable slow readback
      i=1;
      k=1;
      i = pcie_send(hDev, i, k, px);
//
//     set a_id
//
      a_id =0x20;
      imod=imod_fem;
      ichip=3;
      buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_a_id+(a_id<<16);  // set a_id
      i=1;
      k=1;
      i = pcie_send(hDev, i, k, px);

      if(use_pmt == 1) {
//
//     work on the ADC -- set reset pulse
//
       imod=imod_fem;
       ichip=5;
       buf_send[0]=(imod<<11)+(ichip<<8)+(mb_pmt_adc_reset)+(0x0<<16); // reset goes high
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);
       imod=imod_fem;
       ichip=5;
       buf_send[0]=(imod<<11)+(ichip<<8)+(mb_pmt_adc_reset)+(0x1<<16); // reset goes low
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);
       imod=imod_fem;
       ichip=5;
       buf_send[0]=(imod<<11)+(ichip<<8)+(mb_pmt_adc_reset)+(0x0<<16); // reset goes high
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);
//
//      enable ADC clock,
//
       imod=imod_fem;
       ichip=5;
       buf_send[0]=(imod<<11)+(ichip<<8)+(mb_pmt_spi_add)+(0x7<<16); //set spi address
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);
       imod=imod_fem;
       ichip=5;
       buf_send[0]=(imod<<11)+(ichip<<8)+(mb_pmt_adc_data_load)+(0xffff<<16); //load spi data, clock gate enable
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);
//
//        load ADC sync data pattern  + set MSB 1st
//
       for (is=1; is<7; is++) {
        imod=imod_fem;
        ichip=5;
        buf_send[0]=(imod<<11)+(ichip<<8)+(mb_pmt_spi_add)+((is & 0xf)<<16); //set spi address
        i=1;
        k=1;
        i = pcie_send(hDev, i, k, px);
        imod=imod_fem;
        ichip=5;
        buf_send[0]=(imod<<11)+(ichip<<8)+(mb_pmt_adc_data_load)+(0x0b00<<16); //sync pattern, b for sync, 7 for skew, 3 for normal
        i=1;
        k=1;
        i = pcie_send(hDev, i, k, px);
        imod=imod_fem;
        ichip=5;
        buf_send[0]=(imod<<11)+(ichip<<8)+(mb_pmt_adc_data_load)+(0x1400<<16); //msb 1st
        i=1;
        k=1;
        i = pcie_send(hDev, i, k, px);
       }
       printf(" enter 1 to continue FPGA ADC receiver reset\n");
       scanf("%d",&ik);
//
//    send FPGA ADC receiver reset
//
       imod=imod_fem;
       ichip=3;
       buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_pmt_rxreset+(0x1<<16);  // FPGA ADC receiver reset on
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);
//
//      readback status
//
       i = pcie_rec(hDev,0,1,nword,iprint,py);     // init the receiver

       imod=imod_fem;
       ichip=3;
       buf_send[0]=(imod<<11)+(ichip<<8)+20+(0x0<<16);  // read out status
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);
       py = &read_array;
       i = pcie_rec(hDev,0,2,nword,iprint,py);     // read out 2 32 bits words
       printf("receive data word -- after reset = %x, %x \n", read_array[0], read_array[1]);
       printf(" module = %d, command = %d \n", ((read_array[0]>>11) & 0x1f), (read_array[0] &0xff));
       printf(" ADC right dpa lock     %d \n", ((read_array[0]>>17) & 0x1));
       printf(" ADC left  dpa lock     %d \n", ((read_array[0]>>18) & 0x1));
       printf(" block error 2          %d \n", ((read_array[0]>>19) & 0x1));
       printf(" block error 1          %d \n", ((read_array[0]>>20) & 0x1));
       printf(" pll lcoked             %d \n", ((read_array[0]>>21) & 0x1));
       printf(" superNova mem ready    %d \n", ((read_array[0]>>22) & 0x1));
       printf(" beam      mem ready    %d \n", ((read_array[0]>>23) & 0x1));
       printf(" ADC right PLL locked   %d \n", ((read_array[0]>>24) & 0x1));
       printf(" ADC left PLL locked    %d \n", ((read_array[0]>>25) & 0x1));
       printf(" ADC align cmd right    %d \n", ((read_array[0]>>26) & 0x1));
       printf(" ADC align cmd left     %d \n", ((read_array[0]>>27) & 0x1));
       printf(" ADC align done right   %d \n", ((read_array[0]>>28) & 0x1));
       printf(" ADC align done left    %d \n", ((read_array[0]>>29) & 0x1));
       printf(" Neutrino data empty    %d \n", ((read_array[0]>>30) & 0x1));
       printf(" Neutrino Header empty  %d \n", ((read_array[0]>>31) & 0x1));
//
//
//
       printf(" enter 1 to continue FPGA ADC receiver align\n");
       scanf("%d",&ik);
//
//    send FPGA ADC align
//
       imod=imod_fem;
       ichip=3;
       buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_pmt_align_pulse+(0x0<<16);  // FPGA ADC receiver reset off
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);

       usleep(5000); // wait for 5ms

//
//      readback status
//
       i = pcie_rec(hDev,0,1,nword,iprint,py);     // init the receiver

       imod=imod_fem;
       ichip=3;
       buf_send[0]=(imod<<11)+(ichip<<8)+20+(0x0<<16);  // read out status
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);
       py = &read_array;
       i = pcie_rec(hDev,0,2,nword,iprint,py);     // read out 2 32 bits words
       printf("receive data word -- after align = %x, %x \n", read_array[0], read_array[1]);
       printf(" module = %d, command = %d \n", ((read_array[0]>>11) & 0x1f), (read_array[0] &0xff));
       printf(" ADC right dpa lock     %d \n", ((read_array[0]>>17) & 0x1));
       printf(" ADC left  dpa lock     %d \n", ((read_array[0]>>18) & 0x1));
       printf(" block error 2          %d \n", ((read_array[0]>>19) & 0x1));
       printf(" block error 1          %d \n", ((read_array[0]>>20) & 0x1));
       printf(" pll lcoked             %d \n", ((read_array[0]>>21) & 0x1));
       printf(" superNova mem ready    %d \n", ((read_array[0]>>22) & 0x1));
       printf(" beam      mem ready    %d \n", ((read_array[0]>>23) & 0x1));
       printf(" ADC right PLL locked   %d \n", ((read_array[0]>>24) & 0x1));
       printf(" ADC left PLL locked    %d \n", ((read_array[0]>>25) & 0x1));
       printf(" ADC align cmd right    %d \n", ((read_array[0]>>26) & 0x1));
       printf(" ADC align cmd left     %d \n", ((read_array[0]>>27) & 0x1));
       printf(" ADC align done right   %d \n", ((read_array[0]>>28) & 0x1));
       printf(" ADC align done left    %d \n", ((read_array[0]>>29) & 0x1));
       printf(" ADC align done left    %d \n", ((read_array[0]>>29) & 0x1));
       printf(" Neutrino data empty    %d \n", ((read_array[0]>>30) & 0x1));
       printf(" Neutrino Header empty  %d \n", ((read_array[0]>>31) & 0x1));
//
//
//
//
       printf(" enter 1 to continue after ADC alignment \n");
       scanf("%d",&ik);
//
//
//
       for (is=1; is<7; is++) {
        imod=imod_fem;
        ichip=5;
        buf_send[0]=(imod<<11)+(ichip<<8)+(mb_pmt_spi_add)+((is & 0xf)<<16); //set spi address
        i=1;
        k=1;
        i = pcie_send(hDev, i, k, px);
        imod=imod_fem;
        ichip=5;
        buf_send[0]=(imod<<11)+(ichip<<8)+(mb_pmt_adc_data_load)+(0x0300<<16); //sync pattern, b for sync, 7 for skew, 3 for normal
        i=1;
        k=1;
        i = pcie_send(hDev, i, k, px);
       }
      }

      if(use_pmt ==1) {
       if(pmt_testpulse == 1) {
//
//     set dac value and write
//
        imod =imod_shaper;  /* set shaper module DAC value */
        buf_send[0]=(imod<<11)+mb_shaper_dac+((0xfff & idac_shaper)<<16);
        i=1;
        k=1;
        i = pcie_send(hDev, i, k, px);
        usleep(10);
        imod =imod_shaper;  /* write to the DAC */
        buf_send[0]=(imod<<11)+mb_shaper_write+((0xfff)<<16);
        i=1;
        k=1;
        i = pcie_send(hDev, i, k, px);
        usleep(1000);
 //
 //     set up pulse time
 //
        imod =imod_shaper;  /* write pulse time */
        idiv =1;
        isample =1;
        buf_send[0]=(imod<<11)+mb_shaper_pulsetime+(((idiv&0x7)+((isample&0xfff)<<3))<<16);  // all bits on
        i=1;
        k=1;
        i = pcie_send(hDev, i, k, px);
        usleep(1000);
//
//      set firing patterm
//

        imod =imod_shaper;  /* write to test pattern register */
        buf_send[0]=(imod<<11)+mb_shaper_pattern+((0xf)<<16);  // all bits on
        i=1;
        k=1;
        i = pcie_send(hDev, i, k, px);
        usleep(1000);
       }
//
//     set up enable trigger or not
//
       if(pmt_testpulse == 1) {
        imod =imod_shaper;
        if(itrig_ext == 1) is = 0;
        else is = 1;
        buf_send[0]=(imod<<11)+mb_shaper_entrig+((is)<<16);  // all bits on
        i=1;
        k=1;
        i = pcie_send(hDev, i, k, px);
        usleep(1000);
       }

      }
//
//     enable PMT test mode, only when we are not using trigger module as pulser
//
      else if (itrig_pulse < 1) {
       imod=imod_fem;
       ichip=3;
       buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_pmt_test+(0x1<<16);  // set PMT test data on
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);
      }
//
//
//
//      iwrite = 0;
      for (ib=0; ib<nevent; ib++) {
//
//
//
       if(use_pmt ==1) {
        if((pmt_testpulse == 1) & (pmt_dac_scan ==1)) {
         if(idac_shaper == 4096) idac_shaper = 256;
         else idac_shaper = idac_shaper+256;
//
//     set dac value and write
//
         imod =imod_shaper;  /* set shaper module DAC value */
         buf_send[0]=(imod<<11)+mb_shaper_dac+((0xfff & (idac_shaper-1))<<16);
         i=1;
         k=1;
         i = pcie_send(hDev, i, k, px);
         usleep(10);
         imod =imod_shaper;  /* write to the DAC */
         buf_send[0]=(imod<<11)+mb_shaper_write+((0xfff)<<16);
         i=1;
         k=1;
         i = pcie_send(hDev, i, k, px);
         usleep(1000);
        }
       }

//
//     set up test pulse
//
       if((use_pmt != 1) & (itrig_pulse < 1)) {
//
//     clear PMT test FIFO
//
        printf(" enter 1 to continue on sending clear\n");
        scanf("%d",&ik);
        imod=imod_fem;
        ichip=3;
        buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_pmt_clear+(0x1<<16);  // clear PMT test data FIFO
        i=1;
        k=1;
        i = pcie_send(hDev, i, k, px);
//
//     load PMT test data
//
        imod=imod_fem;
        ichip=3;
        irise=100;
        ifall=1;
        ibase =0;
        istart_time = 50;
        for (i=0; i< 256; i++) {
//        printf(" enter 1 to continue, loop %d, t_upper \n", i);
//        scanf("%d",&ik);
         is = ((istart_time<<12) & 0xfff) + 0x8000;
         ijk=1;
         k=1;
         buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_pmt_test_data+(is<<16);  // load PMT test data
         ijk = pcie_send(hDev, ijk, k, px);
//        printf(" enter 1 to continue, loop %d, t_lower \n", i);
//        scanf("%d",&ik);
         is = (istart_time & 0xfff) + 0x8000;
         ijk=1;
         k=1;
         buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_pmt_test_data+(is<<16);  // load PMT test data
         istart_time = istart_time+1;
         ijk = pcie_send(hDev, ijk, k, px);
//        printf(" istart_time %d, loop %d\n", istart_time, i);
         for (j=0; j<32; j++) {   // load data reverse order
          if(i <= 10) is= ibase+(31-j);
          else if((i > 10) && (i <= 16)) is= irise*(i-10)+ibase+(31-j);
          else is= (irise*6+ibase+(31-j))-(i-16)*ifall;
          if(is <= 0) is =0;
          if(is >= 4095) is = 4095;
          if(j != 31) il = (is & 0xfff)+ 0x8000;
          else il =(is & 0xfff)+ 0xc000;
//          printf("is = %x, loop %d, chnl %d \n", is, i,j);
          buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_pmt_test_data+(il<<16);  // load PMT test data
          ijk=1;
          k=1;
          ijk = pcie_send(hDev, ijk, k, px);
         }
//        scanf("%d",&ik);
        }
//
//     set PMT test data pulse
//
        imod=imod_fem;
        ichip=3;
        buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_pmt_pulse+(0x1<<16);  // send pulse for PMT test data
        i=1;
        k=1;
        i = pcie_send(hDev, i, k, px);
       }
//
//     set up PMT
//

//
       imod = imod_trig;
       buf_send[0]=(imod<<11)+(mb_trig_output_select)+((0x2)<<16); // trigger out
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);

       if(itrig_ext ==1) {
//
//     only need to restart the run if the we use the test data or 1st run
//
        if((ib == 0)|| (use_pmt != 1)) {
         imod=imod_trig;
         buf_send[0]=(imod<<11)+(mb_trig_run)+((0x1)<<16); //set up run
         i=1;
         k=1;
         i = pcie_send(hDev, i, k, px);
        }
        if(itrig_pulse == 1) {
//
//
         imod = imod_trig;
         buf_send[0]=(imod<<11)+(mb_trig_output_select)+((0x1)<<16); // select test pulse output
         i=1;
         k=1;
         i = pcie_send(hDev, i, k, px);
//
         imod = imod_trig;
         buf_send[0]=(imod<<11)+(mb_trig_p1_delay)+((p1_delay)<<16); // set up p1 delay;
         i=1;
         k=1;
         i = pcie_send(hDev, i, k, px);

         imod = imod_trig;
         buf_send[0]=(imod<<11)+(mb_trig_p1_width)+((p1_width)<<16); // set up p1 width;
         i=1;
         k=1;
         i = pcie_send(hDev, i, k, px);

         imod = imod_trig;
         buf_send[0]=(imod<<11)+(mb_trig_p2_delay)+((p2_delay)<<16); // set up p1 delay;
         i=1;
         k=1;
         i = pcie_send(hDev, i, k, px);

         imod = imod_trig;
         buf_send[0]=(imod<<11)+(mb_trig_p2_width)+((p2_width)<<16); // set up p1 width;
         i=1;
         k=1;
         i = pcie_send(hDev, i, k, px);

         imod = imod_trig;
         buf_send[0]=(imod<<11)+(mb_trig_pulse_delay)+((pulse_trig_delay)<<16); // set up triger delay;
         i=1;
         k=1;
         i = pcie_send(hDev, i, k, px);



         usleep(10);

         imod = imod_trig;
         buf_send[0]=(imod<<11)+(mb_trig_pulse1)+((0x1)<<16); // fire pulse 1;
         i=1;
         k=1;
         i = pcie_send(hDev, i, k, px);
//
//
         usleep(1000);
        }
        else if( itrig_pulse == 2) {
         usleep(10);

         imod = imod_trig;
         buf_send[0]=(imod<<11)+(mb_trig_frame_trig)+((0x1)<<16); // fire pulse 1;
         i=1;
         k=1;
         i = pcie_send(hDev, i, k, px);
        }

       }
       else {
//
//      if not use trigger module, controller provide trigger and fire test pulse
//
        if(ib == 0) {
         imod=0;
         ichip=1;
         buf_send[0]=(imod<<11)+(ichip<<8)+(mb_cntrl_set_run_on)+(0x0<<16); //enable offline run on
         i=1;
         k=1;
         i = pcie_send(hDev, i, k, px);
         usleep(5000);
        }

        imod=0;
        ichip=1;
        buf_send[0]=(imod<<11)+(ichip<<8)+mb_cntrl_set_trig1+(0x0<<16);  // send trigger
        i=1;
        k=1;
        i = pcie_send(hDev, i, k, px);

       }
//
//     figure out the test pulse firing and trigger setup
//
       if(pmt_testpulse == 1) {
//        if(itrig_ext == 1) {
//**         printf(" enter 1 to continue on sending test pulse\n");
//**         scanf("%d",&ik);
         imod =imod_shaper;  /* arm test pulse firing*/
         buf_send[0]=(imod<<11)+mb_shaper_pulse+((0xf)<<16);  // all bits on
         i=1;
         k=1;
         i = pcie_send(hDev, i, k, px);
//        }
       }
       usleep(1000);
//
//
//
       if(iprint == 1) {
        printf(" ready to receive trigger \n");
        scanf("%d",&ik);
       }

       for (ijk=0; ijk<100000000; ijk++){
//
//      readback status
//
        nword = 1;
        i = pcie_rec(hDev,0,1,nword,0,py);     // init the receiver

        imod=imod_fem;
        ichip=3;
        buf_send[0]=(imod<<11)+(ichip<<8)+20+(0x0<<16);  // read out status
        i=1;
        k=1;
        i = pcie_send(hDev, i, k, px);
        py = &read_array;
        i = pcie_rec(hDev,0,2,nword,0,py);     // read out 2 32 bits words
//
//      readback status
//
        i = pcie_rec(hDev,0,1,nword,0,py);     // init the receiver

        imod=imod_fem;
        ichip=3;
        buf_send[0]=(imod<<11)+(ichip<<8)+20+(0x0<<16);  // read out status
        i=1;
        k=1;
        i = pcie_send(hDev, i, k, px);
        py = &read_array;
        i = pcie_rec(hDev,0,2,nword,0,py);     // read out 2 32 bits words
//
//
//
        if(iwrite !=1 ) {
         printf("receive data word -- after reset = %x, %x \n", read_array[0], read_array[1]);
         printf(" module = %d, command = %d \n", ((read_array[0]>>11) & 0x1f), (read_array[0] &0xff));
         printf(" ADC right dpa lock     %d \n", ((read_array[0]>>17) & 0x1));
         printf(" ADC left  dpa lock     %d \n", ((read_array[0]>>18) & 0x1));
         printf(" block error 2          %d \n", ((read_array[0]>>19) & 0x1));
         printf(" block error 1          %d \n", ((read_array[0]>>20) & 0x1));
         printf(" pll lcoked             %d \n", ((read_array[0]>>21) & 0x1));
         printf(" superNova mem ready    %d \n", ((read_array[0]>>22) & 0x1));
         printf(" beam      mem ready    %d \n", ((read_array[0]>>23) & 0x1));
         printf(" ADC right PLL locked   %d \n", ((read_array[0]>>24) & 0x1));
         printf(" ADC left PLL locked    %d \n", ((read_array[0]>>25) & 0x1));
         printf(" ADC align cmd right    %d \n", ((read_array[0]>>26) & 0x1));
         printf(" ADC align cmd left     %d \n", ((read_array[0]>>27) & 0x1));
         printf(" ADC align done right   %d \n", ((read_array[0]>>28) & 0x1));
         printf(" ADC align done left    %d \n", ((read_array[0]>>29) & 0x1));
         printf(" Neutrino data empty    %d \n", ((read_array[0]>>30) & 0x1));
         printf(" Neutrino Header empty  %d \n", ((read_array[0]>>31) & 0x1));
        }

        if(((read_array[0] >> 31) &0x1) == 0) break;
        else {
          usleep(1000);
          printf(".");
        }
//        break;
       }

//
//

//      set module number again to enable the FEB module read back

       imod=imod_fem;
       ichip=3;
       buf_send[0]=(imod<<11)+(ichip<<8)+6+(imod<<16);  // set module number
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);

       usleep(50000); //wait for 500 ms
//
//
       if(inewcode == 2) nword = 6;
       else nword = 5 ;

       i = pcie_rec(hDev,0,1,nword,iprint,py);     // init the receiver
//
//
       imod=imod_fem;
       ichip=3;
       buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_a_rdhed+(0x1<<16);  // read a header
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);
//
//
//
       py = &read_array;
       i = pcie_rec(hDev,0,2,nword,iprint,py);     // read out 2 32 bits words
//
       if(inewcode == 2) {
        if(iwrite ==1) fprintf(outf," %x %x %x %x %x %x\n", read_array[0], read_array[1], read_array[2], read_array[3], read_array[4],read_array[4]);
//
        if(iprint ==1)
         printf("receive data word = %x, %x, %x, %x, %x %x \n", read_array[0], read_array[1], read_array[2], read_array[3], read_array[4], read_array[5]);
        if(iprint == 1) {
         printf(" header word %x \n",(read_array[0] & 0xffff));
         k=(read_array[0]>>16) & 0xfff;
         printf(" module adress %d, id number %d\n", (k & 0x1f), ((k>>5) & 0x7f));
         printf(" number of data word to read %d\n", (((read_array[1]>>16) & 0xfff)+((read_array[1] &0xfff) <<12)));
         printf(" event number %d\n", (((read_array[2]>>16) & 0xfff)+((read_array[2] &0xfff) <<12)));
         k= (((read_array[3]>>16) & 0xfff)+((read_array[3] &0xfff) <<12));
         printf(" frame number %d %x(hex)\n", k, k);
         printf(" checksum %x\n", (((read_array[4]>>16) & 0xfff)+((read_array[4] &0xfff) <<12)));
         printf(" trigger pointer %x\n", (((read_array[5]>>16) & 0xfff)+((read_array[5] &0xfff) <<12)));
         printf(" trigger pointer %x\n", (((read_array[5]>>16) & 0xff)+((read_array[5] &0xff) <<8)));
         k = ((read_array[5]>>16) & 0xff)+((read_array[5] & 0xff) <<8);
         printf(" trigger pointer frame, sample %x %x\n", ((k>>12) & 0xf), (k &0xfff));

        }
       }
       else {
        if(iwrite ==1) fprintf(outf," %x %x %x %x %x\n", read_array[0], read_array[1], read_array[2], read_array[3], read_array[4]);
//
        if(iprint ==1)
         printf("receive data word = %x, %x, %x, %x, %x\n", read_array[0], read_array[1], read_array[2], read_array[3], read_array[4]);
        if(iprint == 1) {
         printf(" header word %x \n",(read_array[0] & 0xffff));
         k=(read_array[0]>>16) & 0xfff;
         printf(" module adress %d, id number %d\n", (k & 0x1f), ((k>>5) & 0x7f));
         printf(" number of data word to read %d\n", (((read_array[1]>>16) & 0xfff)+((read_array[1] &0xfff) <<12)));
         printf(" event number %d\n", (((read_array[2]>>16) & 0xfff)+((read_array[2] &0xfff) <<12)));
         printf(" frame number %d\n", (((read_array[3]>>16) & 0xfff)+((read_array[3] &0xfff) <<12)));
         printf(" checksum %x\n", (((read_array[4]>>16) & 0xfff)+((read_array[4] &0xfff) <<12)));
        }
       }

//       printf(" enter 1 to continue \n");
//       scanf("%d",&ik);

       nread = ((read_array[1]>>16) & 0xfff)+((read_array[1] &0xfff) <<12);
//       printf(" event %d, nread %d \n",ib,nread);
//
//
//
//**       if(iprint ==1 )scanf("%d",&ik);
       nword = (nread+1)/2;                    // short words
//       if(inewcode == 1) nword = nword+1;
       i = pcie_rec(hDev,0,1,nword,iprint,py);     // init the receiver

       imod=imod_fem;
       ichip=mb_feb_pass_add;
       buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_a_rdbuf+(0x0<<16);  // read a header
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);

       py = &read_array;
       i = pcie_rec(hDev,0,2,nword,iprint,py);     // read out 2 32 bits words

       if(iprint == 1) {
        for (i=0; i< nword; i++) {
         if((i%8) ==0) printf("%4d",i);
         printf(" %8x",read_array[i]);
         if(((i+1)%8) ==0 ) printf("\n");
        }
        if((i%8) !=0 ) printf("\n");
       }
       if(iwrite == 1) {
        fprintf(outf," %d\n %d\n",nread, idac_shaper);
        for (i=0; i< nword; i++) {
         if((i%8) ==0) fprintf(outf,"%4d",i);
         fprintf(outf," %8x",read_array[i]);
         if(((i+1)%8) ==0 ) fprintf(outf,"\n");
        }
        if(((i+1)*8) != 0)fprintf(outf,"\n");
       }

//
//
//
//**       printf(" enter 1 to continue \n");
//**       scanf("%d",&ik);
//
       if(iprint == 1) {
        if(inewcode != 0) {
         ik=0;
         for (i=0; i< nword; i++) {
          read_array_s[ik] = read_array[i] &0xffff;
          read_array_s[ik+1] = ((read_array[i]>>16) & 0xffff);
          ik=ik+2;
         }
         for (i=0; i< ik; i++) {
          if((i%8) == 0) printf("%4d",i);
          printf(" %4x",read_array_s[i]);
          if(((i+1)%8) ==0 ) printf("\n");
         }
         if(((i+1)*8) != 0)printf("\n");
         for (i=0; i< ik; i++) {
          if((read_array_s[i] & 0xc000) == 0x4000) {
           printf(" first word in the event %x\n", read_array_s[i]);
          }
          else if((read_array_s[i] & 0xc000) == 0xc000) {
           printf(" last word in the event %x\n", read_array_s[i]);
          }
          else if((read_array_s[i] & 0xc000) == 0x8000) {   // data word encoding
           ijk = read_array_s[i] & 0x3fff;         // grep data word
           if((ijk & 0x3000) == 0x1000) {
            printf(" header word, id= %d, channel = %d \n", (ijk & 0xe00)>> 9, (ijk & 0x3f));
            ijk= read_array_s[i+1] & 0x3fff;
            is = ((ijk & 0x1f) << 12) + (read_array_s[i+2] & 0xfff);
            printf(" frame = %d, sample = %d\n",(read_array_s[i+1] & 0xe0)>>5,is);
            i= i+2;
            k=0;
           }
           else if ((ijk & 0x2000) == 0x2000) {
            k=k+1;
            printf(" %4X", ijk & 0xfff);
            if((k%8) == 0 ) printf("\n");
            if ((ijk & 0x3000) == 0x3000) {
             if((k%8) != 0 ) printf("\n");
             printf( "last word -- channel \n");
            }
           }
           else printf(" wrong header lable, %4x\n",read_array_s[i]);
          }
         }
        }
        else {
         ik=0;
         ich_head=0;
         count =0;
         for (i=0; i< nword; i++) {
          read_array_s[ik] = read_array[i] &0xffff;
          read_array_s[ik+1] = ((read_array[i]>>16) & 0xffff);
          ik=ik+2;
         }
         for (i=0; i<(nread+1); i++) {
          if((read_array_s[i] & 0xf000) == 0x5000) {
           printf(" first word in the event %x\n", read_array_s[i]);
          }
          else if((read_array_s[i] & 0xf000) == 0x9000) {
           printf(" header -- channel %d, id = %d \n",(read_array_s[i] & 0x1f), ((read_array_s[i] & 0xc00)>>10));
           ich_head =2;
          }
          else if(((read_array_s[i] & 0xf000) == 0xa000) && (ich_head !=0)) {
           if(ich_head == 2) {
             ich_sample = ((read_array_s[i] & 0x1f)<<12);    // temp hold the upper bits
             ich_frm = ((read_array_s[i] & 0xe0)>>5);
           }
           else {
             ich_sample = (read_array_s[i] & 0xfff) + ich_sample;
             printf(" 2 header words -- frame %x, sample %x \n", ich_frm, ich_sample);
           }
           ich_head = ich_head -1;
          }
          else if (((read_array_s[i] & 0xf000) == 0xa000) && (ich_head ==0)) {
           if(count == 0) printf(" adc sample \n");
           printf(" %d", read_array_s[i] & 0xfff);
           count = count+1;
           if(count%8 == 0) printf("\n");
          }
          else if ((read_array_s[i] & 0xf000) == 0xb000) {
           printf(" %d", read_array_s[i] & 0xfff);
           count =0;
           printf(" ---last channel word \n");
          }
          else if((read_array_s[i] & 0xc000) == 0xc000) {
           printf(" last word in the event %x\n", read_array_s[i]);
          }
          else printf(" wrong word type %x \n", read_array_s[i]);
         }
        }
       }


//
//      readback status
//
       if(iprint == 1) {
        nword = 1;
        i = pcie_rec(hDev,0,1,nword,iprint,py);     // init the receiver

        imod=imod_fem;
        ichip=3;
        buf_send[0]=(imod<<11)+(ichip<<8)+20+(0x0<<16);  // read out status
        i=1;
        k=1;
        i = pcie_send(hDev, i, k, px);
        py = &read_array;
        i = pcie_rec(hDev,0,2,nword,iprint,py);     // read out 2 32 bits words
//
//      readback status
//
        i = pcie_rec(hDev,0,1,nword,iprint,py);     // init the receiver

        imod=imod_fem;
        ichip=3;
        buf_send[0]=(imod<<11)+(ichip<<8)+20+(0x0<<16);  // read out status
        i=1;
        k=1;
        i = pcie_send(hDev, i, k, px);
        py = &read_array;
        i = pcie_rec(hDev,0,2,nword,iprint,py);     // read out 2 32 bits words
//
//
//
        if(iwrite != 1) {
         printf("receive data word -- after reset = %x, %x \n", read_array[0], read_array[1]);
         printf(" module = %d, command = %d \n", ((read_array[0]>>11) & 0x1f), (read_array[0] &0xff));
         printf(" ADC right dpa lock     %d \n", ((read_array[0]>>17) & 0x1));
         printf(" ADC left  dpa lock     %d \n", ((read_array[0]>>18) & 0x1));
         printf(" block error 2          %d \n", ((read_array[0]>>19) & 0x1));
         printf(" block error 1          %d \n", ((read_array[0]>>20) & 0x1));
         printf(" pll lcoked             %d \n", ((read_array[0]>>21) & 0x1));
         printf(" superNova mem ready    %d \n", ((read_array[0]>>22) & 0x1));
         printf(" beam      mem ready    %d \n", ((read_array[0]>>23) & 0x1));
         printf(" ADC right PLL locked   %d \n", ((read_array[0]>>24) & 0x1));
         printf(" ADC left PLL locked    %d \n", ((read_array[0]>>25) & 0x1));
         printf(" ADC align cmd right    %d \n", ((read_array[0]>>26) & 0x1));
         printf(" ADC align cmd left     %d \n", ((read_array[0]>>27) & 0x1));
         printf(" ADC align done right   %d \n", ((read_array[0]>>28) & 0x1));
         printf(" ADC align done left    %d \n", ((read_array[0]>>29) & 0x1));
         printf(" Neutrino data empty    %d \n", ((read_array[0]>>30) & 0x1));
         printf(" Neutrino Header empty  %d \n", ((read_array[0]>>31) & 0x1));
        }
       }

//
//
//


       if(iprint == 1) {
        printf(" enter 1 to continue \n");
        scanf("%d",&ik);
       }

//
//     only need to stop the run if we are not using PMT
//
       if((itrig_ext == 1) && (use_pmt != 1)) {
 //
 //  set trigger module run off
 //
        imod=imod_trig;
        buf_send[0]=(imod<<11)+(mb_trig_run)+((0x0)<<16); //set up run off
        i=1;
        k=1;
        i = pcie_send(hDev, i, k, px);
       }
//       else {
//
//disable the run command
//
//        imod=0;
//        ichip=1;
//        buf_send[0]=(imod<<11)+(ichip<<8)+(mb_cntrl_set_run_off)+(0x0<<16); //enable offline run on
//        i=1;
//        k=1;
//        i = pcie_send(hDev, i, k, px);
//       }
      if((iwrite == 1)&&((ib%100) ==0)) printf("nevent = %d\n",ib);
//      if(((ib%100) ==0)) printf("nevent = %d\n",ib);
      }
     }

     break;


    case 23:
     printf(" XMIT boot test \n");
     printf(" number of boot lopp \n");
     scanf("%d", &nloop);
     printf(" number event \n");
     scanf("%d",&nevent);
     printf(" number of fake data word to send \n");
     scanf("%d",&nsend_f);

     imod_xmit=10;
     nsend=500;

// once the fpga is booted we should let system receive fill frame before send any data.
// set system with normal transmitter mode

     dwAddrSpace =2;
     u32Data = 0x20000000;    // initial transmitter, return the hold
     dwOffset = 0x18;
     WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);
     dwAddrSpace =2;
     u32Data = 0x20000000;    // initial transmitter, return the hold
     dwOffset = 0x20;
     WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);

     dwAddrSpace =2;
     u32Data = 0x20000000;
     dwOffset = 0x1c;
     WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);
     dwAddrSpace =2;
     u32Data = 0x20000000;
     dwOffset = 0x24;
     WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);


     dwAddrSpace =2;
     u32Data = 0xfff;    // set mode off with 0xfff...
     dwOffset = 0x28;
     WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);


     ifr =0;
     px = &buf_send;
     py = &read_array;
     imod =0;  /* controller module */
/** initialize **/
     buf_send[0]=0x0;
     buf_send[1]=0x0;
     i=1;
     k=1;
     i = pcie_send(hDev, i, k, px);
// set offline test
     imod=0;
     ichip=1;
     buf_send[0]=(imod<<11)+(ichip<<8)+(mb_cntrl_test_on)+(0x0<<16); //enable offline run on
     i=1;
     k=1;
     i = pcie_send(hDev, i, k, px);
 //disable the run command
     imod=0;
     ichip=1;
     buf_send[0]=(imod<<11)+(ichip<<8)+(mb_cntrl_set_run_off)+(0x0<<16); //enable offline run on
     i=1;
     k=1;
     i = pcie_send(hDev, i, k, px);
     for ( j=0; j<nloop; j++) {
      usleep(10000); // wait for 10ms
      inpf = fopen("../../xmit_fpga","r");
      imod=imod_xmit;
      ichip=mb_xmit_conf_add;
      buf_send[0]=(imod<<11)+(ichip<<8)+0x0+(0x0<<16);  // turn conf to be on
      i=1;
      k=1;
      i = pcie_send(hDev, i, k, px);
//      for (i=0; i<100000; i++) {
//          ik= i%2;
//          dummy1= (ik+i)*(ik+i);
//      }


        /* read data as characters (28941) */
      usleep(1000);   // wait fior a while
      count = 0;
      counta= 0;
      ichip_c = 7; // set ichip_c to stay away from any other command in the
      dummy1 =0;
      while (fread(&charchannel,sizeof(char),1,inpf)==1) {
       carray[count] = charchannel;
       count++;
       counta++;
       if((count%(nsend*2)) == 0) {
//        printf(" loop = %d\n",dummy1);
        buf_send[0] = (imod <<11) +(ichip_c <<8)+ (carray[0]<<16);
        send_array[0] =buf_send[0];
        if(dummy1 <= 5 ) printf(" counta = %d, first word = %x, %x, %x %x %x \n",counta,buf_send[0], carray[0], carray[1]
        ,carray[2], carray[3]);
        for (ij=0; ij< nsend; ij++) {
         if(ij== (nsend-1)) buf_send[ij+1] = carray[2*ij+1]+(0x0<<16);
         else buf_send[ij+1] = carray[2*ij+1]+ (carray[2*ij+2]<<16);
//         buf_send[ij+1] = carray[2*ij+1]+ (carray[2*ij+2]<<16);
         send_array[ij+1] = buf_send[ij+1];
        }
        nword =nsend+1;
        i=1;
//       if(dummy1 == 0)
        ij = pcie_send(hDev, i, nword, px);
        nanosleep(&tim , &tim2);
        dummy1 = dummy1+1;
        count =0;
       }
      }
      if(feof(inpf)) {
       printf("You have reached the end-of-file word count= %d %d\n", counta, count);
       buf_send[0] = (imod <<11) +(ichip_c <<8)+ (carray[0]<<16);
       if ( count > 1) {
        if( ((count-1)%2) ==0) {
         ik =(count-1)/2;
        }
        else {
         ik =(count-1)/2+1;
        }
        ik=ik+2;   // add one more for safety
        printf("ik= %d\n",ik);
        for (ij=0; ij<ik; ij++){
         if(ij == (ik-1)) buf_send[ij+1] = carray[(2*ij)+1]+(((imod<<11)+(ichip<<8)+0x0)<<16);
         else buf_send[ij+1] = carray[(2*ij)+1]+ (carray[(2*ij)+2]<<16);
         send_array[ij+1] = buf_send[ij+1];
        }
       }
       else ik=1;

           for (ij=ik-10; ij< ik+1; ij++) {
            printf("Last data = %d, %x\n",ij,buf_send[ij]);
           }

       nword =ik+1;
       i=1;
       i = pcie_send(hDev, i, nword, px);
      }
      usleep(2000);    // wait for 2ms to cover the packet time plus fpga init time
      fclose(inpf);
      printf(" type 1 for continue \n");
      scanf("%d",&i);
//
//   /* set tx mode register */
//
     if(ibusy_test== 1)
      u32Data = 0x00000050;  // set up hold coming back from the XMIT module
     else
      u32Data = 0xfff;
     printf("u32Data = %x\n",u32Data);
     dwOffset = 0x28;
     dwAddrSpace =2;
     WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);
//
//   set up hold
//
     printf(" set up the hold condition \n");
     dwAddrSpace =2;
     u32Data = 0x8000000;    // initial transmitter, return the hold
     dwOffset = 0x18;
     WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);
     dwAddrSpace =2;
     u32Data = 0x8000000;    // initial transmitter, return the hold
     dwOffset = 0x20;
     WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);



//
// set frame set to be 1023 --- there will be 1024/8 = 128 adc samples.
//
      imod=0;
      ichip=1;
      iframe= 255;    //1023
      buf_send[0]=(imod<<11)+(ichip<<8)+(mb_cntrl_load_frame)+((iframe & 0xffff)<<16); //enable test mode
      i=1;
      k=1;
      i = pcie_send(hDev, i, k, px);
//
// load trig 1 position relative to the frame..
//
      imod=0;
      ichip=1;
      buf_send[0]=(imod<<11)+(ichip<<8)+(mb_cntrl_load_trig_pos)+((itrig_delay & 0xffff)<<16); //enable test mode
      i=1;
      k=1;
      i = pcie_send(hDev, i, k, px);
//
//
//
      imod=0;
      ichip=1;
      buf_send[0]=(imod<<11)+(ichip<<8)+(mb_cntrl_set_run_on)+(0x0<<16); //enable offline run on
      i=1;
      k=1;
      i = pcie_send(hDev, i, k, px);
//
//
//
      imod=imod_xmit;
      ichip=3;
      buf_send[0]=(imod<<11)+(ichip<<8)+mb_xmit_modcount+(0x0<<16);  // set number of module to 1 to enable output
      i=1;
      k=1;
      i = pcie_send(hDev, i, k, px);


      for (is=0; is<nevent; is++) {
       iprint=1;
       nword = 1;
       py = &read_array;
       i = pcie_rec(hDev,0,1,nword,iprint,py);     // init the receiver
       imod=imod_xmit;
       ichip=3;
       buf_send[0]=(imod<<11)+(ichip<<8)+mb_xmit_rdstatus+(0x0<<16);  // read a header
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);
       i = pcie_rec(hDev,0,2,nword,iprint,py);     // read out 2 32 bits words
       printf("receive data word = %x, %x \n", read_array[0], read_array[1]);
//
//
//
       imod=imod_xmit;
       ichip=3;
       buf_send[0]=(imod<<11)+(ichip<<8)+mb_xmit_test2+(0x1<<16);  // enable test fiber 1
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);
//
//
       imod=imod_xmit;
       ichip=3;
       buf_send[0]=(imod<<11)+(ichip<<8)+mb_opt_dig_reset+(0x1<<16);  // set optical reset on
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);
//
//
//
       dwDMABufSize = 200000;
       if(ifr ==0) {
        ifr=1;
        printf(" buffer allocation \n");
        dwStatus = WDC_DMAContigBufLock(hDev2, &pbuf_rec, dwOptions_rec, dwDMABufSize, &pDma_rec);
        if (WD_STATUS_SUCCESS != dwStatus) {
         printf("Failed locking a rec Contiguous DMA buffer. Error 0x%lx - %s\n", dwStatus, Stat2Str(dwStatus));
         printf("enter 1 to continue \n");
         scanf("%d",&is);
        }
       }
//
//
//     set up for busy test read 20 words first then reset of the words
//
//     buffer allocation
//           (8 bytes header + 8 bytes trailer) + nsend_f * 4 bytes)/(2 fibers * 2 bytes per allocation on DMA)
//     single word read is done through 64 bits data read per fiber
//     pcie_rec_6_x set up to receive (nword/4+1) * 64 bits read per fiber
//
//
//       nwrite = (nsend_f*4+8)/8;
       nwrite = 80;

/* set tx mode register */

       u32Data = 0x00000050;
       dwOffset = tx_md_reg;
       dwAddrSpace =cs_bar;
       WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);

/* write this will abort previous DMA */
       dwAddrSpace =2;
       dwOffset = cs_dma_msi_abort;
       u32Data = dma_abort;
       WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);
/* clear DMA register after the abort */
       dwAddrSpace =2;
       dwOffset = cs_dma_msi_abort;
       u32Data = 0;
       WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);

       buffp_rec32 = pbuf_rec;

       for (is=0; is<nwrite*2; is++) {
         *(buffp_rec32+is) =0;
       }


/* synch cache */
       WDC_DMASyncCpu(pDma_rec);
       printf(" synch CPU \n");
///
///    set up the DMA size  (half buffer size limit??)
///
//       nwrite =(dwDMABufSize/8);  //remove factor 2
//       nwrite = 4000;

       for (is=1; is<3; is++) {
        tr_bar = t1_tr_bar;
        r_cs_reg = r1_cs_reg;
        dma_tr = dma_tr1;
        if(is == 2) {
         tr_bar = t2_tr_bar;
         r_cs_reg = r2_cs_reg;
         dma_tr = dma_tr2;
        }
        printf(" is = %d\n",is);
/** initialize the receiver ***/
        u32Data = cs_init;
        dwOffset = r_cs_reg;
        dwAddrSpace =cs_bar;
        WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);
/** start the receiver **/
        dwAddrSpace = cs_bar;
        u32Data = cs_start+(nwrite*8);   /* 32 bits mode == 4 bytes per word *2 fibers **/
//        u32Data = cs_start+ 20*8;             // readout 40 32 bytes words
        dwOffset = r_cs_reg;
        WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);
       }
       printf(" initial receiver \n");
       scanf("%d",&ik);
/** set up DMA for both transceiver together **/

       dwAddrSpace =cs_bar;
       dwOffset = cs_dma_add_low_reg;
       u32Data = pDma_rec->Page->pPhysicalAddr & 0xffffffff;
       WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);

       dwAddrSpace =cs_bar;
       dwOffset = cs_dma_add_high_reg;
       u32Data = (pDma_rec->Page->pPhysicalAddr >> 32) & 0xffffffff;
       WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);

/* byte count */
       dwAddrSpace =cs_bar;
       dwOffset = cs_dma_by_cnt;
       u32Data = (nwrite)*8;      /** twice more data - from fiber 1& 2**/
//       u32Data = 20*8;
       WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);


/* write this will start DMA */
       dwAddrSpace =2;
       dwOffset = cs_dma_cntrl;
       u32Data = dma_tr12+dma_4dw_rec;
       WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);
       printf(" DMA set up done \n");

//
//     send fake data
//
       imod=imod_xmit;
       ichip=3;
       nsend=nsend_f;
       for (k=0; k<nsend; k++) {
         if(k==0) buf_send[k] = (imod<<11)+(ichip<<8)+mb_xmit_testdata+(k<<16);
         else buf_send[k]=(2*k-1)+((2*k)<<16);
       }
       i=1;
       k=nsend;
       i = pcie_send(hDev, i, k, px);

       usleep(1000);

/***    check to see if DMA is done or not **/
       idone =0;
       for (is=0; is<2000; is++) {;
          dwAddrSpace =cs_bar;
 	  u64Data =0;
	  dwOffset = cs_dma_cntrl;
          WDC_ReadAddr32(hDev2, dwAddrSpace, dwOffset, &u32Data);
	  printf(" receive DMA status word %d %X \n", is, u32Data);
	  if((u32Data & dma_in_progress) == 0) {
            idone =1;
            printf(" receive DMA complete %d \n", i);
          }
	  if((u32Data & dma_in_progress) == 0) break;
       }
	/* synch DMA i/O cache **/

       WDC_DMASyncIo(pDma_rec);
//
       dwAddrSpace =cs_bar;
       u64Data =0;
       dwOffset = t1_cs_reg;
       WDC_ReadAddr64(hDev2, dwAddrSpace, dwOffset, &u64Data);
       printf (" status word for channel 1 after read = %x, %x \n",(u64Data>>32), (u64Data &0xffff));
       dwAddrSpace =cs_bar;
       u64Data =0;
       dwOffset = t2_cs_reg;
       WDC_ReadAddr64(hDev2, dwAddrSpace, dwOffset, &u64Data);
       printf (" status word for channel 2 after read = %x, %x \n",(u64Data>>32), (u64Data &0xffff));

//
       for (is=0; is<nwrite*2; is++) {
         read_array[is]= *buffp_rec32++;
       }
       for (is=0; is< nwrite*2; is++) {
        if((is%8) ==0) printf("%4d",is);
        printf(" %8x",read_array[is]);
        if(((is+1)%8) ==0 ) printf("\n");
       }
       if(((is+1)*8) != 0)printf("\n");
//
//
//
       printf(" receive 1st block of data,, type 1 to continue \n");
       scanf("%d",&i);
//
//
//
//       nwrite = ((nsend_f*8+16))/8-20;
       nwrite = ((nsend_f*4+8)/8) -80;

/* write this will abort previous DMA */
       dwAddrSpace =2;
       dwOffset = cs_dma_msi_abort;
       u32Data = dma_abort;
//       WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);
/* clear DMA register after the abort */
       dwAddrSpace =2;
       dwOffset = cs_dma_msi_abort;
       u32Data = 0;
//       WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);

       buffp_rec32 = pbuf_rec;

/* synch cache */
       WDC_DMASyncCpu(pDma_rec);
       printf(" synch CPU \n");
///
///    set up the DMA size  (half buffer size limit??)
///
//       nwrite =(dwDMABufSize/8);  //remove factor 2
//       nwrite = 4000;

       for (is=1; is<3; is++) {
        tr_bar = t1_tr_bar;
        r_cs_reg = r1_cs_reg;
        dma_tr = dma_tr1;
        if(is == 2) {
         tr_bar = t2_tr_bar;
         r_cs_reg = r2_cs_reg;
         dma_tr = dma_tr2;
        }
        printf(" is = %d\n",is);
/** initialize the receiver ***/
        u32Data = cs_init;
        dwOffset = r_cs_reg;
        dwAddrSpace =cs_bar;
//        WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);
/** start the receiver **/
        dwAddrSpace = cs_bar;
        u32Data = cs_start+(nwrite*2)*4;   /* 32 bits mode == 4 bytes per word *2 fibers **/
//        u32Data = cs_start+ 20*8;             // readout 40 32 bytes words
        dwOffset = r_cs_reg;
        WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);
       }
       printf(" initial receiver \n");
       scanf("%d",&ik);
/** set up DMA for both transceiver together **/

       dwAddrSpace =cs_bar;
       dwOffset = cs_dma_add_low_reg;
       u32Data = pDma_rec->Page->pPhysicalAddr & 0xffffffff;
       WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);

       dwAddrSpace =cs_bar;
       dwOffset = cs_dma_add_high_reg;
       u32Data = (pDma_rec->Page->pPhysicalAddr >> 32) & 0xffffffff;
       WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);

/* byte count */
       dwAddrSpace =cs_bar;
       dwOffset = cs_dma_by_cnt;
       u32Data = (nwrite)*4*2;      /** twice more data - from fiber 1& 2**/
//       u32Data = 20*8;
       WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);


/* write this will start DMA */
       dwAddrSpace =2;
       dwOffset = cs_dma_cntrl;
       u32Data = dma_tr12+dma_4dw_rec;
       WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);
       printf(" DMA set up done \n");

//
//     send fake data
//
       imod=imod_xmit;
       ichip=3;
       nsend=nsend_f;
       for (k=0; k<nsend; k++) {
         if(k==0) buf_send[k] = (imod<<11)+(ichip<<8)+mb_xmit_testdata+(k<<16);
         else buf_send[k]=(2*k-1)+((2*k)<<16);
       }
       i=1;
       k=nsend;
//       i = pcie_send(hDev, i, k, px);

       usleep(1000);

/***    check to see if DMA is done or not **/
       idone =0;
       for (is=0; is<2000; is++) {;
          dwAddrSpace =cs_bar;
 	  u64Data =0;
	  dwOffset = cs_dma_cntrl;
          WDC_ReadAddr32(hDev2, dwAddrSpace, dwOffset, &u32Data);
	  printf(" receive DMA status word %d %X \n", is, u32Data);
	  if((u32Data & dma_in_progress) == 0) {
            idone =1;
            printf(" receive DMA complete %d \n", i);
          }
	  if((u32Data & dma_in_progress) == 0) break;
       }
	/* synch DMA i/O cache **/

       WDC_DMASyncIo(pDma_rec);
//
       dwAddrSpace =cs_bar;
       u64Data =0;
       dwOffset = t1_cs_reg;
       WDC_ReadAddr64(hDev2, dwAddrSpace, dwOffset, &u64Data);
       printf (" status word for channel 1 after read = %x, %x \n",(u64Data>>32), (u64Data &0xffff));
       dwAddrSpace =cs_bar;
       u64Data =0;
       dwOffset = t2_cs_reg;
       WDC_ReadAddr64(hDev2, dwAddrSpace, dwOffset, &u64Data);
       printf (" status word for channel 2 after read = %x, %x \n",(u64Data>>32), (u64Data &0xffff));

//
       for (is=0; is<nwrite*2; is++) {
         read_array[is]= *buffp_rec32++;
       }
       for (is=0; is< nwrite*2; is++) {
        if((is%8) ==0) printf("%4d",is);
        printf(" %8x",read_array[is]);
        if(((is+1)%8) ==0 ) printf("\n");
       }
       if(((is+1)*8) != 0)printf("\n");
//
//
//
       printf(" receive 2nd block of data,, type 1 to continue \n");
       scanf("%d",&i);
      }
     }

     break;


    case 24:
     printf(" SuperNova readout test \n");
     printf(" enable number of loop\n");
     scanf("%d",&nloop);
     printf(" enter 1 to turn on huffman encoding \n");
     scanf("%d",&ihuff);
     printf("tyep 1 to compare with the 1st event\n");
     scanf("%d",&comp_s);
     printf("type 1 for print out debug information in dma loop\n");
     scanf("%d",&idebug);
     printf("type 1 for raw data print \n");
     scanf("%d",&irawprint);
     printf(" enter buffer size in bytes \n");
     scanf("%d",&dwDMABufSize);


//     printf(" 1 for checking the event \n");
//     scanf("%d",&icheck);
//     printf(" type 1 to use random number \n");
//     scanf("%d",&irand);
     icheck =0;
     ifr=0;
     irand = 0;
     islow_read =0;
//     if(icheck != 1) {
//      printf(" 1 for print event\n");
//      scanf("%d",&iprint);
//    }
//     else iprint =0;
     iprint = 1;
//     printf(" number event \n");
//     scanf("%d",&nevent);

//     printf(" enter number of words per packet \n");
//     scanf("%d",&nsend);
     nsend=500;
     imod_xmit=10;

// once the fpga is booted we should let system receive fill frame before send any data.
// set system with normal transmitter mode

     dwAddrSpace =2;
     u32Data = 0x20000000;    // initial transmitter, no hold
     dwOffset = 0x18;
     WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);
     dwAddrSpace =2;
     u32Data = 0x20000000;    // initial transmitter, no hold
     dwOffset = 0x20;
     WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);

     dwAddrSpace =2;
     u32Data = 0x20000000;    // initial receiver
     dwOffset = 0x1c;
     WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);
     dwAddrSpace =2;
     u32Data = 0x20000000;   // initial receiver
     dwOffset = 0x24;
     WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);


     dwAddrSpace =2;
     u32Data = 0xfff;    // set mode off with 0xfff...
     dwOffset = 0x28;
     WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);

//
//
//
     px = &buf_send;
     py = &read_array;
     imod =0;  /* controller module */
/** initialize **/
     buf_send[0]=0x0;
     buf_send[1]=0x0;
     i=1;
     k=1;
     i = pcie_send(hDev, i, k, px);
// set offline test
     imod=0;
     ichip=1;
     buf_send[0]=(imod<<11)+(ichip<<8)+(mb_cntrl_test_on)+(0x0<<16); //enable offline run on
     i=1;
     k=1;
     i = pcie_send(hDev, i, k, px);
 //disable the run command
     imod=0;
     ichip=1;
     buf_send[0]=(imod<<11)+(ichip<<8)+(mb_cntrl_set_run_off)+(0x0<<16); //trun off run
     i=1;
     k=1;
     i = pcie_send(hDev, i, k, px);
 // turn on the Stratix III power supply
     imod=11;
     ichip =1;
     buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_power_add+(0x0<<16); //turn module 11 power on
     i=1;
     k=1;
     i = pcie_send(hDev, i, k, px);
     usleep(200000);  // wait for 200 ms
//     printf(" enable number of loop\n");
//     scanf("%d",&nloop);
     for (j=0; j<nloop; j++) {
      usleep(10000); // wait for 10ms

//
//    boot up xmit module 1st
//
      printf(" boot xmit module \n");
      inpf = fopen("../../xmit_fpga","r");
      imod=imod_xmit;
      ichip=mb_xmit_conf_add;
      buf_send[0]=(imod<<11)+(ichip<<8)+0x0+(0x0<<16);  // turn conf to be on
      i=1;
      k=1;
      i = pcie_send(hDev, i, k, px);
//      for (i=0; i<100000; i++) {
//          ik= i%2;
//          dummy1= (ik+i)*(ik+i);
//      }


        /* read data as characters (28941) */
      usleep(1000);   // wait fior a while
      count = 0;
      counta= 0;
      ichip_c = 7; // set ichip_c to stay away from any other command in the
      dummy1 =0;
      while (fread(&charchannel,sizeof(char),1,inpf)==1) {
       carray[count] = charchannel;
       count++;
       counta++;
       if((count%(nsend*2)) == 0) {
//        printf(" loop = %d\n",dummy1);
        buf_send[0] = (imod <<11) +(ichip_c <<8)+ (carray[0]<<16);
        send_array[0] =buf_send[0];
        if(dummy1 <= 5 ) printf(" counta = %d, first word = %x, %x, %x %x %x \n",counta,buf_send[0], carray[0], carray[1]
        ,carray[2], carray[3]);
        for (ij=0; ij< nsend; ij++) {
         if(ij== (nsend-1)) buf_send[ij+1] = carray[2*ij+1]+(0x0<<16);
         else buf_send[ij+1] = carray[2*ij+1]+ (carray[2*ij+2]<<16);
//         buf_send[ij+1] = carray[2*ij+1]+ (carray[2*ij+2]<<16);
         send_array[ij+1] = buf_send[ij+1];
        }
        nword =nsend+1;
        i=1;
//       if(dummy1 == 0)
        ij = pcie_send(hDev, i, nword, px);
        nanosleep(&tim , &tim2);
        dummy1 = dummy1+1;
        count =0;
       }
      }
      if(feof(inpf)) {
       printf("You have reached the end-of-file word count= %d %d\n", counta, count);
       buf_send[0] = (imod <<11) +(ichip_c <<8)+ (carray[0]<<16);
       if ( count > 1) {
        if( ((count-1)%2) ==0) {
         ik =(count-1)/2;
        }
        else {
         ik =(count-1)/2+1;
        }
        ik=ik+2;   // add one more for safety
        printf("ik= %d\n",ik);
        for (ij=0; ij<ik; ij++){
         if(ij == (ik-1)) buf_send[ij+1] = carray[(2*ij)+1]+(((imod<<11)+(ichip<<8)+0x0)<<16);
         else buf_send[ij+1] = carray[(2*ij)+1]+ (carray[(2*ij)+2]<<16);
         send_array[ij+1] = buf_send[ij+1];
        }
       }
       else ik=1;

           for (ij=ik-10; ij< ik+1; ij++) {
            printf("Last data = %d, %x\n",ij,buf_send[ij]);
           }

       nword =ik+1;
       i=1;
       i = pcie_send(hDev, i, nword, px);
      }
      usleep(2000);    // wait for 2ms to cover the packet time plus fpga init time
      fclose(inpf);
//
      printf(" xmit done, booting FEM \n");
      scanf("%d",&ik);

//
//    Boot stratix after XMIT module
//
      inpf = fopen("/home/ub/feb_fpga_test","r");
      imod=11;
      ichip=mb_feb_conf_add;
      buf_send[0]=(imod<<11)+(ichip<<8)+0x0+(0x0<<16);  // turn conf to be on
      i=1;
      k=1;
      i = pcie_send(hDev, i, k, px);
//      for (i=0; i<100000; i++) {
//          ik= i%2;
//          dummy1= (ik+i)*(ik+i);
//      }


        /* read data as characters (28941) */
      usleep(1000);   // wait fior a while
      count = 0;
      counta= 0;
      ichip_c = 7; // set ichip_c to stay away from any other command in the
      dummy1 =0;
      while (fread(&charchannel,sizeof(char),1,inpf)==1) {
       carray[count] = charchannel;
       count++;
       counta++;
       if((count%(nsend*2)) == 0) {
//        printf(" loop = %d\n",dummy1);
        buf_send[0] = (imod <<11) +(ichip_c <<8)+ (carray[0]<<16);
        send_array[0] =buf_send[0];
        if(dummy1 <= 5 ) printf(" counta = %d, first word = %x, %x, %x %x %x \n",counta,buf_send[0], carray[0], carray[1]
        ,carray[2], carray[3]);
        for (ij=0; ij< nsend; ij++) {
         if(ij== (nsend-1)) buf_send[ij+1] = carray[2*ij+1]+(0x0<<16);
         else buf_send[ij+1] = carray[2*ij+1]+ (carray[2*ij+2]<<16);
//         buf_send[ij+1] = carray[2*ij+1]+ (carray[2*ij+2]<<16);
         send_array[ij+1] = buf_send[ij+1];
        }
        nword =nsend+1;
        i=1;
//       if(dummy1 == 0)
        ij = pcie_send(hDev, i, nword, px);
        nanosleep(&tim , &tim2);
        dummy1 = dummy1+1;
        count =0;
       }
      }
      if(feof(inpf)) {
       printf("You have reached the end-of-file word count= %d %d\n", counta, count);
       buf_send[0] = (imod <<11) +(ichip_c <<8)+ (carray[0]<<16);
       if ( count > 1) {
        if( ((count-1)%2) ==0) {
         ik =(count-1)/2;
        }
        else {
         ik =(count-1)/2+1;
        }
        ik=ik+2;   // add one more for safety
        printf("ik= %d\n",ik);
        for (ij=0; ij<ik; ij++){
         if(ij == (ik-1)) buf_send[ij+1] = carray[(2*ij)+1]+(((imod<<11)+(ichip<<8)+0x0)<<16);
         else buf_send[ij+1] = carray[(2*ij)+1]+ (carray[(2*ij)+2]<<16);
         send_array[ij+1] = buf_send[ij+1];
        }
       }
       else ik=1;

           for (ij=ik-10; ij< ik+1; ij++) {
            printf("Last data = %d, %x\n",ij,buf_send[ij]);
           }

       nword =ik+1;
       i=1;
       i = pcie_send(hDev, i, nword, px);
      }
      usleep(2000);    // wait for 2ms to cover the packet time plus fpga init time
      fclose(inpf);
//
//    both FEM and XMIT bootted.
//
//
//   /* set tx mode register */
//
     u32Data = 0x00003fff;  // set up number of words hold coming back from the XMIT module
     printf(" number of words for hold be send back = %x\n",u32Data);
     dwOffset = 0x28;
     dwAddrSpace =2;
     WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);
//
//   set up hold
//
     printf(" set up the hold condition \n");
     dwAddrSpace =2;
     u32Data = 0x8000000;    // set up transmitter to return the hold -- upper transciever
     dwOffset = 0x18;
     WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);
     dwAddrSpace =2;
     u32Data = 0x8000000;    // set up transmitter to return the hold -- lower transciever
     dwOffset = 0x20;
     WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);



//
//    start testing routine
//
       printf(" enter 1 to reset the dram \n");
       scanf("%d",&ik);
 //      ik =1;
       if(ik ==1) {
         imod=11;
         ichip=3;
         buf_send[0]=(imod<<11)+(ichip<<8)+31+(0x1<<16);  // turm the DRAM reset on
         i=1;
         k=1;
         i = pcie_send(hDev, i, k, px);
         imod=11;
         ichip=3;
         buf_send[0]=(imod<<11)+(ichip<<8)+31+(0x0<<16);  // turm the DRAM reset off
         i=1;
         k=1;
         i = pcie_send(hDev, i, k, px);

         usleep(5000);    // wait for 5 ms for DRAM to be initialized

         imod=11;
         ichip=3;
         buf_send[0]=(imod<<11)+(ichip<<8)+6+(imod<<16);  // set module number
         i=1;
         k=1;
         i = pcie_send(hDev, i, k, px);


       }
//       printf(" enter 1 to read system status \n");
//       scanf("%d",&ik);
       ik=1;
       nword =1;
       if(ik ==1) {


         i = pcie_rec(hDev,0,1,nword,iprint,py);     // init the receiver

         imod=11;
         ichip=3;
         buf_send[0]=(imod<<11)+(ichip<<8)+20+(0x0<<16);  // read out status
         i=1;
         k=1;
         i = pcie_send(hDev, i, k, px);
         py = &read_array;
         i = pcie_rec(hDev,0,2,nword,iprint,py);     // read out 2 32 bits words
         printf("receive data word = %x, %x \n", read_array[0], read_array[1]);
       }
//       printf(" enter L1 trigger delay \n");
//       scanf("%d",&itrig_delay);
       itrig_delay = 51;
       nword =1;
//
// set to use test generator 2, set test =2
//
       imod=11;
       ichip=mb_feb_pass_add;
       buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_test_source+(0x2<<16);  // set test source to 2
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);
//
// set frame set to be 255 --- there will be 256/8 = 32 adc samples.
//
       imod=0;
       ichip=1;
       iframe= 255;    //1023
       buf_send[0]=(imod<<11)+(ichip<<8)+(mb_cntrl_load_frame)+((iframe & 0xffff)<<16); //enable test mode
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);


//
// load trig 1 position relative to the frame..
//
       imod=0;
       ichip=1;
       buf_send[0]=(imod<<11)+(ichip<<8)+(mb_cntrl_load_trig_pos)+((itrig_delay & 0xffff)<<16); //enable test mode
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);
//
//    start loading the test 2 data memory
//
       imod =11;
       ichip=3;
       for (is=0; is<64; is++) {
        ik = 0x4000+is;                        // load channel address
        buf_send[0]=(imod<<11)+(ichip<<8)+(mb_feb_test_ram_data)+((ik & 0xffff)<<16); //enable test mode
        i = pcie_send(hDev, 1, 1, px);
        ibase = 32*is;
        il = is%8;
        if(il == 0) printf(" loading channel %d\n",is);
        for (ik=0; ik< 256; ik++) {                 // loop over all possible address
         if(irand ==1) ijk = rand() & 0xfff ;        // use random number
         else ijk= (ibase+ik*8) & 0xfff;
//         if(ihuff == 1) {
           if((ik%4) ==0) ic =ijk;        // set data to repeat for 4 samples....
           ijk=ic;
//         }
         k = 0x8000+ ijk;        // make sure bit 15-12 is clear for the data
         buf_send[0]=(imod<<11)+(ichip<<8)+(mb_feb_test_ram_data)+((k & 0xffff)<<16); //enable test mode
         i = pcie_send(hDev, 1, 1, px);
         send_array[is*256+ik]=ijk;           //load up data map
        }
       }

       imod=11;
       ichip=3;
       if(ihuff == 1) buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_b_nocomp+(0x0<<16);  // turn the compression
       else buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_b_nocomp+(0x1<<16);  // set b channel no compression
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);

       timesize =4;
       imod=11;
       ichip=3;
       buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_timesize+(timesize<<16);  // set drift time size
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);

       a_id =0xf;
       imod=11;
       ichip=3;
       buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_b_id+(a_id<<16);  // set a_id
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);

       imod=11;
       ichip=4;
       buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_b_id+(a_id<<16);  // set a_id
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);
//
//     set max word in the pre-buffer memory
//
       ik=8000;
       imod=11;
       ichip=3;
       buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_max+(ik<<16);  // set pre-buffer max word
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);
//
//     enable hold
//
       imod=11;
       ichip=3;
       buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_hold_enable+(0x1<<16);  // enable the hold
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);

//       imod=11;
//       ichip=3;
//       buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_a_test+(0x1<<16);    // enable a test on
//       i=1;
//       k=1;
//       if(islow_read == 1) i = pcie_send(hDev, i, k, px);


       imod=11;
       ichip=4;
       buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_lst_on+(0x0<<16);    // set last module on
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);

       imod=11;
       ichip=4;
       buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_rxreset+(0x0<<16);    // reset LINKIN DPA
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);

//
//     set up xmit module  -- module count
//
       imod=imod_xmit;
       ichip=3;
       buf_send[0]=(imod<<11)+(ichip<<8)+mb_xmit_modcount+(0x0<<16);  // set number of module to 1 to enable output
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);
//
//     rest optical
//
       imod=imod_xmit;
       ichip=3;
       buf_send[0]=(imod<<11)+(ichip<<8)+mb_opt_dig_reset+(0x1<<16);  // set optical reset on
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);
//
//     enable superNova Token Passing
//
       imod=imod_xmit;
       ichip=3;
       buf_send[0]=(imod<<11)+(ichip<<8)+mb_xmit_enable_2+(0x1<<16);  // enable token 1 pass
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);
//
//
       printf(" enter 1 to reset the DPA \n");
       scanf("%d",&ik);

//
//     reset XMIT LINK IN DPA
//
       imod=imod_xmit;
       ichip=3;
       buf_send[0]=(imod<<11)+(ichip<<8)+mb_xmit_link_reset+(0x1<<16);  //  reset XMIT LINK IN DPA
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);
//
//     wait for 10ms just in case
//
       usleep(10000);
       printf(" XMIT FIFO reset \n");
//
//     reset XMIT FIFO reset
//
       imod=imod_xmit;
       ichip=3;
       buf_send[0]=(imod<<11)+(ichip<<8)+mb_xmit_dpa_fifo_reset+(0x1<<16);  //  reset XMIT LINK IN DPA
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);

//
//
//

       for (is=0; is<1; is++) {
//
//      test re-align circuit
//
        imod=imod_xmit;
        ichip=3;
        buf_send[0]=(imod<<11)+(ichip<<8)+mb_xmit_dpa_word_align+(0x1<<16);  //  send alignment pulse
        i=1;
        k=1;
        i = pcie_send(hDev, i, k, px);

//        printf(" enter 1 to set continue on re-align circuit \n");
//        scanf("%d",&ik);
       }

       usleep(5000); //wait for 5 ms
       printf(" XMIT re-align done \n");


//       dwDMABufSize = 200000;
       ndma_loop =dma_buffer_size/dwDMABufSize;  // set DMA loop for 100 M 32bits words
       printf(" DMA will run %d loop\n", ndma_loop);
       ntot_rec=0;
       for (iv=0; iv<ndma_loop; iv++) {
        if(ifr ==0) {
//         ifr=1;
         printf(" buffer allocation \n");
         dwStatus = WDC_DMAContigBufLock(hDev2, &pbuf_rec, dwOptions_rec, dwDMABufSize, &pDma_rec);
         if (WD_STATUS_SUCCESS != dwStatus) {
          printf("Failed locking a rec Contiguous DMA buffer. Error 0x%lx - %s\n", dwStatus, Stat2Str(dwStatus));
          printf("enter 1 to continue \n");
          scanf("%d",&is);
         }
         else {
           u32Data = pDma_rec->Page->pPhysicalAddr & 0xffffffff;
           printf(" buffer allocation lower address = %x\n", u32Data);
           u32Data = (pDma_rec->Page->pPhysicalAddr >> 32) & 0xffffffff;
           printf(" buffer allocation higher address = %x\n", u32Data);
         }
/* set tx mode register */

         u32Data = 0x00001000;
         dwOffset = tx_md_reg;
         dwAddrSpace =cs_bar;
         WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);

/* write this will abort previous DMA */
         dwAddrSpace =2;
         dwOffset = cs_dma_msi_abort;
         u32Data = dma_abort;
         WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);
/* clear DMA register after the abort */
         dwAddrSpace =2;
         dwOffset = cs_dma_msi_abort;
         u32Data = 0;
         WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);
         printf(" initial abort finished \n");
        }

        buffp_rec32 = pbuf_rec;

/* synch cache */
        WDC_DMASyncCpu(pDma_rec);
        printf(".");
        if(idebug ==1) printf(" synch CPU \n");
///
///    set up the DMA size  (half buffer size limit??)
///
        nwrite =(dwDMABufSize/8);  //remove factor 2
//       nwrite = 4000;

        for (is=1; is<3; is++) {
         tr_bar = t1_tr_bar;
         r_cs_reg = r1_cs_reg;
         dma_tr = dma_tr1;
         if(is == 2) {
          tr_bar = t2_tr_bar;
          r_cs_reg = r2_cs_reg;
          dma_tr = dma_tr2;
         }
         if(idebug ==1) printf(" is = %d\n",is);
/** initialize the receiver ***/
         u32Data = cs_init;
         dwOffset = r_cs_reg;
         dwAddrSpace =cs_bar;
//
// rreceiver only get initialize for the 1st time
//
         if(ifr ==0) WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);
/** start the receiver **/
         dwAddrSpace = cs_bar;
         u32Data = cs_start+(nwrite*2)*4;   /* 32 bits mode == 4 bytes per word *2 fibers **/
         dwOffset = r_cs_reg;
         WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);
        }
        if((ifr ==0) &&(idebug ==1)) printf(" initial receiver \n");
//       scanf("%d",&ik);
/** set up DMA for both transceiver together **/

        dwAddrSpace =cs_bar;
        dwOffset = cs_dma_add_low_reg;
        u32Data = pDma_rec->Page->pPhysicalAddr & 0xffffffff;
        WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);

        dwAddrSpace =cs_bar;
        dwOffset = cs_dma_add_high_reg;
        u32Data = (pDma_rec->Page->pPhysicalAddr >> 32) & 0xffffffff;
        WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);

/* byte count */
        dwAddrSpace =cs_bar;
        dwOffset = cs_dma_by_cnt;
        u32Data = (nwrite)*4*2;      /** twice more data - from fiber 1& 2**/
        WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);


/* write this will start DMA */
        dwAddrSpace =2;
        dwOffset = cs_dma_cntrl;
        u32Data = dma_tr12+dma_3dw_rec;
        WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);
        if(idebug ==1) printf(" DMA set up done \n");

        if(ifr ==0) {
         ifr=1;
//
//      turn the run on to start data flow
//
         printf(" enter 1 to set the RUN on \n");
         scanf("%d",&ik);

         imod=0;
         ichip=1;
         buf_send[0]=(imod<<11)+(ichip<<8)+(mb_cntrl_set_run_on)+(0x0<<16); //enable offline run on
         i=1;
         k=1;
         i = pcie_send(hDev, i, k, px);
        }

/***    check to see if DMA is done or not **/
        idone =0;
        for (is=0; is<6000; is++) {;
          dwAddrSpace =cs_bar;
 	  u64Data =0;
	  dwOffset = cs_dma_cntrl;
          WDC_ReadAddr32(hDev2, dwAddrSpace, dwOffset, &u32Data);
	  if(idebug ==1) printf(" receive DMA status word %d %X \n", is, u32Data);
	  if((u32Data & dma_in_progress) == 0) {
            idone =1;
            if(idebug ==1) printf(" receive DMA complete %d \n", i);
          }
	  if((u32Data & dma_in_progress) == 0) break;
        }
        if(idone == 0) {
         printf(" loop %d, DMA is not finished \n", iv);
         dwAddrSpace =cs_bar;
         dwOffset = cs_dma_by_cnt;
         WDC_ReadAddr64(hDev2, dwAddrSpace, dwOffset, &u64Data);
         printf (" DMA word count = %x, %x \n",(u64Data>>32), (u64Data &0xffff));
//
         WDC_DMASyncIo(pDma_rec);
         nred = (((nwrite)*4*2)-(u64Data &0xffff))/4;
         printf(" number of words received %d %d\n",nred, ntot_rec);
         for (is=0; is<nred; is++) {
          read_array[is+(iv*(nwrite*2))]= *buffp_rec32++;
         }
         ntot_rec = ntot_rec+nred;


/* write this will abort previous DMA */
         dwAddrSpace =2;
         dwOffset = cs_dma_msi_abort;
         u32Data = dma_abort;
         WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);
/* clear DMA register after the abort */
         dwAddrSpace =2;
         dwOffset = cs_dma_msi_abort;
         u32Data = 0;
         WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);
         scanf("%d",&is);
        }
        if(idone == 0) break;
	/* synch DMA i/O cache **/

        WDC_DMASyncIo(pDma_rec);
//
        if(idebug == 1) {
         dwAddrSpace =cs_bar;
         u64Data =0;
         dwOffset = t1_cs_reg;
         WDC_ReadAddr64(hDev2, dwAddrSpace, dwOffset, &u64Data);
         printf (" status word for channel 1 after read = %x, %x \n",(u64Data>>32), (u64Data &0xffff));
         dwAddrSpace =cs_bar;
         u64Data =0;
         dwOffset = t2_cs_reg;
         WDC_ReadAddr64(hDev2, dwAddrSpace, dwOffset, &u64Data);
         printf (" status word for channel 2 after read = %x, %x \n",(u64Data>>32), (u64Data &0xffff));
        }

//
//     copy of the data array
//
        for (is=0; is<nwrite*2; is++) {
         read_array[is+(iv*(nwrite*2))]= *buffp_rec32++;
        }
        ntot_rec = ntot_rec+(nwrite*2);
       }

//
//
//
       if(irawprint ==1) {
        for (is=0; is< ntot_rec; is++) {
         if((is%8) ==0) printf("%4d",is);
         if(((is%250000) ==0) && (is !=0)) {
          printf(" type 1 to continue\n");
          scanf("%d", &dummy1);
         }
         printf(" %8x",read_array[is]);
         if(((is+1)%8) ==0 ) printf("\n");
        }
        if(((is+1)*8) != 0)printf("\n");
       }

//       for(is=0; is< 6*nwrite; is++) {
//         read_array_s[is*2] = (read_array[is] & 0xffff);
//         read_array_s[is*2+1] = ((read_array[is] >>16) & 0xffff);
//       }
//       nread = ((read_array_s[4] & 0xfff) << 12)+ (read_array_s[5] & 0xfff);

       nread = (((read_array[2] & 0xfff)<<12) + ((read_array[2] & 0xfff0000)>>16));
       nread =nread+1;
       nread = nread/2;
       printf(" no. of word within the frame is %d\n", nread);
       for (is=0; is< nread+7; is++) {       // 6 header + 1 trailer.
        read_comp[is] = read_array[is];
       }

       icomp_l = (ntot_rec)/(nread+7); // only compare complete event  // have to add header
       if(comp_s ==1) printf(" compare %d of event in the loop, nread = %d \n",icomp_l, nread);
       if(comp_s == 1) {
        for(is=0; is<icomp_l; is++) {
         for (ik=6; ik< nread+6; ik++) {   //for the moment skip header
          k=ik+is*(nread+7);
          if(read_comp[ik] != read_array[k]) {
            printf(" data error seq = %d, seq= %d, event = %d, first event data word = %8x, data = %8x \n", ik,k,is,read_comp[ik], read_array[k]);
            scanf("%d",&k);
          }
         }
        }
       }
       printf(" compare finished \n");
       scanf("%d",&is);
       is=0;
       while (is < nwrite*2) {
         if(((nwrite*2)-is) <= 12) printf(" not enough word header \n");
         if(((nwrite*2)-is) <= 12) break;
         if((read_array_s[is] == 0xffff) && (read_array_s[is+1] == 0xffff)) {
          printf(" event header %8x \n", read_array_s[is]+(read_array_s[is+1] << 16));
          is=is+2;
          printf(" module header = %4x\n", read_array_s[is]);
          is=is+1;
          printf(" address word = %4x, aid = %2x, module numebr %3d\n", read_array_s[is], ((read_array_s[is]>>5) &0x7f), (read_array_s[is] &0x1f));
          is=is+1;
          ik= (read_array_s[is]<<16)+ (read_array_s[is+1]);
          nread=  ((read_array_s[is] & 0xfff) << 12)+ (read_array_s[is+1] & 0xfff);
          nread = nread+1;
          printf(" word count word = %8x, word count = %8d \n", ik,nread);
          is = is+2;
          ik= (read_array_s[is]<<16)+ (read_array_s[is+1]);
          k=  ((read_array_s[is] & 0xfff) << 12)+ (read_array_s[is+1] & 0xfff);
          printf(" event number word = %8x, event number = %8d \n", ik,k);
          is = is+2;
          ik= (read_array_s[is]<<16)+ (read_array_s[is+1]);
          k=  ((read_array_s[is] & 0xfff) << 12)+ (read_array_s[is+1] & 0xfff);
          printf(" frame number word = %8x, frame number = %8d \n", ik,k);
          is =is+2;
          ik= (read_array_s[is]<<16)+ (read_array_s[is+1]);
          k=  ((read_array_s[is] & 0xfff) << 12)+ (read_array_s[is+1] & 0xfff);
          printf(" checksum word = %8x, checksum = %8x \n", ik,k);
          is=is+2;
         if(((nwrite*2)-is) <= (nread+2)) printf(" not enough word for the event \n");
         if(((nwrite*2)-is) <= (nread+2)) break;
          is=is+nread;
          printf("end of packet word, %8x \n", read_array_s[is]+ (read_array_s[is+1]<<16));
          is = is+2;
          scanf("%d", &ik);
         }
       }

       imod=0;
       ichip=1;
       buf_send[0]=(imod<<11)+(ichip<<8)+(mb_cntrl_set_run_off)+(0x0<<16); //enable offline run off
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);
       scanf("%d",&ik);
      }

     break;


    case 25:
     printf(" SuperNova readout test \n");
     printf(" enable number of loop\n");
     scanf("%d",&nloop);
     printf(" enter 1 to turn on huffman encoding \n");
     scanf("%d",&ihuff);
     printf("tyep 1 to compare with the 1st event\n");
     scanf("%d",&comp_s);
     printf("type 1 for print out debug information in dma loop\n");
     scanf("%d",&idebug);
     printf(" enter buffer size in bytes \n");
     scanf("%d",&dwDMABufSize);

//     printf(" 1 for checking the event \n");
//     scanf("%d",&icheck);
//     printf(" type 1 to use random number \n");
//     scanf("%d",&irand);
     icheck =0;
     ifr=0;
     irand = 0;
     islow_read =0;
//     if(icheck != 1) {
//      printf(" 1 for print event\n");
//      scanf("%d",&iprint);
//    }
//     else iprint =0;
     iprint = 1;
//     printf(" number event \n");
//     scanf("%d",&nevent);

//     printf(" enter number of words per packet \n");
//     scanf("%d",&nsend);
     nsend=500;
     imod_xmit=10;

// once the fpga is booted we should let system receive fill frame before send any data.
// set system with normal transmitter mode

     dwAddrSpace =2;
     u32Data = 0x20000000;    // initial transmitter, no hold
     dwOffset = 0x18;
     WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);
     dwAddrSpace =2;
     u32Data = 0x20000000;    // initial transmitter, no hold
     dwOffset = 0x20;
     WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);

     dwAddrSpace =2;
     u32Data = 0x20000000;    // initial receiver
     dwOffset = 0x1c;
     WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);
     dwAddrSpace =2;
     u32Data = 0x20000000;   // initial receiver
     dwOffset = 0x24;
     WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);


     dwAddrSpace =2;
     u32Data = 0xfff;    // set mode off with 0xfff...
     dwOffset = 0x28;
     WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);

//
//
//
     px = &buf_send;
     py = &read_array;
     imod =0;  /* controller module */
/** initialize **/
     buf_send[0]=0x0;
     buf_send[1]=0x0;
     i=1;
     k=1;
     i = pcie_send(hDev, i, k, px);
// set offline test
     imod=0;
     ichip=1;
     buf_send[0]=(imod<<11)+(ichip<<8)+(mb_cntrl_test_on)+(0x0<<16); //enable offline run on
     i=1;
     k=1;
     i = pcie_send(hDev, i, k, px);
 //disable the run command
     imod=0;
     ichip=1;
     buf_send[0]=(imod<<11)+(ichip<<8)+(mb_cntrl_set_run_off)+(0x0<<16); //trun off run
     i=1;
     k=1;
     i = pcie_send(hDev, i, k, px);
 // turn on the Stratix III power supply
     imod=11;
     ichip =1;
     buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_power_add+(0x0<<16); //turn module 11 power on
     i=1;
     k=1;
     i = pcie_send(hDev, i, k, px);
     usleep(200000);  // wait for 200 ms
//     printf(" enable number of loop\n");
//     scanf("%d",&nloop);
     for (j=0; j<nloop; j++) {
      usleep(10000); // wait for 10ms

//
//    boot up xmit module 1st
//
      printf(" boot xmit module \n");
      inpf = fopen("../../xmit_fpga","r");
      imod=imod_xmit;
      ichip=mb_xmit_conf_add;
      buf_send[0]=(imod<<11)+(ichip<<8)+0x0+(0x0<<16);  // turn conf to be on
      i=1;
      k=1;
      i = pcie_send(hDev, i, k, px);
//      for (i=0; i<100000; i++) {
//          ik= i%2;
//          dummy1= (ik+i)*(ik+i);
//      }


        /* read data as characters (28941) */
      usleep(1000);   // wait fior a while
      count = 0;
      counta= 0;
      ichip_c = 7; // set ichip_c to stay away from any other command in the
      dummy1 =0;
      while (fread(&charchannel,sizeof(char),1,inpf)==1) {
       carray[count] = charchannel;
       count++;
       counta++;
       if((count%(nsend*2)) == 0) {
//        printf(" loop = %d\n",dummy1);
        buf_send[0] = (imod <<11) +(ichip_c <<8)+ (carray[0]<<16);
        send_array[0] =buf_send[0];
        if(dummy1 <= 5 ) printf(" counta = %d, first word = %x, %x, %x %x %x \n",counta,buf_send[0], carray[0], carray[1]
        ,carray[2], carray[3]);
        for (ij=0; ij< nsend; ij++) {
         if(ij== (nsend-1)) buf_send[ij+1] = carray[2*ij+1]+(0x0<<16);
         else buf_send[ij+1] = carray[2*ij+1]+ (carray[2*ij+2]<<16);
//         buf_send[ij+1] = carray[2*ij+1]+ (carray[2*ij+2]<<16);
         send_array[ij+1] = buf_send[ij+1];
        }
        nword =nsend+1;
        i=1;
//       if(dummy1 == 0)
        ij = pcie_send(hDev, i, nword, px);
        nanosleep(&tim , &tim2);
        dummy1 = dummy1+1;
        count =0;
       }
      }
      if(feof(inpf)) {
       printf("You have reached the end-of-file word count= %d %d\n", counta, count);
       buf_send[0] = (imod <<11) +(ichip_c <<8)+ (carray[0]<<16);
       if ( count > 1) {
        if( ((count-1)%2) ==0) {
         ik =(count-1)/2;
        }
        else {
         ik =(count-1)/2+1;
        }
        ik=ik+2;   // add one more for safety
        printf("ik= %d\n",ik);
        for (ij=0; ij<ik; ij++){
         if(ij == (ik-1)) buf_send[ij+1] = carray[(2*ij)+1]+(((imod<<11)+(ichip<<8)+0x0)<<16);
         else buf_send[ij+1] = carray[(2*ij)+1]+ (carray[(2*ij)+2]<<16);
         send_array[ij+1] = buf_send[ij+1];
        }
       }
       else ik=1;

           for (ij=ik-10; ij< ik+1; ij++) {
            printf("Last data = %d, %x\n",ij,buf_send[ij]);
           }

       nword =ik+1;
       i=1;
       i = pcie_send(hDev, i, nword, px);
      }
      usleep(2000);    // wait for 2ms to cover the packet time plus fpga init time
      fclose(inpf);
//
      printf(" xmit done, booting FEM \n");
      scanf("%d",&ik);

//
//    Boot stratix after XMIT module
//
      inpf = fopen("/home/ub/feb_fpga_test","r");
      imod=11;
      ichip=mb_feb_conf_add;
      buf_send[0]=(imod<<11)+(ichip<<8)+0x0+(0x0<<16);  // turn conf to be on
      i=1;
      k=1;
      i = pcie_send(hDev, i, k, px);
//      for (i=0; i<100000; i++) {
//          ik= i%2;
//          dummy1= (ik+i)*(ik+i);
//      }


        /* read data as characters (28941) */
      usleep(1000);   // wait fior a while
      count = 0;
      counta= 0;
      ichip_c = 7; // set ichip_c to stay away from any other command in the
      dummy1 =0;
      while (fread(&charchannel,sizeof(char),1,inpf)==1) {
       carray[count] = charchannel;
       count++;
       counta++;
       if((count%(nsend*2)) == 0) {
//        printf(" loop = %d\n",dummy1);
        buf_send[0] = (imod <<11) +(ichip_c <<8)+ (carray[0]<<16);
        send_array[0] =buf_send[0];
        if(dummy1 <= 5 ) printf(" counta = %d, first word = %x, %x, %x %x %x \n",counta,buf_send[0], carray[0], carray[1]
        ,carray[2], carray[3]);
        for (ij=0; ij< nsend; ij++) {
         if(ij== (nsend-1)) buf_send[ij+1] = carray[2*ij+1]+(0x0<<16);
         else buf_send[ij+1] = carray[2*ij+1]+ (carray[2*ij+2]<<16);
//         buf_send[ij+1] = carray[2*ij+1]+ (carray[2*ij+2]<<16);
         send_array[ij+1] = buf_send[ij+1];
        }
        nword =nsend+1;
        i=1;
//       if(dummy1 == 0)
        ij = pcie_send(hDev, i, nword, px);
        nanosleep(&tim , &tim2);
        dummy1 = dummy1+1;
        count =0;
       }
      }
      if(feof(inpf)) {
       printf("You have reached the end-of-file word count= %d %d\n", counta, count);
       buf_send[0] = (imod <<11) +(ichip_c <<8)+ (carray[0]<<16);
       if ( count > 1) {
        if( ((count-1)%2) ==0) {
         ik =(count-1)/2;
        }
        else {
         ik =(count-1)/2+1;
        }
        ik=ik+2;   // add one more for safety
        printf("ik= %d\n",ik);
        for (ij=0; ij<ik; ij++){
         if(ij == (ik-1)) buf_send[ij+1] = carray[(2*ij)+1]+(((imod<<11)+(ichip<<8)+0x0)<<16);
         else buf_send[ij+1] = carray[(2*ij)+1]+ (carray[(2*ij)+2]<<16);
         send_array[ij+1] = buf_send[ij+1];
        }
       }
       else ik=1;

           for (ij=ik-10; ij< ik+1; ij++) {
            printf("Last data = %d, %x\n",ij,buf_send[ij]);
           }

       nword =ik+1;
       i=1;
       i = pcie_send(hDev, i, nword, px);
      }
      usleep(2000);    // wait for 2ms to cover the packet time plus fpga init time
      fclose(inpf);
//
//    both FEM and XMIT bootted.
//
//
//   /* set tx mode register */
//
     u32Data = 0x00003fff;  // set up number of words hold coming back from the XMIT module
     printf(" number of words for hold be send back = %x\n",u32Data);
     dwOffset = 0x28;
     dwAddrSpace =2;
     WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);
//
//   set up hold
//
     printf(" set up the hold condition \n");
     dwAddrSpace =2;
     u32Data = 0x8000000;    // set up transmitter to return the hold -- upper transciever
     dwOffset = 0x18;
     WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);
     dwAddrSpace =2;
     u32Data = 0x8000000;    // set up transmitter to return the hold -- lower transciever
     dwOffset = 0x20;
     WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);



//
//    start testing routine
//
       printf(" enter 1 to reset the dram \n");
       scanf("%d",&ik);
 //      ik =1;
       if(ik ==1) {
         imod=11;
         ichip=3;
         buf_send[0]=(imod<<11)+(ichip<<8)+31+(0x1<<16);  // turm the DRAM reset on
         i=1;
         k=1;
         i = pcie_send(hDev, i, k, px);
         imod=11;
         ichip=3;
         buf_send[0]=(imod<<11)+(ichip<<8)+31+(0x0<<16);  // turm the DRAM reset off
         i=1;
         k=1;
         i = pcie_send(hDev, i, k, px);

         usleep(5000);    // wait for 5 ms for DRAM to be initialized

         imod=11;
         ichip=3;
         buf_send[0]=(imod<<11)+(ichip<<8)+6+(imod<<16);  // set module number
         i=1;
         k=1;
         i = pcie_send(hDev, i, k, px);


       }
//       printf(" enter 1 to read system status \n");
//       scanf("%d",&ik);
       ik=1;
       nword =1;
       if(ik ==1) {


         i = pcie_rec(hDev,0,1,nword,iprint,py);     // init the receiver

         imod=11;
         ichip=3;
         buf_send[0]=(imod<<11)+(ichip<<8)+20+(0x0<<16);  // read out status
         i=1;
         k=1;
         i = pcie_send(hDev, i, k, px);
         py = &read_array;
         i = pcie_rec(hDev,0,2,nword,iprint,py);     // read out 2 32 bits words
         printf("receive data word = %x, %x \n", read_array[0], read_array[1]);
       }
//       printf(" enter L1 trigger delay \n");
//       scanf("%d",&itrig_delay);
       itrig_delay = 51;
       nword =1;
//
// set to use test generator 2, set test =2
//
       imod=11;
       ichip=mb_feb_pass_add;
       buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_test_source+(0x2<<16);  // set test source to 2
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);
//
// set frame set to be 255 --- there will be 256/8 = 32 adc samples.
//
       imod=0;
       ichip=1;
       iframe= 255;    //1023
       buf_send[0]=(imod<<11)+(ichip<<8)+(mb_cntrl_load_frame)+((iframe & 0xffff)<<16); //enable test mode
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);


//
// load trig 1 position relative to the frame..
//
       imod=0;
       ichip=1;
       buf_send[0]=(imod<<11)+(ichip<<8)+(mb_cntrl_load_trig_pos)+((itrig_delay & 0xffff)<<16); //enable test mode
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);
//
//    start loading the test 2 data memory
//
       imod =11;
       ichip=3;
       for (is=0; is<64; is++) {
        ik = 0x4000+is;                        // load channel address
        buf_send[0]=(imod<<11)+(ichip<<8)+(mb_feb_test_ram_data)+((ik & 0xffff)<<16); //enable test mode
        i = pcie_send(hDev, 1, 1, px);
        ibase = 32*is;
        il = is%8;
        if(il == 0) printf(" loading channel %d\n",is);
        for (ik=0; ik< 256; ik++) {                 // loop over all possible address
         if(irand ==1) ijk = rand() & 0xfff ;        // use random number
         else ijk= (ibase+ik*8) & 0xfff;
//         if(ihuff == 1) {
           if((ik%4) ==0) ic =ijk;        // set data to repeat for 4 samples....
           ijk=ic;
//         }
         k = 0x8000+ ijk;        // make sure bit 15-12 is clear for the data
         buf_send[0]=(imod<<11)+(ichip<<8)+(mb_feb_test_ram_data)+((k & 0xffff)<<16); //enable test mode
         i = pcie_send(hDev, 1, 1, px);
         send_array[is*256+ik]=ijk;           //load up data map
        }
       }

       imod=11;
       ichip=3;
       if(ihuff == 1) buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_b_nocomp+(0x0<<16);  // turn the compression
       else buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_b_nocomp+(0x1<<16);  // set b channel no compression
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);

       timesize =4;
       imod=11;
       ichip=3;
       buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_timesize+(timesize<<16);  // set drift time size
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);

       a_id =0xf;
       imod=11;
       ichip=3;
       buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_b_id+(a_id<<16);  // set a_id
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);

       imod=11;
       ichip=4;
       buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_b_id+(a_id<<16);  // set a_id
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);
//
//     set max word in the pre-buffer memory
//
       ik=8000;
       imod=11;
       ichip=3;
       buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_max+(ik<<16);  // set pre-buffer max word
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);
//
//     enable hold
//
       imod=11;
       ichip=3;
       buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_hold_enable+(0x1<<16);  // enable the hold
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);

//       imod=11;
//       ichip=3;
//       buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_a_test+(0x1<<16);    // enable a test on
//       i=1;
//       k=1;
//       if(islow_read == 1) i = pcie_send(hDev, i, k, px);


       imod=11;
       ichip=4;
       buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_lst_on+(0x0<<16);    // set last module on
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);

       imod=11;
       ichip=4;
       buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_rxreset+(0x0<<16);    // reset LINKIN DPA
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);

//
//     set up xmit module  -- module count
//
       imod=imod_xmit;
       ichip=3;
       buf_send[0]=(imod<<11)+(ichip<<8)+mb_xmit_modcount+(0x0<<16);  // set number of module to 1 to enable output
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);
//
//     rest optical
//
       imod=imod_xmit;
       ichip=3;
       buf_send[0]=(imod<<11)+(ichip<<8)+mb_opt_dig_reset+(0x1<<16);  // set optical reset on
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);
//
//     enable superNova Token Passing
//
       imod=imod_xmit;
       ichip=3;
       buf_send[0]=(imod<<11)+(ichip<<8)+mb_xmit_enable_2+(0x1<<16);  // enable token 1 pass
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);
//
//
       printf(" enter 1 to reset the DPA \n");
       scanf("%d",&ik);

//
//     reset XMIT LINK IN DPA
//
       imod=imod_xmit;
       ichip=3;
       buf_send[0]=(imod<<11)+(ichip<<8)+mb_xmit_link_reset+(0x1<<16);  //  reset XMIT LINK IN DPA
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);
//
//     wait for 10ms just in case
//
       usleep(10000);
       printf(" XMIT FIFO reset \n");
//
//     reset XMIT FIFO reset
//
       imod=imod_xmit;
       ichip=3;
       buf_send[0]=(imod<<11)+(ichip<<8)+mb_xmit_dpa_fifo_reset+(0x1<<16);  //  reset XMIT LINK IN DPA
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);

//
//
//

       for (is=0; is<1; is++) {
//
//      test re-align circuit
//
        imod=imod_xmit;
        ichip=3;
        buf_send[0]=(imod<<11)+(ichip<<8)+mb_xmit_dpa_word_align+(0x1<<16);  //  send alignment pulse
        i=1;
        k=1;
        i = pcie_send(hDev, i, k, px);

//        printf(" enter 1 to set continue on re-align circuit \n");
//        scanf("%d",&ik);
       }

       usleep(5000); //wait for 5 ms
       printf(" XMIT re-align done \n");

//       dwDMABufSize = 200000;
       if(ifr ==0) {
        ifr=1;
        printf(" buffer allocation \n");
        dwStatus = WDC_DMAContigBufLock(hDev2, &pbuf_rec, dwOptions_rec, dwDMABufSize, &pDma_rec);
        if (WD_STATUS_SUCCESS != dwStatus) {
         printf("Failed locking a rec Contiguous DMA buffer. Error 0x%lx - %s\n", dwStatus, Stat2Str(dwStatus));
         printf("enter 1 to continue \n");
         scanf("%d",&is);
        }
       }

/* set tx mode register */

       u32Data = 0x000003ff;
       dwOffset = tx_md_reg;
       dwAddrSpace =cs_bar;
       WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);

/* write this will abort previous DMA */
       dwAddrSpace =2;
       dwOffset = cs_dma_msi_abort;
       u32Data = dma_abort;
       WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);
/* clear DMA register after the abort */
       dwAddrSpace =2;
       dwOffset = cs_dma_msi_abort;
       u32Data = 0;
       WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);

       buffp_rec32 = pbuf_rec;

/* synch cache */
       WDC_DMASyncCpu(pDma_rec);
       if(idebug ==1) printf(" synch CPU \n");
///
///    set up the DMA size  (half buffer size limit??)
///
       nwrite =(dwDMABufSize/8);  //remove factor 2 
//       nwrite = 4000;

       for (is=1; is<3; is++) {
        tr_bar = t1_tr_bar;
        r_cs_reg = r1_cs_reg;
        dma_tr = dma_tr1;
        if(is == 2) {
         tr_bar = t2_tr_bar;
         r_cs_reg = r2_cs_reg;
         dma_tr = dma_tr2;
        }
        if(idebug ==1) printf(" is = %d\n",is);
/** initialize the receiver ***/
        u32Data = cs_init;
        dwOffset = r_cs_reg;
        dwAddrSpace =cs_bar;
        WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);
/** start the receiver **/
        dwAddrSpace = cs_bar;
        u32Data = cs_start+(nwrite*2)*4;   /* 32 bits mode == 4 bytes per word *2 fibers **/
        dwOffset = r_cs_reg;
        WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);
       }
       if(idebug ==1) printf(" initial receiver \n");
//       scanf("%d",&ik);
/** set up DMA for both transceiver together **/

       dwAddrSpace =cs_bar;
       dwOffset = cs_dma_add_low_reg;
       u32Data = pDma_rec->Page->pPhysicalAddr & 0xffffffff;
       WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);

       dwAddrSpace =cs_bar;
       dwOffset = cs_dma_add_high_reg;
       u32Data = (pDma_rec->Page->pPhysicalAddr >> 32) & 0xffffffff;
       WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);

/* byte count */
       dwAddrSpace =cs_bar;
       dwOffset = cs_dma_by_cnt;
       u32Data = (nwrite)*4*2;      /** twice more data - from fiber 1& 2**/
       WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);


/* write this will start DMA */
       dwAddrSpace =2;
       dwOffset = cs_dma_cntrl;
       u32Data = dma_tr12+dma_3dw_rec;
       WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);
       if(idebug ==1) printf(" DMA set up done \n");

//
//      turn the run on to start data flow
//
       printf(" enter 1 to set the RUN on \n");
       scanf("%d",&ik);

       imod=0;
       ichip=1;
       buf_send[0]=(imod<<11)+(ichip<<8)+(mb_cntrl_set_run_on)+(0x0<<16); //enable offline run on
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);

/***    check to see if DMA is done or not **/
       idone =0;
       for (is=0; is<6000; is++) {;
          dwAddrSpace =cs_bar;
 	  u64Data =0;
	  dwOffset = cs_dma_cntrl;
          WDC_ReadAddr32(hDev2, dwAddrSpace, dwOffset, &u32Data);
	  if(idebug ==1) printf(" receive DMA status word %d %X \n", is, u32Data);
	  if((u32Data & dma_in_progress) == 0) {
            idone =1;
            if(idebug ==1) printf(" receive DMA complete %d \n", i);
          }
	  if((u32Data & dma_in_progress) == 0) break;
       }
       if(idone == 0) {
         printf(" loop 0, DMA is not finished \n");
         scanf("%d",&is);
       }
	/* synch DMA i/O cache **/

       WDC_DMASyncIo(pDma_rec);
//
       if(idebug == 1) {
        dwAddrSpace =cs_bar;
        u64Data =0;
        dwOffset = t1_cs_reg;
        WDC_ReadAddr64(hDev2, dwAddrSpace, dwOffset, &u64Data);
        printf (" status word for channel 1 after read = %x, %x \n",(u64Data>>32), (u64Data &0xffff));
        dwAddrSpace =cs_bar;
        u64Data =0;
        dwOffset = t2_cs_reg;
        WDC_ReadAddr64(hDev2, dwAddrSpace, dwOffset, &u64Data);
        printf (" status word for channel 2 after read = %x, %x \n",(u64Data>>32), (u64Data &0xffff));
       }

//
//     copy of the data array
//
       for (is=0; is<nwrite*2; is++) {
         read_array[is]= *buffp_rec32++;
       }
//
//     set up for the second loop
//
//       dwDMABufSize = 20000;

/* write this will abort previous DMA */
       dwAddrSpace =2;
       dwOffset = cs_dma_msi_abort;
       u32Data = dma_abort;
//       WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);
/* clear DMA register after the abort */
       dwAddrSpace =2;
       dwOffset = cs_dma_msi_abort;
       u32Data = 0;
//       WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);

       buffp_rec32 = pbuf_rec;

/* synch cache */
       WDC_DMASyncCpu(pDma_rec);
       if(idebug ==1) printf(" synch CPU \n");
///
///    set up the DMA size  (half buffer size limit??)
///
       nwrite =(dwDMABufSize/8);  //remove factor 2
//       nwrite = 4000;

       for (is=1; is<3; is++) {
        tr_bar = t1_tr_bar;
        r_cs_reg = r1_cs_reg;
        dma_tr = dma_tr1;
        if(is == 2) {
         tr_bar = t2_tr_bar;
         r_cs_reg = r2_cs_reg;
         dma_tr = dma_tr2;
        }
        if(idebug ==1) printf(" is = %d\n",is);
//
//      do not init the receiver... otherwise it will remove data from the fifo
/** start the receiver **/
//
        dwAddrSpace = cs_bar;
        u32Data = cs_start+(nwrite*2)*4;   /* 32 bits mode == 4 bytes per word *2 fibers **/
        dwOffset = r_cs_reg;
        WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);
       }
       if(idebug ==1) printf(" initial receiver \n");
//       scanf("%d",&ik);
//
/** set up DMA for both transceiver together **/
//
       dwAddrSpace =cs_bar;
       dwOffset = cs_dma_add_low_reg;
       u32Data = pDma_rec->Page->pPhysicalAddr & 0xffffffff;
       WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);

       dwAddrSpace =cs_bar;
       dwOffset = cs_dma_add_high_reg;
       u32Data = (pDma_rec->Page->pPhysicalAddr >> 32) & 0xffffffff;
       WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);

/* byte count */
       dwAddrSpace =cs_bar;
       dwOffset = cs_dma_by_cnt;
       u32Data = (nwrite)*4*2;      /** twice more data - from fiber 1& 2**/
       WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);


/* write this will start DMA */
       dwAddrSpace =2;
       dwOffset = cs_dma_cntrl;
       u32Data = dma_tr12+dma_3dw_rec;
       WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);
       if(idebug ==1) printf(" DMA set up done \n");
//
/***    check to see if DMA is done or not **/
//
       idone =0;
       for (is=0; is<6000; is++) {;
          dwAddrSpace =cs_bar;
 	  u64Data =0;
	  dwOffset = cs_dma_cntrl;
          WDC_ReadAddr32(hDev2, dwAddrSpace, dwOffset, &u32Data);
	  if(idebug ==1) printf(" receive DMA status word %d %X \n", is, u32Data);
	  if((u32Data & dma_in_progress) == 0) {
            idone =1;
            if(idebug ==1) printf(" receive DMA complete %d \n", i);
          }
	  if((u32Data & dma_in_progress) == 0) break;
       }
	/* synch DMA i/O cache **/
       if(idone == 0) {
         printf(" loop 1, DMA is not finished \n");
         scanf("%d",&is);
       }
       WDC_DMASyncIo(pDma_rec);
//
       if(idebug ==1) {
        dwAddrSpace =cs_bar;
        u64Data =0;
        dwOffset = t1_cs_reg;
        WDC_ReadAddr64(hDev2, dwAddrSpace, dwOffset, &u64Data);
        printf (" status word for channel 1 after read = %x, %x \n",(u64Data>>32), (u64Data &0xffff));
        dwAddrSpace =cs_bar;
        u64Data =0;
        dwOffset = t2_cs_reg;
        WDC_ReadAddr64(hDev2, dwAddrSpace, dwOffset, &u64Data);
        printf (" status word for channel 2 after read = %x, %x \n",(u64Data>>32), (u64Data &0xffff));
       }

//
//     copy of the data array
//
       for (is=0; is<nwrite*2; is++) {
         read_array[is+(nwrite*2)]= *buffp_rec32++;
       }
//
//     set up for the third loop
//
//       dwDMABufSize = 20000;

/* write this will abort previous DMA */
       dwAddrSpace =2;
       dwOffset = cs_dma_msi_abort;
       u32Data = dma_abort;
//       WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);
/* clear DMA register after the abort */
       dwAddrSpace =2;
       dwOffset = cs_dma_msi_abort;
       u32Data = 0;
//       WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);

       buffp_rec32 = pbuf_rec;

/* synch cache */
       WDC_DMASyncCpu(pDma_rec);
       if(idebug ==1) printf(" synch CPU \n");
///
///    set up the DMA size  (half buffer size limit??)
///
       nwrite =(dwDMABufSize/8);  //remove factor 2
//       nwrite = 4000;

       for (is=1; is<3; is++) {
        tr_bar = t1_tr_bar;
        r_cs_reg = r1_cs_reg;
        dma_tr = dma_tr1;
        if(is == 2) {
         tr_bar = t2_tr_bar;
         r_cs_reg = r2_cs_reg;
         dma_tr = dma_tr2;
        }
        if(idebug ==1) printf(" is = %d\n",is);
//
//      do not init the receiver... otherwise it will remove data from the fifo
/** start the receiver **/
//
        dwAddrSpace = cs_bar;
        u32Data = cs_start+(nwrite*2)*4;   /* 32 bits mode == 4 bytes per word *2 fibers **/
        dwOffset = r_cs_reg;
        WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);
       }
       if(idebug ==1) printf(" initial receiver \n");
//       scanf("%d",&ik);
//
/** set up DMA for both transceiver together **/
//
       dwAddrSpace =cs_bar;
       dwOffset = cs_dma_add_low_reg;
       u32Data = pDma_rec->Page->pPhysicalAddr & 0xffffffff;
       WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);

       dwAddrSpace =cs_bar;
       dwOffset = cs_dma_add_high_reg;
       u32Data = (pDma_rec->Page->pPhysicalAddr >> 32) & 0xffffffff;
       WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);

/* byte count */
       dwAddrSpace =cs_bar;
       dwOffset = cs_dma_by_cnt;
       u32Data = (nwrite)*4*2;      /** twice more data - from fiber 1& 2**/
       WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);


/* write this will start DMA */
       dwAddrSpace =2;
       dwOffset = cs_dma_cntrl;
       u32Data = dma_tr12+dma_3dw_rec;
       WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);
       if(idebug ==1) printf(" DMA set up done \n");
//
/***    check to see if DMA is done or not **/
//
       idone =0;
       for (is=0; is<6000; is++) {;
          dwAddrSpace =cs_bar;
 	  u64Data =0;
	  dwOffset = cs_dma_cntrl;
          WDC_ReadAddr32(hDev2, dwAddrSpace, dwOffset, &u32Data);
	  if(idebug ==1) printf(" receive DMA status word %d %X \n", is, u32Data);
	  if((u32Data & dma_in_progress) == 0) {
            idone =1;
            if(idebug ==1) printf(" receive DMA complete %d \n", i);
          }
	  if((u32Data & dma_in_progress) == 0) break;
       }
       if(idone == 0) {
         printf(" loop 2, DMA is not finished \n");
         dwAddrSpace =cs_bar;
         dwOffset = cs_dma_by_cnt;
         WDC_ReadAddr64(hDev2, dwAddrSpace, dwOffset, &u64Data);
         printf (" DMA word count = %x, %x \n",(u64Data>>32), (u64Data &0xffff));
/* write this will abort previous DMA */
         dwAddrSpace =2;
         dwOffset = cs_dma_msi_abort;
         u32Data = dma_abort;
         WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);
/* clear DMA register after the abort */
         dwAddrSpace =2;
         dwOffset = cs_dma_msi_abort;
         u32Data = 0;
         WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);
         scanf("%d",&is);
       }
	/* synch DMA i/O cache **/

       WDC_DMASyncIo(pDma_rec);
//
       if(idebug ==1) {
        dwAddrSpace =cs_bar;
        u64Data =0;
        dwOffset = t1_cs_reg;
        WDC_ReadAddr64(hDev2, dwAddrSpace, dwOffset, &u64Data);
        printf (" status word for channel 1 after read = %x, %x \n",(u64Data>>32), (u64Data &0xffff));
        dwAddrSpace =cs_bar;
        u64Data =0;
        dwOffset = t2_cs_reg;
        WDC_ReadAddr64(hDev2, dwAddrSpace, dwOffset, &u64Data);
        printf (" status word for channel 2 after read = %x, %x \n",(u64Data>>32), (u64Data &0xffff));
       }

//
//     copy of the data array
//
       for (is=0; is<nwrite*2; is++) {
         read_array[is+(2*(nwrite*2))]= *buffp_rec32++;
       }
//
//
//
       for (is=0; is< nwrite*6; is++) {
        if((is%8) ==0) printf("%4d",is);
        if(((is%25000) ==0) && (is !=0)) {
          printf(" type 1 to continue\n");
          scanf("%d", &dummy1);
        }
        printf(" %8x",read_array[is]);
        if(((is+1)%8) ==0 ) printf("\n");
       }
       if(((is+1)*8) != 0)printf("\n");

       for(is=0; is< 6*nwrite; is++) {
         read_array_s[is*2] = (read_array[is] & 0xffff);
         read_array_s[is*2+1] = ((read_array[is] >>16) & 0xffff);
       }
       nread = ((read_array_s[4] & 0xfff) << 12)+ (read_array_s[5] & 0xfff);
       nread =nread+1;
       nread = nread/2;
       for (is=0; is< nread+7; is++) {       // 6 header + 1 trailer.
        read_comp[is] = read_array[is];
       }

       icomp_l = (nwrite*6)/(nread+7); // only compare complete event  // have to add header
       if(comp_s ==1) printf(" compare %d of event in the loop, nread = %d \n",icomp_l, nread);
       if(comp_s == 1) {
        for(is=0; is<icomp_l; is++) {
         for (ik=6; ik< nread+6; ik++) {   //for the moment skip header
          k=ik+is*(nread+7);
          if(read_comp[ik] != read_array[k]) {
            printf(" data error seq = %d, seq= %d, event = %d, first event data word = %8x, data = %8x \n", ik,k,is,read_comp[ik], read_array[k]);
            scanf("%d",&k);
          }
         }
        }
       }
       printf(" compare finished \n");
       scanf("%d",&is);
       is=0;
       while (is < nwrite*2) {
         if(((nwrite*2)-is) <= 12) printf(" not enough word header \n");
         if(((nwrite*2)-is) <= 12) break;
         if((read_array_s[is] == 0xffff) && (read_array_s[is+1] == 0xffff)) {
          printf(" event header %8x \n", read_array_s[is]+(read_array_s[is+1] << 16));
          is=is+2;
          printf(" module header = %4x\n", read_array_s[is]);
          is=is+1;
          printf(" address word = %4x, aid = %2x, module numebr %3d\n", read_array_s[is], ((read_array_s[is]>>5) &0x7f), (read_array_s[is] &0x1f));
          is=is+1;
          ik= (read_array_s[is]<<16)+ (read_array_s[is+1]);
          nread=  ((read_array_s[is] & 0xfff) << 12)+ (read_array_s[is+1] & 0xfff);
          nread = nread+1;
          printf(" word count word = %8x, word count = %8d \n", ik,nread);
          is = is+2;
          ik= (read_array_s[is]<<16)+ (read_array_s[is+1]);
          k=  ((read_array_s[is] & 0xfff) << 12)+ (read_array_s[is+1] & 0xfff);
          printf(" event number word = %8x, event number = %8d \n", ik,k);
          is = is+2;
          ik= (read_array_s[is]<<16)+ (read_array_s[is+1]);
          k=  ((read_array_s[is] & 0xfff) << 12)+ (read_array_s[is+1] & 0xfff);
          printf(" frame number word = %8x, frame number = %8d \n", ik,k);
          is =is+2;
          ik= (read_array_s[is]<<16)+ (read_array_s[is+1]);
          k=  ((read_array_s[is] & 0xfff) << 12)+ (read_array_s[is+1] & 0xfff);
          printf(" checksum word = %8x, checksum = %8x \n", ik,k);
          is=is+2;
         if(((nwrite*2)-is) <= (nread+2)) printf(" not enough word for the event \n");
         if(((nwrite*2)-is) <= (nread+2)) break;
          is=is+nread;
          printf("end of packet word, %8x \n", read_array_s[is]+ (read_array_s[is+1]<<16));
          is = is+2;
          scanf("%d", &ik);
         }
       }

       imod=0;
       ichip=1;
       buf_send[0]=(imod<<11)+(ichip<<8)+(mb_cntrl_set_run_off)+(0x0<<16); //enable offline run off
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);
       scanf("%d",&ik);
      }

     break;



    case 26:
     printf(" multiple ADC board test \n");
     printf(" enable number of loop\n");
//***     scanf("%d",&nloop);
//     printf(" 1 for checking the event \n");
//     scanf("%d",&icheck);
//     printf(" type 1 to use random number \n");
//     scanf("%d",&irand);
     icheck = 0;
     irand =0;
     if(icheck != 1) {
      printf(" 1 for print event\n");
//***      scanf("%d",&iprint);
     }
     else iprint =0;
     printf(" number event \n");
//***     scanf("%d",&nevent);
     iprint =1;
     nloop=10;
     nevent=10;
//****

     printf(" first FEM module address \n");
     scanf("%d", &ifem_fst);
     printf(" last FEM module address \n");
     scanf("%d", &ifem_lst);

//     printf(" enter number of words per packet \n");
//     scanf("%d",&nsend);
     nsend=500;

     px = &buf_send;
     py = &read_array;
     imod =0;  /* controller module */
/** initialize **/
     buf_send[0]=0x0;
     buf_send[1]=0x0;
     i=1;
     k=1;
     i = pcie_send(hDev, i, k, px);
// set offline test
     imod=0;
     ichip=1;
     buf_send[0]=(imod<<11)+(ichip<<8)+(mb_cntrl_test_on)+(0x0<<16); //enable offline run on
     i=1;
     k=1;
     i = pcie_send(hDev, i, k, px);



//     printf(" enable number of loop\n");
//     scanf("%d",&nloop);
     for ( j=0; j<nloop; j++) {
//
//disable the run command
      imod=0;
      ichip=1;
      buf_send[0]=(imod<<11)+(ichip<<8)+(mb_cntrl_set_run_off)+(0x0<<16); //enable offline run on
      i=1;
      k=1;
      i = pcie_send(hDev, i, k, px);

      itrig_delay = 51;
//
// set frame set to be 1023 --- there will be 1024/8 = 128 adc samples.
//
      imod=0;
      ichip=1;
      iframe= 255;    //1023
      buf_send[0]=(imod<<11)+(ichip<<8)+(mb_cntrl_load_frame)+((iframe & 0xffff)<<16); //enable test mode
      i=1;
      k=1;
      i = pcie_send(hDev, i, k, px);


//
// load trig 1 position relative to the frame..
//
      imod=0;
      ichip=1;
      buf_send[0]=(imod<<11)+(ichip<<8)+(mb_cntrl_load_trig_pos)+((itrig_delay & 0xffff)<<16); //enable test mode
      i=1;
      k=1;
      i = pcie_send(hDev, i, k, px);

//
//

      for (ifem_loop=ifem_fst; ifem_loop< (ifem_lst+1); ifem_loop++) {
 // turn on the Stratix III power supply
       printf(" starting boot module %d\n", ifem_loop);
       imod=ifem_loop;
       ichip =1;
       buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_power_add+(0x0<<16); //turn module 11 power on
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);
       usleep(200000);  // wait for 200 ms
       usleep(10000); // wait for 10ms
       inpf = fopen("/home/ub/feb_fpga_test","r");
//       imod=11;
       ichip=mb_feb_conf_add;
       buf_send[0]=(imod<<11)+(ichip<<8)+0x0+(0x0<<16);  // turn conf to be on
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);
//      for (i=0; i<100000; i++) {
//          ik= i%2;
//          dummy1= (ik+i)*(ik+i);
//      }


        /* read data as characters (28941) */
       usleep(1000);   // wait fior a while
       count = 0;
       counta= 0;
       ichip_c = 7; // set ichip_c to stay away from any other command in the
       dummy1 =0;
       while (fread(&charchannel,sizeof(char),1,inpf)==1) {
        carray[count] = charchannel;
        count++;
        counta++;
        if((count%(nsend*2)) == 0) {
//        printf(" loop = %d\n",dummy1);
         buf_send[0] = (imod <<11) +(ichip_c <<8)+ (carray[0]<<16);
         send_array[0] =buf_send[0];
         if(dummy1 <= 5 ) printf(" counta = %d, first word = %x, %x, %x %x %x \n",counta,buf_send[0], carray[0], carray[1]
        ,carray[2], carray[3]);
         for (ij=0; ij< nsend; ij++) {
          if(ij== (nsend-1)) buf_send[ij+1] = carray[2*ij+1]+(0x0<<16);
          else buf_send[ij+1] = carray[2*ij+1]+ (carray[2*ij+2]<<16);
//         buf_send[ij+1] = carray[2*ij+1]+ (carray[2*ij+2]<<16);
          send_array[ij+1] = buf_send[ij+1];
         }
         nword =nsend+1;
         i=1;
//       if(dummy1 == 0)
         ij = pcie_send(hDev, i, nword, px);
         nanosleep(&tim , &tim2);
         dummy1 = dummy1+1;
         count =0;
        }
       }
       if(feof(inpf)) {
        printf("You have reached the end-of-file word count= %d %d\n", counta, count);
        buf_send[0] = (imod <<11) +(ichip_c <<8)+ (carray[0]<<16);
        if ( count > 1) {
         if( ((count-1)%2) ==0) {
          ik =(count-1)/2;
         }
         else {
          ik =(count-1)/2+1;
         }
         ik=ik+2;   // add one more for safety
         printf("ik= %d\n",ik);
         for (ij=0; ij<ik; ij++){
          if(ij == (ik-1)) buf_send[ij+1] = carray[(2*ij)+1]+(((imod<<11)+(ichip<<8)+0x0)<<16);
          else buf_send[ij+1] = carray[(2*ij)+1]+ (carray[(2*ij)+2]<<16);
          send_array[ij+1] = buf_send[ij+1];
         }
        }
        else ik=1;

        for (ij=ik-10; ij< ik+1; ij++) {
            printf("Last data = %d, %x\n",ij,buf_send[ij]);
        }
        nword =ik+1;
        i=1;
        i = pcie_send(hDev, i, nword, px);
        usleep(2000);    // wait for 2ms to cover the packet time plus fpga init time
       }

       fclose(inpf);
       printf(" enter 1 to reset the dram \n");
       scanf("%d",&ik);
//       ik =1;
//       if(ik ==1) {
//         imod=11;
       ichip=3;
       buf_send[0]=(imod<<11)+(ichip<<8)+31+(0x1<<16);  // turm the DRAM reset on
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);
//         imod=11;
       ichip=3;
       buf_send[0]=(imod<<11)+(ichip<<8)+31+(0x0<<16);  // turm the DRAM reset off
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);

       usleep(5000);    // wait for 5 ms for DRAM to be initialized

//         imod=11;
       ichip=3;
       buf_send[0]=(imod<<11)+(ichip<<8)+6+(imod<<16);  // set module number
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);


//        }
//      printf(" enter 1 to read system status \n");
//       scanf("%d",&ik);
//        ik=1;
       nword =1;
//        if(ik ==1) {


       i = pcie_rec(hDev,0,1,nword,iprint,py);     // init the receiver

//         imod=11;
       ichip=3;
       buf_send[0]=(imod<<11)+(ichip<<8)+20+(0x0<<16);  // read out status
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);
       py = &read_array;
       i = pcie_rec(hDev,0,2,nword,iprint,py);     // read out 2 32 bits words
       printf("receive data word = %x, %x \n", read_array[0], read_array[1]);
//        }
//       printf(" enter L1 trigger delay \n");
//       scanf("%d",&itrig_delay);

//
//        set adc operatio -- soft reset
//
       for (is=0; is<8; is++) {
//         imod=11;
        ichip=5;
        buf_send[0]=(imod<<11)+(ichip<<8)+(mb_pmt_spi_add)+((is & 0xf)<<16); //set spi address
        i=1;
        k=1;
        i = pcie_send(hDev, i, k, px);
//       printf(" spi port %d \n",is);
//       scanf("%d",&ik);

//        imod=11;
        ichip=5;
        buf_send[0]=(imod<<11)+(ichip<<8)+(mb_pmt_adc_data_load)+(0x0300<<16); //1st next word will be overwrite by the next next word
        buf_send[1]=(((0x0)<<13)+(0x0))+((0x3c)<<24)+((0x0)<<16);
//
//  set /w =0, w1,w2 =0, a12-a0 = 0x0, data =0x3c;
//

        i=1;
        k=2;
//       i = pcie_send(hDev, i, k, px);
        usleep(2000);   // sleep for 2ms
       }
//       usleep(2000);   // sleep for 2ms
       printf(" enter 1 to continue after soft reset\n");
//***       scanf("%d",&ik);
//
//     set to double terminate the ADC driver
//
       for (is=0; is<8; is++) {
//         imod=11;
        ichip=5;
        buf_send[0]=(imod<<11)+(ichip<<8)+(mb_pmt_spi_add)+((is & 0xf)<<16); //set spi address
        i=1;
        k=1;
        i = pcie_send(hDev, i, k, px);
        usleep(2000);   // sleep for 2ms
        printf(" spi port %d \n",is);
//       scanf("%d",&ik);

//        imod=11;
        ichip=5;
        buf_send[0]=(imod<<11)+(ichip<<8)+(mb_pmt_adc_data_load)+(0x0300<<16); //1st next word will be overwrite by the next next word
        buf_send[1]=(((0x0)<<13)+(0x15))+((0x30)<<24)+((0x0)<<16);
//        buf_send[1]=(((0x0)<<13)+(0xd))+((0xa)<<24)+((0x0)<<16);
//
//  set /w =0, w1,w2 =0, a12-a0 = 0x15, data =0x30;
//

        i=1;
        k=2;
//        i = pcie_send(hDev, i, k, px);
        usleep(2000);   // sleep for 2ms
        printf(" spi port 2nd command %d \n",is);
//       scanf("%d",&ik);

//        imod=11;
        ichip=5;
        buf_send[0]=(imod<<11)+(ichip<<8)+(mb_pmt_adc_data_load)+(0x0300<<16); //1st next word will be overwrite by the next next word
        buf_send[1]=(((0x0)<<13)+(0xff))+((0x1)<<24)+((0x0)<<16);
//
//  set /w =0, w1,w2 =0, a12-a0 = 0xff, data =0x1;
//  write to transfer register
//

        i=1;
        k=2;
//        i = pcie_send(hDev, i, k, px);
        usleep(2000);   // sleep for 2ms

       }
//
//    the ADC spi stream.. The 16 bits data before the last word is r/w, w1, w2 and 13 bits address
//                         the last 16 bits.upper byte = 8 bits data and lower 8 bits ignored.
//
       for (is=0; is<8; is++) {
//         imod=11;
        ichip=5;
        buf_send[0]=(imod<<11)+(ichip<<8)+(mb_pmt_spi_add)+((is & 0xf)<<16); //set spi address
        i=1;
        k=1;
        i = pcie_send(hDev, i, k, px);
        usleep(2000);   // sleep for 2ms
        printf(" spi port %d \n",is);
//       scanf("%d",&ik);

//        imod=11;
        ichip=5;
        buf_send[0]=(imod<<11)+(ichip<<8)+(mb_pmt_adc_data_load)+(0x0300<<16); //1st next word will be overwrite by the next next word
        buf_send[1]=(((0x0)<<13)+(0xd))+((0xc)<<24)+((0x0)<<16);
//        buf_send[1]=(((0x0)<<13)+(0xd))+((0xa)<<24)+((0x0)<<16);
//
//  set /w =0, w1,w2 =0, a12-a0 = 0xd, data =0xb;
//

        i=1;
        k=2;
        i = pcie_send(hDev, i, k, px);
        usleep(2000);   // sleep for 2ms
        printf(" spi port 2nd command %d \n",is);
//       scanf("%d",&ik);

//        imod=11;
        ichip=5;
        buf_send[0]=(imod<<11)+(ichip<<8)+(mb_pmt_adc_data_load)+(0x0300<<16); //1st next word will be overwrite by the next next word
        buf_send[1]=(((0x0)<<13)+(0xff))+((0x1)<<24)+((0x0)<<16);
//
//  set /w =0, w1,w2 =0, a12-a0 = 0xff, data =0x1;
//  write to transfer register
//

        i=1;
        k=2;
        i = pcie_send(hDev, i, k, px);
        usleep(2000);   // sleep for 2ms

       }

       printf(" enter 1 to continue FPGA ADC receiver reset\n");
//***       scanf("%d",&ik);
//
//    send FPGA ADC receiver reset
//
//       imod=11;
       ichip=3;
       buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_adc_reset+(0x1<<16);  // FPGA ADC receiver reset on
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);


       printf(" enter 1 to continue FPGA ADC receiver align\n");
//***       scanf("%d",&ik);
//
//    send FPGA ADC align
//
//       imod=11;
       ichip=3;
       buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_adc_align+(0x0<<16);  // FPGA ADC receiver reset off
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);
       usleep(2000);   // sleep for 2ms

       printf(" finish align \n");
//****       scanf("%d",&ik);
//
//    the ADC spi stream.. The 16 bits data before the last word is r/w, w1, w2 and 13 bits address
//                         the last 16 bits.upper byte = 8 bits data and lower 8 bits ignored.
//
       for (is=0; is<8; is++) {
//        imod=11;
        ichip=5;
        buf_send[0]=(imod<<11)+(ichip<<8)+(mb_pmt_spi_add)+((is & 0xf)<<16); //set spi address
        i=1;
        k=1;
        i = pcie_send(hDev, i, k, px);
        usleep(2000);   // sleep for 2ms
        printf(" spi port %d \n",is);
//       scanf("%d",&ik);

//        imod=11;
        ichip=5;
        buf_send[0]=(imod<<11)+(ichip<<8)+(mb_pmt_adc_data_load)+(0x0300<<16); //1st next word will be overwrite by the next next word
        buf_send[1]=(((0x0)<<13)+(0xd))+((0xb)<<24)+((0x0)<<16);          // send 1 bit high
//        buf_send[1]=(((0x0)<<13)+(0xd))+((0x0)<<24)+((0x0)<<16);
//
//  set /w =0, w1,w2 =0, a12-a0 = 0xd, data =0xb;
//

        i=1;
        k=2;
        i = pcie_send(hDev, i, k, px);
        usleep(2000);   // sleep for 2ms
        printf(" spi port 2nd command %d \n",is);
//       scanf("%d",&ik);

//        imod=11;
        ichip=5;
        buf_send[0]=(imod<<11)+(ichip<<8)+(mb_pmt_adc_data_load)+(0x0300<<16); //1st next word will be overwrite by the next next word
        buf_send[1]=(((0x0)<<13)+(0xff))+((0x1)<<24)+((0x0)<<16);
//
//  set /w =0, w1,w2 =0, a12-a0 = 0xff, data =0x1;
//  write to transfer register
//

        i=1;
        k=2;
        i = pcie_send(hDev, i, k, px);
        usleep(2000);   // sleep for 2ms

       }




//        itrig_delay = 51;
       nword =1;
//
// set to not use test generator 2, set test =2
//
//        imod=11;
       ichip=mb_feb_pass_add;
       buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_test_source+(0x0<<16);  // set test source to 0
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);

//       imod=11;
       ichip=3;
       buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_a_nocomp+(0x1<<16);  // set a channel no compression
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);

       timesize =4;
//        imod=11;
       ichip=3;
       buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_timesize+(timesize<<16);  // set drift time size
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);

//       a_id =0x20;
//       imod=11;
       ichip=3;
       buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_a_id+(imod<<16);  // set a_id
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);


//       imod=11;
       ichip=3;
       buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_a_test+(0x1<<16);    // enable a test on
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);

      }
//
//
      printf(" FEM boot and setup done\n");

//
//
      imod=0;
      ichip=1;
      buf_send[0]=(imod<<11)+(ichip<<8)+(mb_cntrl_set_run_on)+(0x0<<16); //enable offline run on
      i=1;
      k=1;
      i = pcie_send(hDev, i, k, px);

      usleep(5000); //wait for 5 ms


      for (is=0; is<nevent; is++) {



       imod=0;
       ichip=1;
       buf_send[0]=(imod<<11)+(ichip<<8)+mb_cntrl_set_trig1+(0x0<<16);  // send trigger
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);

       usleep(5000); // wait for 5 ms

//      set module number again to enable the FEB module read back
       for (ifem_loop=ifem_fst; ifem_loop< (ifem_lst+1); ifem_loop++) {
        imod=ifem_loop;

//        imod=11;
        ichip=3;
        buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_a_id+(imod<<16);  // set a_id
        i=1;
        k=1;
        i = pcie_send(hDev, i, k, px);
//
//
//
//       i = pcie_rec(hDev,0,1,nword,iprint,py);     // init the receiver
//       ichip=3;
//       buf_send[0]=(imod<<11)+(ichip<<8)+20+(0x0<<16);  // read out status
//       i=1;
//       k=1;
//       i = pcie_send(hDev, i, k, px);
//       py = &read_array;
//       i = pcie_rec(hDev,0,2,nword,iprint,py);     // read out 2 32 bits words
//       printf("receive data word = %x, %x \n", read_array[0], read_array[1]);
//
//
//        usleep(1000);
        nword = 5;
        i = pcie_rec(hDev,0,1,nword,iprint,py);     // init the receiver

//        imod=11;
        ichip=3;
        buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_a_rdhed+(0x1<<16);  // read a header
        i=1;
        k=1;
        i = pcie_send(hDev, i, k, px);

        py = &read_array;
        i = pcie_rec(hDev,0,2,nword,iprint,py);     // read out 2 32 bits words
        if(iprint ==1) printf("receive data word = %x, %x, %x, %x, %x\n", read_array[0], read_array[1], read_array[2], read_array[3], read_array[4]);
        if(iprint == 1) {
          printf(" *** module number %d ***\n", imod);
          printf(" header word %x \n",(read_array[0] & 0xffff));
          k=(read_array[0]>>16) & 0xfff;
          printf(" module adress %d, id number %d\n", (k & 0x1f), ((k>>5) & 0x7f));
          printf(" number of data word to read %d\n", (((read_array[1]>>16) & 0xfff)+((read_array[1] &0xfff) <<12)));
          printf(" event number %d\n", (((read_array[2]>>16) & 0xfff)+((read_array[2] &0xfff) <<12)));
          printf(" frame number %d\n", (((read_array[3]>>16) & 0xfff)+((read_array[3] &0xfff) <<12)));
          printf(" checksum %x\n", (((read_array[4]>>16) & 0xfff)+((read_array[4] &0xfff) <<12)));
        }
        nread = ((read_array[1]>>16) & 0xfff)+((read_array[1] &0xfff) <<12);
//        if(iprint ==1) printf(" number of data word to read = %d\n",nread);

//        ik =  read_array[0] & 0x1f;
//        if(iprint ==1) printf(" module number = %d",ik);
//        ik =  (read_array[0] >> 5) & 0x7f;
//        if(iprint ==1) printf(" data ID = %d",ik);
//        ik =  (((read_array[2] >>16) & 0xfff)<<12) + (read_array[2] & 0xfff);
//        if(iprint ==1) printf(" event number = %d",ik);
//        ik =  (((read_array[3] >>16) & 0xfff)<<12) + (read_array[3] & 0xfff);
//        if(iprint ==1) printf(" frame number = %d\n",ik);
//        ik =  (((read_array[4] >>16) & 0xfff)<<12) + (read_array[4] & 0xfff);
//        if(iprint ==1) printf(" checksum = %x\n",ik);

        if(iprint ==1 )scanf("%d",&ik);
        nword = (nread+1)/2;
        nword =384;                  // short words
        i = pcie_rec(hDev,0,1,nword,iprint,py);     // init the receiver

//        imod=11;
        ichip=mb_feb_pass_add;
        buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_a_rdbuf+(0x0<<16);  // read a header
        i=1;
        k=1;
        i = pcie_send(hDev, i, k, px);

        py = &read_array;
        i = pcie_rec(hDev,0,2,nword,iprint,py);     // read out 2 32 bits words

        if(iprint == 1) {
         for (i=0; i< nword; i++) {
          if((i%8) ==0) printf("%4d",i);
          printf(" %8x",read_array[i]);
          if(((i+1)%8) ==0 ) printf("\n");
         }
        }

        ik=0;
        for (i=0; i< nword; i++) {
          read_array_s[ik] = read_array[i] &0xffff;
          read_array_s[ik+1] = ((read_array[i]>>16) & 0xffff);
          ik=ik+2;
        }

//
//      printout formatted word
//
        if(iprint ==1) {
         iset = 0;
         for(i=0; i< 2*nword; i++) {
          if((read_array_s[i] & 0xf000) == 0x4000) {
            iset=1;
            ncount=0;
            printf(" channel %d\n",(read_array_s[i] & 0xfff));
          }
          else if ((read_array_s[i] & 0xf000) == 0x5000) printf(" channel end %d\n",(read_array_s[i] &0xfff));
          else if (iset ==1) {
            printf(" %4x",read_array_s[i]);
            ncount = ncount+1;
            if((ncount%8) == 0) printf("\n");
          }
          else {
            printf("%x",read_array_s[i]);
            ncount = ncount+1;
            if((ncount%8) == 0) printf("\n");
          }
         }
        }

        if(icheck ==1 ){
         if((2*nword) == (64*timesize*3)){
          for (i=0; i<64; i++){
           k=i*(timesize*3);
           ij= i*256;
           if(read_array_s[k] != (0x4000+i))
            printf(" first word error, event %d data received %x, data expected %x\n", is, read_array_s[k], (0x4000+i));
           for (ik=0; ik< ((3*timesize)-2); ik++) {
            if(read_array_s[k+1+ik] != send_array[ij+ik])
             printf(" data word error, event %d ch = %d, received %x, expected %x\n",is,i,read_array_s[k+1+ik], send_array[ij+ik]);
           }
           k=(i+1)*(timesize*3)-1;
           if(read_array_s[k] != (0x5000+i))
            printf(" last word error, event %d data received %x, data expected %x\n", is, read_array_s[k], (0x5000+i));
          }
         }
         else {
          printf(" event %d number word receive = %d, expected=  %d \n", is, (2*nword), (64*timesize*3));
         }
        }
        if(icheck ==1) {
          k = is%1000;
          if(k ==0) printf("event %d\n",is);
        }
        if(iprint == 1) scanf("%d",&ik);

       }
      }

      imod=0;
      ichip=1;
      buf_send[0]=(imod<<11)+(ichip<<8)+(mb_cntrl_set_run_off)+(0x0<<16); //enable offline run off
      i=1;
      k=1;
      i = pcie_send(hDev, i, k, px);
      scanf("%d",&ik);
     }

     break;
     

    case 27:
     printf(" trigger borad test \n");
     printf(" enable number of loop\n");
     scanf("%d",&nloop);
//     printf(" 1 for checking the event \n");
//     scanf("%d",&icheck);
//     printf(" type 1 to use random number \n");
//     scanf("%d",&irand);
     icheck =0;
     irand = 0;
     islow_read =0;
//     if(icheck != 1) {
//      printf(" 1 for print event\n");
//      scanf("%d",&iprint);
//     }
//     else iprint =0;
//     iprint = 1;
//     printf(" number event \n");
//     scanf("%d",&nevent);

//     printf(" enter number of words per packet \n");
//     scanf("%d",&nsend);
     nsend=500;
     imod_trig=18;
     printf("trigger module address %d\n", imod_trig);

     px = &buf_send;
     py = &read_array;
//
//   controller
//
     imod =0;  /* controller module */
/** initialize **/
     buf_send[0]=0x0;
     buf_send[1]=0x0;
     i=1;
     k=1;
     i = pcie_send(hDev, i, k, px);

     imod=imod_trig;
     buf_send[0]=(imod<<11)+(mb_trig_deadtime_size)+((0x1)<<16); //set trigger deadtime size
     i=1;
     k=1;
     i = pcie_send(hDev, i, k, px);

//    for (j=1; j<nloop; j++) {
     imod=imod_trig;
     iframe= 255;    //1023
     buf_send[0]=(imod<<11)+(mb_trig_frame_size)+((iframe & 0xffff)<<16); //set up frame size.
     i=1;
     k=1;
     i = pcie_send(hDev, i, k, px);

     usleep(5000);
     imod=imod_trig;
//     buf_send[0]=(imod<<11)+(mb_trig_mask8)+((0x2 & 0xffff)<<16); // enable external trigger mask
     buf_send[0]=(imod<<11)+(mb_trig_mask8)+((0x4a & 0xffff)<<16); // enable external trigger mask
     i=1;
     k=1;
     i = pcie_send(hDev, i, k, px);

     usleep(5000);
     imod=imod_trig;         //fack module
     buf_send[0]=(imod<<11)+(mb_trig_prescale8)+((0x0 & 0xffff)<<16); // set prescale for mask 8
     i=1;
     k=1;
     i = pcie_send(hDev, i, k, px);


//     }


     imod=imod_trig;
     buf_send[0]=(imod<<11)+(mb_trig_run)+((0x1)<<16); //set up run
     i=1;
     k=1;
     i = pcie_send(hDev, i, k, px);

      printf(" set up to run \n");
      scanf("%d",&ik);

     imod=imod_trig;
     buf_send[0]=(imod<<11)+(mb_trig_calib_delay)+((0x10)<<16); //set up calibration delay to 0x20
     i=1;
     k=1;
     i = pcie_send(hDev, i, k, px);

     for (j=1; j<nloop; j++) {
      imod=imod_trig;
      if(j==2) printf("enter calibration test loop\n");
      buf_send[0]=(imod<<11)+(mb_trig_calib)+((0x0)<<16); //fire up calibration pulse
      i=1;
      k=1;
      i = pcie_send(hDev, i, k, px);
      usleep(5000);
     }


     for (j=1; j<nloop; j++) {

      iprint=1;
      nread = 5;
      i = pcie_rec_2(hDev,0,1,nread,iprint,py);     // init the receiver

      imod =imod_trig;  /* trigger module */
      buf_send[0]=(imod<<11)+mb_trig_pctrig+((0x0)<<16);
      i=1;
      k=1;
      i = pcie_send(hDev, i, k, px);
      usleep(1000);

      printf(" enter 1 to read system status \n");
      scanf("%d",&ik);

      nword = 7;

      i = pcie_rec(hDev,0,1,nword,iprint,py);     // init the receiver


      scanf("%d",&ik);

      imod=imod_trig;
      ichip=3;   // don't care about ichip #
      buf_send[0]=(imod<<11)+(ichip<<8)+mb_trig_rd_param+(0x0<<16);  // read out status
      i=1;
      k=1;
      i = pcie_send(hDev, i, k, px);
      py = &read_array;
      i = pcie_rec(hDev,0,2,nword,iprint,py);     // read out 2 32 bits words
      printf("receive data word = %x, %x, %x, %x \n", read_array[0], read_array[1],read_array[2], read_array[3]);
      printf("receive data word = %x, %x, %x\n", read_array[4], read_array[5],read_array[6]);
//
//
//
      py = &read_array;
      i = pcie_rec_2(hDev,0,2,nread,iprint,py);     // read out 2 32 bits words
      printf("optical receive data word = %x, %x, %x\n", read_array[0], read_array[1],read_array[2]);

      scanf("%d",&ik);

     }

     break;
     
     


    case 28:
     printf(" feb boot test \n");
     printf(" enable number of loop\n");
     scanf("%d",&nloop);
     printf(" enter module number \n");
     scanf("%d",&imod_fem);
//     printf(" frame length \n");
//     scanf("%d",&iframe_length);
     iframe_length =8192;
     ik=iframe_length%64;
     if(ik != 0) printf(" frame_length problem \n");

//     printf(" drift time (< %d) \n", iframe_length/8);
//     scanf("%d",&idrift_time);
     idrift_time =10;
     printf(" enter triger delay \n");
     scanf("%d",&itrig_delay);
//     printf("number of triggers per loop \n");
//     scanf("%d",&itrig);
     itrig =1;
     printf(" 1 for checking the event \n");
     scanf("%d",&icheck);
     printf(" type 1 to use random number \n");
     scanf("%d",&irand);
//     icheck=0;
//     irand=0;
     if(icheck != 1) {
      printf(" 1 for print event\n");
      scanf("%d",&iprint);
     }
     else iprint =0;
     printf(" number event \n");
     scanf("%d",&nevent);

//     printf(" enter number of words per packet \n");
//     scanf("%d",&nsend);
     nsend=500;

     px = &buf_send;
     py = &read_array;
     imod =0;  /* controller module */
/** initialize **/
     buf_send[0]=0x0;
     buf_send[1]=0x0;
     i=1;
     k=1;
     i = pcie_send(hDev, i, k, px);
// set offline test
     imod=0;
     ichip=1;
     buf_send[0]=(imod<<11)+(ichip<<8)+(mb_cntrl_test_on)+(0x0<<16); //enable offline run on
     i=1;
     k=1;
     i = pcie_send(hDev, i, k, px);
 //disable the run command
     imod=0;
     ichip=1;
     buf_send[0]=(imod<<11)+(ichip<<8)+(mb_cntrl_set_run_off)+(0x0<<16); //enable offline run on
     i=1;
     k=1;
     i = pcie_send(hDev, i, k, px);
 // turn on the Stratix III power supply
     imod=imod_fem;
     ichip =1;
     buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_power_add+(0x0<<16); //turn module 11 power on
     i=1;
     k=1;
     i = pcie_send(hDev, i, k, px);
     usleep(200000);  // wait for 200 ms
//     printf(" enable number of loop\n");
//     scanf("%d",&nloop);
     for ( j=0; j<nloop; j++) {
      usleep(10000); // wait for 10ms
      inpf = fopen("/home/ub/feb_fpga_test","r");
      imod=imod_fem;
      ichip=mb_feb_conf_add;
      buf_send[0]=(imod<<11)+(ichip<<8)+0x0+(0x0<<16);  // turn conf to be on
      i=1;
      k=1;
      i = pcie_send(hDev, i, k, px);
//      for (i=0; i<100000; i++) {
//          ik= i%2;
//          dummy1= (ik+i)*(ik+i);
//      }


        /* read data as characters (28941) */
      usleep(1000);   // wait fior a while
      count = 0;
      counta= 0;
      ichip_c = 7; // set ichip_c to stay away from any other command in the
      dummy1 =0;
      while (fread(&charchannel,sizeof(char),1,inpf)==1) {
       carray[count] = charchannel;
       count++;
       counta++;
       if((count%(nsend*2)) == 0) {
//        printf(" loop = %d\n",dummy1);
        buf_send[0] = (imod <<11) +(ichip_c <<8)+ (carray[0]<<16);
        send_array[0] =buf_send[0];
        if(dummy1 <= 5 ) printf(" counta = %d, first word = %x, %x, %x %x %x \n",counta,buf_send[0], carray[0], carray[1]
        ,carray[2], carray[3]);
        for (ij=0; ij< nsend; ij++) {
         if(ij== (nsend-1)) buf_send[ij+1] = carray[2*ij+1]+(0x0<<16);
         else buf_send[ij+1] = carray[2*ij+1]+ (carray[2*ij+2]<<16);
//         buf_send[ij+1] = carray[2*ij+1]+ (carray[2*ij+2]<<16);
         send_array[ij+1] = buf_send[ij+1];
        }
        nword =nsend+1;
        i=1;
//       if(dummy1 == 0)
        ij = pcie_send(hDev, i, nword, px);
        nanosleep(&tim , &tim2);
        dummy1 = dummy1+1;
        count =0;
       }
      }
      if(feof(inpf)) {
       printf("You have reached the end-of-file word count= %d %d\n", counta, count);
       buf_send[0] = (imod <<11) +(ichip_c <<8)+ (carray[0]<<16);
       if ( count > 1) {
        if( ((count-1)%2) ==0) {
         ik =(count-1)/2;
        }
        else {
         ik =(count-1)/2+1;
        }
        ik=ik+2;   // add one more for safety
        printf("ik= %d\n",ik);
        for (ij=0; ij<ik; ij++){
         if(ij == (ik-1)) buf_send[ij+1] = carray[(2*ij)+1]+(((imod<<11)+(ichip<<8)+0x0)<<16);
         else buf_send[ij+1] = carray[(2*ij)+1]+ (carray[(2*ij)+2]<<16);
         send_array[ij+1] = buf_send[ij+1];
        }
       }
       else ik=1;

           for (ij=ik-10; ij< ik+1; ij++) {
            printf("Last data = %d, %x\n",ij,buf_send[ij]);
           }

       nword =ik+1;
       i=1;
       i = pcie_send(hDev, i, nword, px);
       usleep(2000);    // wait for 2ms to cover the packet time plus fpga init time
       fclose(inpf);
       printf(" enter 1 to reset the dram \n");
       scanf("%d",&ik);
 //      ik =1;
       if(ik ==1) {
         imod=imod_fem;
         ichip=3;
         buf_send[0]=(imod<<11)+(ichip<<8)+31+(0x1<<16);  // turm the DRAM reset on
         i=1;
         k=1;
         i = pcie_send(hDev, i, k, px);
         imod=imod_fem;
         ichip=3;
         buf_send[0]=(imod<<11)+(ichip<<8)+31+(0x0<<16);  // turm the DRAM reset off
         i=1;
         k=1;
         i = pcie_send(hDev, i, k, px);

         usleep(5000);    // wait for 5 ms for DRAM to be initialized

         imod=imod_fem;
         ichip=3;
         buf_send[0]=(imod<<11)+(ichip<<8)+6+(imod<<16);  // set module number
         i=1;
         k=1;
         i = pcie_send(hDev, i, k, px);


       }
//       printf(" enter 1 to read system status \n");
//       scanf("%d",&ik);
       ik=1;
       nword =1;
       if(ik ==1) {


         i = pcie_rec(hDev,0,1,nword,iprint,py);     // init the receiver

         imod=imod_fem;
         ichip=3;
         buf_send[0]=(imod<<11)+(ichip<<8)+20+(0x0<<16);  // read out status
         i=1;
         k=1;
         i = pcie_send(hDev, i, k, px);
         py = &read_array;
         i = pcie_rec(hDev,0,2,nword,iprint,py);     // read out 2 32 bits words
         printf("receive data word = %x, %x \n", read_array[0], read_array[1]);
       }
//       printf(" enter L1 trigger delay \n");
//       scanf("%d",&itrig_delay);
//       itrig_delay = 51;
       nword =1;
//
// set to use test generator 2, set test =2
//
       imod=imod_fem;
       ichip=mb_feb_pass_add;
       buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_test_source+(0x2<<16);  // set test source to 2
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);
//
// set frame set to be 1023 --- there will be 1024/8 = 128 adc samples.
//
       imod=0;
       ichip=1;
//       iframe= 255;    //1023
       iframe = iframe_length-1;
       buf_send[0]=(imod<<11)+(ichip<<8)+(mb_cntrl_load_frame)+((iframe & 0xffff)<<16); //enable test mode
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);


//
// load trig 1 position relative to the frame..
//
       imod=0;
       ichip=1;
       buf_send[0]=(imod<<11)+(ichip<<8)+(mb_cntrl_load_trig_pos)+((itrig_delay & 0xffff)<<16); //enable test mode
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);
//
//    start loading the test 2 data memory
//
       imod =imod_fem;
       ichip=3;
       for (is=0; is<64; is++) {
        ik = 0x4000+is;                        // load channel address
        buf_send[0]=(imod<<11)+(ichip<<8)+(mb_feb_test_ram_data)+((ik & 0xffff)<<16); //enable test mode
        i = pcie_send(hDev, 1, 1, px);
        ibase = 32*is;
        il = is%8;
        if(il == 0) printf(" loading channel %d\n",is);
        for (ik=0; ik< 256; ik++) {                 // loop over all possible address
         if(irand ==1) ijk = rand() & 0xfff ;        // use random number
         else ijk= (ibase+ik*8) & 0xfff;
         k = 0x8000+ ijk;        // make sure bit 15-12 is clear for the data
         buf_send[0]=(imod<<11)+(ichip<<8)+(mb_feb_test_ram_data)+((k & 0xffff)<<16); //enable test mode
         i = pcie_send(hDev, 1, 1, px);
         send_array[is*256+ik]=ijk;           //load up data map
        }
       }

       imod=imod_fem;
       ichip=3;
       buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_a_nocomp+(0x1<<16);  // set a channel no compression
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);

//       timesize =4;
       timesize = idrift_time;
       imod=imod_fem;
       ichip=3;
       buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_timesize+(timesize<<16);  // set drift time size
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);

       a_id =0x20;
       imod=imod_fem;
       ichip=3;
       buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_a_id+(a_id<<16);  // set a_id
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);


       imod=imod_fem;
       ichip=3;
       buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_a_test+(0x1<<16);    // enable a test on
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);

       imod=0;
       ichip=1;
       buf_send[0]=(imod<<11)+(ichip<<8)+(mb_cntrl_set_run_on)+(0x0<<16); //enable offline run on
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);

       usleep(5000); //wait for 5 ms
       scanf("%d",&ik);


       for (is=0; is<nevent; is++) {


//
//     send out multiple triggers
//
        for (ijtrig=0; ijtrig<itrig; ijtrig++) {
         printf(" itrig %d, itrig_delay %d\n", ijtrig,itrig_delay);
         imod=0;
         ichip=1;
         buf_send[0]=(imod<<11)+(ichip<<8)+mb_cntrl_set_trig1+(0x0<<16);  // send trigger
         i=1;
         k=1;
         i = pcie_send(hDev, i, k, px);
         usleep(10000);  //put some space between triggers
//
// load trig 1 position relative to the frame..
//
         itrig_delay = itrig_delay+2;
         imod=0;
         ichip=1;
         buf_send[0]=(imod<<11)+(ichip<<8)+(mb_cntrl_load_trig_pos)+((itrig_delay & 0xffff)<<16); //enable test mode
         i=1;
         k=1;
         i = pcie_send(hDev, i, k, px);
         scanf("%d",&ik);

         usleep(10000);

        }



//      set module number again to enable the FEB module read back

        imod=imod_fem;
        ichip=3;
        buf_send[0]=(imod<<11)+(ichip<<8)+6+(imod<<16);  // set module number
        i=1;
        k=1;
        i = pcie_send(hDev, i, k, px);

        usleep(5000); // wait for 5 ms

        for (ijtrig=0; ijtrig<itrig; ijtrig++) {
         nword = 5;
         i = pcie_rec(hDev,0,1,nword,iprint,py);     // init the receiver

         imod=imod_fem;
         ichip=3;
         buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_a_rdhed+(0x1<<16);  // read a header
         i=1;
         k=1;
         i = pcie_send(hDev, i, k, px);

         py = &read_array;
         i = pcie_rec(hDev,0,2,nword,iprint,py);     // read out 2 32 bits words

         if(iprint ==1) printf("receive data word = %x, %x, %x, %x, %x\n", read_array[0], read_array[1], read_array[2], read_array[3], read_array[4]);
         if(iprint == 1) {
          printf(" header word %x \n",(read_array[0] & 0xffff));
          k=(read_array[0]>>16) & 0xfff;
          printf(" module adress %d, id number %d\n", (k & 0x1f), ((k>>5) & 0x7f));
          printf(" number of data word to read %d\n", (((read_array[1]>>16) & 0xfff)+((read_array[1] &0xfff) <<12)));
          printf(" event number %d\n", (((read_array[2]>>16) & 0xfff)+((read_array[2] &0xfff) <<12)));
          printf(" frame number %d\n", (((read_array[3]>>16) & 0xfff)+((read_array[3] &0xfff) <<12)));
          printf(" checksum %x\n", (((read_array[4]>>16) & 0xfff)+((read_array[4] &0xfff) <<12)));
         }
         nread = ((read_array[1]>>16) & 0xfff)+((read_array[1] &0xfff) <<12);
         if(iprint ==1 )scanf("%d",&ik);
         nword = (nread+1)/2;                    // short words
         i = pcie_rec(hDev,0,1,nword,iprint,py);     // init the receiver

         imod=imod_fem;
         ichip=mb_feb_pass_add;
         buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_a_rdbuf+(0x0<<16);  // read a header
         i=1;
         k=1;
         i = pcie_send(hDev, i, k, px);

         py = &read_array;
         i = pcie_rec(hDev,0,2,nword,iprint,py);     // read out 2 32 bits words

         if(iprint == 1) {
          for (i=0; i< nword; i++) {
           if((i%8) ==0) printf("%4d",i);
           printf(" %8x",read_array[i]);
           if(((i+1)%8) ==0 ) printf("\n");
          }
         }

         ik=0;
         for (i=0; i< nword; i++) {
          read_array_s[ik] = read_array[i] &0xffff;
          read_array_s[ik+1] = ((read_array[i]>>16) & 0xffff);
          ik=ik+2;
         }

//
//      printout formatted word
//
         if(iprint ==1) {
          iset = 0;
          for(i=0; i< 2*nword; i++) {
           if((read_array_s[i] & 0xf000) == 0x4000) {
            iset=1;
            ncount=0;
            printf(" channel %d\n",(read_array_s[i] & 0xfff));
           }
           else if ((read_array_s[i] & 0xf000) == 0x5000) printf(" channel end %d\n",(read_array_s[i] &0xfff));
           else if (iset ==1) {
            printf(" %4x",read_array_s[i]);
            ncount = ncount+1;
            if((ncount%8) == 0) printf("\n");
           }
           else {
            printf("%x",read_array_s[i]);
            ncount = ncount+1;
            if((ncount%8) == 0) printf("\n");
           }
          }
         }

         if(icheck ==1 ){
          if((2*nword) == (64*timesize*3)){
           for (i=0; i<64; i++){
            k=i*(timesize*3);
            ij= i*256;
            if(read_array_s[k] != (0x4000+i))
             printf(" first word error, event %d data received %x, data expected %x\n", is, read_array_s[k], (0x4000+i));
            for (ik=0; ik< ((3*timesize)-2); ik++) {
             if(read_array_s[k+1+ik] != send_array[ij+ik])
              printf(" data word error, event %d ch = %d, received %x, expected %x\n",is,i,read_array_s[k+1+ik], send_array[ij+ik]);
            }
            k=(i+1)*(timesize*3)-1;
            if(read_array_s[k] != (0x5000+i))
             printf(" last word error, event %d data received %x, data expected %x\n", is, read_array_s[k], (0x5000+i));
           }
          }
          else {
           printf(" event %d number word receive = %d, expected=  %d \n", is, (2*nword), (64*timesize*3));
          }
         }
        }
        if(icheck ==1) {
          k = is%1000;
          if(k ==0) printf("event %d\n",is);
        }
        if(iprint == 1) scanf("%d",&ik);
       }

       imod=0;
       ichip=1;
       buf_send[0]=(imod<<11)+(ichip<<8)+(mb_cntrl_set_run_off)+(0x0<<16); //enable offline run off
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);
       scanf("%d",&ik);
      }





     }

     break;




     }

}





/* -----------------------------------------------
    Read/write memory and I/O addresses -- TEST
   ----------------------------------------------- */
/* Read/write memory or I/O space address menu options */
static void Menujsebii_test(WDC_DEVICE_HANDLE hDev)
{
/*  pci express bar setting
bar 0,1 is for transceiver 1
bar 2,3 is for command
bar 4,5 is for transceiver 2
*/

#include "wdc_defs.h"

#define  t1_tr_bar 0
#define  t2_tr_bar 4
#define  cs_bar 2

/**  command register location **/
/** GKQ: are these specific to a pcie? **/

#define  tx_mode_reg 0x28
#define  t1_cs_reg 0x18
#define  r1_cs_reg 0x1c
#define  t2_cs_reg 0x20
#define  r2_cs_reg 0x24

#define  tx_md_reg 0x28

#define  cs_dma_add_low_reg 0x0
#define  cs_dma_add_high_reg  0x4
#define  cs_dma_by_cnt 0x8
#define  cs_dma_cntrl 0xc
#define  cs_dma_msi_abort 0x10

/** define status bits **/

#define  cs_init  0x20000000
#define  cs_start 0x40000000
#define  cs_done  0x80000000

#define  dma_tr1  0x100000
#define  dma_tr2  0x200000
#define  dma_tr12 0x300000
#define  dma_3dw_trans 0x0
#define  dma_3dw_rec   0x40
#define  dma_in_progress 0x80000000

#define  dma_abort 0x2

  /** bunch of variable initializations **/
  static DWORD dwAddrSpace;

  static UINT32 u32Data, u32Data_send;
  static unsigned long long u64Data;
  static DWORD dwOffset;
  static unsigned long long buff[10000];
/*    PVOID buff_p; */
  static UINT32 *buffp_send;
  static UINT32 *buffp_rec;
  static UINT64 *buffp_rec64;
/*
    WDC_ADDR_MODE mode;
    WDC_ADDR_RW_OPTIONS options;
*/
  static UINT32 i,j,k,ifr,jk,nwrite,iprint,nread;
  int newcmd,itr,tr_bar,icheck,istop,iloop,t_cs_reg,r_cs_reg;
  int idone,iseq,incomp,dma_tr,isweep,nsize_sw,irand,nwrite_max,nwrite_min;
  int kwrite;
  UINT32 write_array[100000],read_array[100000];
  int n_written;
  DWORD dwDMABufSize;
  PVOID pbuf_send;
  PVOID pbuf_rec;
  WD_DMA *pDma_send;
  WD_DMA *pDma_rec;
  DWORD dwStatus;
  DWORD dwOptions_send = DMA_TO_DEVICE | DMA_ALLOW_CACHE;
  DWORD dwOptions_rec = DMA_FROM_DEVICE | DMA_ALLOW_CACHE;

  iprint =1;
  ifr =0;
  istop =0;
  icheck =1;
  
    /** main menu (options) of routine **/
  printf(" PCIe board testing routing \n");
  printf(" type 1 to use random number \n");
  scanf("%d",&irand);
  printf(" which transceiver to test (1,2 ) \n");
  scanf("%d", &itr);
  printf(" input testing method \n");
  printf(" 1) for slave loop back test \n");
  printf(" 2) DMA loop back test \n");
  //  printf(" 3) combine optical DMA test \n");
  printf(" 3) write-to-file test \n");
  scanf("%d",&newcmd);
  switch(newcmd) {

  case 1:
    if(icheck == 1) printf(" data checking on \n");
    printf("enter number words per packet, -1 for sequence test \n");
    scanf("%d",&kwrite);
    if(kwrite == -1) {
      printf("enter min number of word \n");
      scanf("%d",&nwrite_min);
      printf("enter max number of word \n");
      scanf("%d",&nwrite_max);
      nwrite=nwrite_min;
    }
    else nwrite = kwrite;
    printf("enter number loops \n");
    scanf("%d",&iloop);
    
    tr_bar = t1_tr_bar;
    t_cs_reg = t1_cs_reg;
    r_cs_reg = r1_cs_reg;
    if(itr == 2) {
      tr_bar = t2_tr_bar;
      t_cs_reg = t2_cs_reg;
      r_cs_reg = r2_cs_reg;
    }
    
/* write this will abort previous DMA */
    dwAddrSpace =2;
    dwOffset = cs_dma_msi_abort;
    u32Data = dma_abort;
    WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);

/* clear DMA register after the abort */
    dwAddrSpace =2;
    dwOffset = cs_dma_msi_abort;
    u32Data = 0;
    WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);


      /** begin timer **/
    struct timeval starttest1, endtest1;
    gettimeofday(&starttest1,NULL);
    long mytime1, seconds1, useconds1;
    seconds1 = starttest1.tv_sec;
    useconds1 = starttest1.tv_usec;
      
    printf("\n\nStart time of test: %ld sec %ld usec\n",seconds1,useconds1);
      //get a fresh timestamp
    gettimeofday(&starttest1,NULL);


    for (j=0; j<iloop; j++) {
	//GSK
	//       printf("started loop = %d \n",j);
/* set tx mode register */
      u32Data = 0xf0000fff;
      dwOffset = tx_md_reg;
      dwAddrSpace =cs_bar;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
/** initialize the tranmission ***/
      u32Data = cs_init;
      dwOffset = t_cs_reg;
      dwAddrSpace =cs_bar;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
/** start the tranmitter **/
      dwAddrSpace = cs_bar;
      u32Data = cs_start+nwrite*4;   /* 32 bits mode == 4 bytes per word **/
      dwOffset = t_cs_reg;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
       //GSK
       //       if(iprint == 1 && j < 2) printf(" set up transmitter \n");

/** initialize the receiver ***/
      u32Data = cs_init;
      dwOffset = r_cs_reg;
      dwAddrSpace =cs_bar;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
      /** start the receiver **/
      dwAddrSpace = cs_bar;
      u32Data = cs_start+nwrite*4;   /* 32 bits mode == 4 bytes per word **/
      dwOffset = r_cs_reg;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
       //GSK
       //       if (iprint ==1 && j < 2) printf(" set up receiver \n");

       //GSK
       //       if(icheck == 1) {
       //         dwAddrSpace =cs_bar;
       //         u64Data =0;
       //         dwOffset = t_cs_reg;
       //         WDC_ReadAddr64(hDev, dwAddrSpace, dwOffset, &u64Data);
       //         if(iprint==1 && j < 2) {
       //          u32Data=u64Data;
       //          printf (" transmitter status before send  = %8X \n",u32Data);
       //          u32Data=u64Data>>32;
       //          printf (" receiver status before send  = %8X \n",u32Data);
       //         }
       //       }

       //GSK
      u32Data = 0x22211; 

      for (i=0; i< nwrite; i++) {
        dwAddrSpace = tr_bar;
	//GSK
	//        if(irand == 1) u32Data=rand();
	//        else u32Data = i;
/*        if(i%2 == 0) u32Data =~i;   */
        dwOffset = 0;
	//GSK
	//        write_array[i]=u32Data;
        WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
      }

       //GSK
       //       if(icheck ==1 ) {
       //        dwAddrSpace =cs_bar;
       //        u64Data =0;
       //        dwOffset = t_cs_reg;
       //        WDC_ReadAddr64(hDev, dwAddrSpace, dwOffset, &u64Data);
       //        if(iprint==1 && j < 2) {
       //         u32Data=u64Data;
       //         printf (" transmitter status after send  = %8X \n",u32Data);
       //         u32Data=u64Data>>32;
       //         printf (" receiver status after send  = %8X \n",u32Data);
       //        }
       //       }
       //       nread = nwrite/2;
       //       if(nwrite%2 !=0) nread= nwrite/2 +1;
       //       for (i=0; i< nread; i++) {
       //        dwAddrSpace = tr_bar;
       //        u32Data = 0;
       //        dwOffset = 0;
       //        WDC_ReadAddr64(hDev, dwAddrSpace, dwOffset, &u64Data);
       //        read_array[i*2] = u64Data;
       //        read_array[i*2+1] =u64Data>>32;
       //       }
       //       if(icheck == 1) {
       //        dwAddrSpace =cs_bar;
       //        u64Data =0;
       //        dwOffset = t_cs_reg;
       //        WDC_ReadAddr64(hDev, dwAddrSpace, dwOffset, &u64Data);
       //        if(iprint==1 && j < 2) {
       //         u32Data=u64Data;
       //         printf (" transmitter status after read  = %8X \n",u32Data);
       //         u32Data=u64Data>>32;
       //         printf (" receiver status after read  = %8X \n",u32Data);
       //        }
       //        for (i=0; i< nwrite; i++) {
       //           if(iprint == 1 && j < 2) {
       //             if(i%8 ==0) printf("%d",i);
       //             printf("%9X",read_array[i]);
       //             if((i+1)%8 ==0) printf("\n");
       //           }
       //           if(read_array[i] != write_array[i]) printf("data mismatch, loop = %d word =%d read= %9X write = %9X\n",j,i,read_array[i],write_array[i]);
       //        }
       //        if((iprint ==1) && (nwrite%8 !=0) && j < 2) printf("\n");
       //       }
       //       if(j%100 ==0) printf(" loop = %d, nwrite= %d \n",j, nwrite);
       //       if(kwrite == -1) {
       //         nwrite =nwrite+1;
       //         if(nwrite > nwrite_max) nwrite =nwrite_min;
       //       }
    }

     /** end timer **/
    gettimeofday(&endtest1,NULL);
    seconds1 = endtest1.tv_sec;
    useconds1 = endtest1.tv_usec;
    
    printf("\nEnd time of test:   %ld sec %ld usec\n",seconds1,useconds1);

    seconds1 = endtest1.tv_sec - starttest1.tv_sec;
    useconds1 = endtest1.tv_usec - starttest1.tv_usec;
    
    mytime1 = seconds1*1000000. + useconds1*1.; //elapsed time in usec

    printf("\nElapsed time:\t\t\t %ld usec\n\n", mytime1);

    break;

  case 2:
    icheck=0;
    iprint=0;
    if(icheck == 1) printf(" data checking on \n");
    printf(" enter number of 32bits word send (< 20000), -1 for sequence test\n");
    scanf("%d",&kwrite);
    if(kwrite == -1) {
      printf("enter min number of word \n");
      scanf("%d",&nwrite_min);
      printf("enter max number of word \n");
      scanf("%d",&nwrite_max);
      nwrite=nwrite_min;
    }
    else nwrite = kwrite;

    printf("enter number loops \n");
    scanf("%d",&iloop);
    
    printf(" DMA sequence -> 1 for DMA read after DMA write \n");
    printf("                 2 for Open DMA read and slave write \n");
    scanf("%d",&iseq);
    printf(" type 1 for incomplete DMA test \n");
    scanf("%d",&incomp);
    

/*** allocate the DMA buffer for send and receive **/
    dwDMABufSize = 80000;
    if(ifr ==0) {
      ifr=1;
      dwStatus = WDC_DMAContigBufLock(hDev, &pbuf_send, dwOptions_send, dwDMABufSize, &pDma_send);
      if (WD_STATUS_SUCCESS != dwStatus) {
	printf("Failed locking a send Contiguous DMA buffer. Error 0x%lx - %s\n", dwStatus, Stat2Str(dwStatus));
      }
      dwStatus = WDC_DMAContigBufLock(hDev, &pbuf_rec, dwOptions_rec, dwDMABufSize, &pDma_rec);
      if (WD_STATUS_SUCCESS != dwStatus) {
	printf("Failed locking a rec Contiguous DMA buffer. Error 0x%lx - %s\n", dwStatus, Stat2Str(dwStatus));
      }
    }
    tr_bar = t1_tr_bar;
    t_cs_reg = t1_cs_reg;
    r_cs_reg = r1_cs_reg;
    dma_tr = dma_tr1;
    if(itr == 2) {
      tr_bar = t2_tr_bar;
      t_cs_reg = t2_cs_reg;
      r_cs_reg = r2_cs_reg;
      dma_tr = dma_tr2;
    }

/* write this will abort previous DMA */
    dwAddrSpace =2;
    dwOffset = cs_dma_msi_abort;
    u32Data = dma_abort;
    WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
       /* clear DMA register after the abort */
    dwAddrSpace =2;
    dwOffset = cs_dma_msi_abort;
    u32Data = 0;
    WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);


       
       //GSK
       //rand() generation outside loop, for speed test

    buffp_send = pbuf_send;
    buffp_rec = pbuf_rec;
    //	 printf("%llX\n",buffp_send);
    //this is not actually necessary:
    int ig;
    for (ig=0; ig<nwrite; ig++) {
      if(irand == 1) *buffp_send++=rand();
      else *buffp_send++= ig;
      *buffp_rec++ =0x0;
    }
    //    }
    printf("\nGenerated data (words) for loop-back test\n");
    for (i=0; i<nwrite; i++) {
      k = i%8;
      if( k ==0) printf(" %3d", i);
      u32Data = *buffp_send++;
      printf(" %llX",u32Data);
      if(k == 7 ) printf("\n");
    }
    printf("\n");
    for (i=0; i<nwrite; i++) {
      k = i%8;
      if( k ==0) printf(" %3d", i);
      u32Data = *buffp_rec++;
      printf(" %llX",u32Data);
      if(k == 7 ) printf("\n");
    }


      /** begin timer **/
    struct timeval starttest, endtest;
    gettimeofday(&starttest,NULL);
    long mytime, seconds, useconds;
    seconds = starttest.tv_sec;
    useconds = starttest.tv_usec;
      
    printf("\n\nStart time of test: %ld sec %ld usec\n",seconds,useconds);
      //get a fresh timestamp
    gettimeofday(&starttest,NULL);


    for (j=0; j<iloop; j++) {
/* set tx mode register */
      u32Data = 0xf0000008;
      dwOffset = tx_md_reg;
      dwAddrSpace =cs_bar;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
      /** initialize the tranmission ***/
      u32Data = cs_init;
      dwOffset = t_cs_reg;
      dwAddrSpace =cs_bar;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
/** start the tranmitter **/
      dwAddrSpace = cs_bar;
      u32Data = cs_start+nwrite*4;   /* 32 bits mode == 4 bytes per word **/
      dwOffset = t_cs_reg;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
       //GSK
       //       if(iprint == 1 && j < 2) printf(" set up transmitter \n");
/** initialize the receiver ***/
      u32Data = cs_init;
      dwOffset = r_cs_reg;
      dwAddrSpace =cs_bar;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
/** start the receiver **/
      dwAddrSpace = cs_bar;
      u32Data = cs_start+nwrite*4;   /* 32 bits mode == 4 bytes per word **/
      //GSK
       //       if(incomp ==1) u32Data = cs_start+nwrite*4+16; /* set up 4 less words to receive */
      dwOffset = r_cs_reg;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
       //GSK
       //       if(iprint == 1 && j < 2) printf(" set up receiver \n");
       //       if(icheck == 1) {
       //         dwAddrSpace =cs_bar;
       //         u64Data =0;
       //         dwOffset = t_cs_reg;
       //         WDC_ReadAddr64(hDev, dwAddrSpace, dwOffset, &u64Data);
       //	 if(iprint==1 && j < 2) {
       //	   u32Data=u64Data;
       //	   printf (" transmitter status before send  = %8X \n",u32Data);
       //	   u32Data=u64Data>>32;
       //	   printf (" receiver status before send  = %8X \n",u32Data);
       //	 }
       //       }

      buffp_send = pbuf_send;
      buffp_rec = pbuf_rec;

       //GSK
       //do rand() generation outside the loop, and fill array(s) ahead of time
       //       for (i=0; i<nwrite+100; i++) {
       //	 if(irand == 1) *buffp_send++=rand();
       //	 else *buffp_send++= i;
       //	 *buffp_rec++ =0;
       //       }

/*
       buffp_rec = pbuf_rec;
       buffp_send = pbuf_send;

       for (i=0; i<nwrite; i++) {
	  k = i%8;
	  if(iprint ==1 && k ==0) printf(" %3d", i);
	  u32Data = *buffp_send++;
          if(iprint==1) printf(" %llX",u32Data);
	  if(k == 7 && iprint == 1) printf("\n");
       }
*/

//GSK iseq==1 by definition for this test
//       if(iseq == 1) {
/* set up transmitter DMA starting address */
      dwAddrSpace =cs_bar;
      dwOffset = cs_dma_add_low_reg;
      u32Data = pDma_send->Page->pPhysicalAddr & 0xffffffff;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
      
      dwAddrSpace =cs_bar;
      dwOffset = cs_dma_add_high_reg;
      u32Data = (pDma_send->Page->pPhysicalAddr >> 32) & 0xffffffff;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);

/* byte count */
      dwAddrSpace =cs_bar;
      dwOffset = cs_dma_by_cnt;
      u32Data = nwrite*4;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);

	/* synch cache */
      WDC_DMASyncCpu(pDma_send);

/* write this will start DMA */
      dwAddrSpace =cs_bar;
      dwOffset = cs_dma_cntrl;
      u32Data = dma_tr+dma_3dw_trans;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);

/***    check to see if DMA is done or not **/
      idone =0;
      for (i=0; i<200; i++) {;
	dwAddrSpace =cs_bar;
	u64Data =0;
	dwOffset = cs_dma_cntrl;
	WDC_ReadAddr32(hDev, dwAddrSpace, dwOffset, &u32Data);
	  //GSK
	  //	  if(iprint ==1 && j < 2) printf(" send DMA status word %d %X \n", i, u32Data);
	if((u32Data & dma_in_progress) == 0) {
	    //GSK
	    //	    if(iprint == 1 && j < 2) printf(" send DMA complete %d \n", i);
	  idone =1;
	}
	if((u32Data & dma_in_progress) == 0) break;
      }
      if(idone == 0) {
	  //gsk
	  //	  printf(" sending dma is not finished \n");
	  //	  printf(" send DMA status word %d %X \n", i, u32Data);
	break;
      }
	//GSK
	//        if(icheck == 1) {
	//         dwAddrSpace =cs_bar;
	//         u64Data =0;
	//         dwOffset = t_cs_reg;
	//         WDC_ReadAddr64(hDev, dwAddrSpace, dwOffset, &u64Data);
	//	 if(iprint==1 && j < 2) {
	//	   u32Data=u64Data;
	//	   printf (" transmitter status after send  = %8X \n",u32Data);
	//	   u32Data=u64Data>>32;
	//	   printf (" receiver status after send  = %8X \n",u32Data);
	//	 }
	//        }
	//GSK end if iseq==1
	//       }

 	/* synch DMA i/O cache **/
      WDC_DMASyncIo(pDma_send);

	//GSK iseq==1 for this test
	//       if (iseq != 1) {
	///** now write data to the transmiiter */
//        buffp_send = pbuf_send;
//        for (i=0; i< nwrite; i++) {
//         dwAddrSpace = tr_bar;
//         u32Data = *buffp_send++;
//         dwOffset = 0;
//         WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
//        }
//       }


 /** set up the receiver DMA and first  **/

      dwAddrSpace =cs_bar;
      dwOffset = cs_dma_add_low_reg;
      u32Data = pDma_rec->Page->pPhysicalAddr & 0xffffffff;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);

      dwAddrSpace =cs_bar;
      dwOffset = cs_dma_add_high_reg;
      u32Data = (pDma_rec->Page->pPhysicalAddr >> 32) & 0xffffffff;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);

/* byte count */
      dwAddrSpace =cs_bar;
      dwOffset = cs_dma_by_cnt;
      u32Data = nwrite*4;
      if(incomp ==1) u32Data = cs_start+nwrite*4+16; /* set up 4 more words to receive */
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);

/* write this will start DMA */
      dwAddrSpace =2;
      dwOffset = cs_dma_cntrl;
      u32Data = dma_tr+dma_3dw_rec;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);

	/* synch cache */
      WDC_DMASyncCpu(pDma_rec);



/***    check to see if DMA is done or not **/
      idone =0;
      for (i=0; i<200; i++) {;
	dwAddrSpace =cs_bar;
	u64Data =0;
	dwOffset = cs_dma_cntrl;
	WDC_ReadAddr32(hDev, dwAddrSpace, dwOffset, &u32Data);
	//GSK
	//	  if(iprint ==1 && j < 2) printf(" receive DMA status word %d %X \n", i, u32Data);
	if((u32Data & dma_in_progress) == 0) {
	  idone =1;
	  //GSK
	  //	    if(iprint == 1 && j < 2) printf(" receive DMA complete %d \n", i);
	}
	if((u32Data & dma_in_progress) == 0) break;
      }
      /* synch DMA i/O cache **/
      
      WDC_DMASyncIo(pDma_rec);

      if(idone == 0){
	 //gsk
	 //	 printf(" DMA is not done, %d, iloop = %d, nwrite= %d\n",i, j, nwrite);
	 //         if(incomp ==1) {
	 //           u32Data = dma_abort;
	 //           dwOffset = cs_dma_msi_abort;
	 //           dwAddrSpace =cs_bar;
	 //           WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
	 //           u32Data = 0;
	 //           dwOffset = cs_dma_msi_abort;
	 //           dwAddrSpace =cs_bar;
	 //           WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
	 //           dwAddrSpace =cs_bar;
	 //	   dwOffset = cs_dma_cntrl;
	 //           WDC_ReadAddr32(hDev, dwAddrSpace, dwOffset, &u32Data);
	 //	   if(iprint ==1 && j < 2) printf(" receive DMA status word after abort %d %X \n", i, u32Data);
	 //           dwAddrSpace =cs_bar;
	 //           dwOffset = t_cs_reg;
	 //           WDC_ReadAddr64(hDev, dwAddrSpace, dwOffset, &u64Data);
	 //	   if(iprint==1 && j < 2) {
	 //	     u32Data=u64Data;
	 //	     printf (" transmitter status after abort  = %8X \n",u32Data);
	 //	     u32Data=u64Data>>32;
	 //	     printf (" receiver status after abort  = %8X \n",u32Data);
	 //	   }
	 //         }
	 //         else 
	break;
      }

      if(idone == 1) {
	buffp_rec = pbuf_rec;
	buffp_send = pbuf_send;
	
	 //GSK
	 //	 for (i=0; i<nwrite; i++) {
	 //	   k = i%8;
	 //	  if(iprint ==1 && k ==0 && j < 2) printf(" %3d", i);
	 //	  u32Data = *buffp_rec++;
	 //	  u32Data_send = *buffp_send++;
	 //	  if((u32Data != u32Data_send) && (icheck ==1) ) printf(" %d, %d, %11x, %11x\n", j,i,u32Data_send,u32Data);
	 //	  if(iprint==1 && j < 2) printf(" %llX",u32Data);
	 //	  if(k == 7 && iprint == 1 && j < 2) printf("\n");
	 //	 }
	 //	 if(k !=7 && iprint ==1 && j < 2) printf("\n");
      }
       //       if(j%100 ==0) printf(" loop = %d, nwrite= %d \n",j, nwrite);

       //GSK
       //       if(kwrite == -1) {
       //        nwrite =nwrite+1;
       //        if(nwrite > nwrite_max) nwrite =nwrite_min;
       //       }
    }

      /** end timer **/
    gettimeofday(&endtest,NULL);
    seconds = endtest.tv_sec;
    useconds = endtest.tv_usec;
      
    printf("\nEnd time of test:   %ld sec %ld usec\n",seconds,useconds);

    seconds = endtest.tv_sec - starttest.tv_sec;
    useconds = endtest.tv_usec - starttest.tv_usec;

    mytime = seconds*1000000. + useconds*1.; //elapsed time in usec

    printf("\nElapsed time:\t\t\t %ld usec\n\n", mytime);

    break;
    
  case 3:
    printf("enter number words per packet \n");
    scanf("%d",&nwrite);
    printf("enter number loops \n");
    scanf("%d",&iloop);
    
    tr_bar = t1_tr_bar;
    t_cs_reg = t1_cs_reg;
    r_cs_reg = r1_cs_reg;
    if(itr == 2) {
      tr_bar = t2_tr_bar;
      t_cs_reg = t2_cs_reg;
      r_cs_reg = r2_cs_reg;
    }

/* write this will abort previous DMA */
    dwAddrSpace =2;
    dwOffset = cs_dma_msi_abort;
    u32Data = dma_abort;
    WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
/* clear DMA register after the abort */
    dwAddrSpace =2;
    dwOffset = cs_dma_msi_abort;
    u32Data = 0;
    WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);

    printf("\n\nWriting to file: -----------> test.bin\n");

    FILE * pFile;
    pFile = fopen("test.bin","w");
    if (pFile==NULL){
      printf("\nFile NOT open; Exiting.\n");
      break;
    }

    //first write some stuff

/* set tx mode register */
    u32Data = 0xf0000fff;
    dwOffset = tx_md_reg;
    dwAddrSpace =cs_bar;
    WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
/** initialize the tranmission ***/
    u32Data = cs_init;
    dwOffset = t_cs_reg;
    dwAddrSpace =cs_bar;
    WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
/** start the tranmitter **/
    dwAddrSpace = cs_bar;
    u32Data = cs_start+nwrite*4;   /* 32 bits mode == 4 bytes per word **/
    dwOffset = t_cs_reg;
    WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
       //GSK
       //       if(iprint == 1 && j < 2) printf(" set up transmitter \n");
/** initialize the receiver ***/
    u32Data = cs_init;
    dwOffset = r_cs_reg;
    dwAddrSpace =cs_bar;
    WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
      /** start the receiver **/
    dwAddrSpace = cs_bar;
    u32Data = cs_start+nwrite*4;   /* 32 bits mode == 4 bytes per word **/
    dwOffset = r_cs_reg;
    WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);


    //now write to transmitter ---> edit from this point on

    u32Data = 0x3333;
    for (i=0; i< nwrite; i++) {
      dwAddrSpace = tr_bar;
      dwOffset = 0;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
    }


    //receiver read and write to file

    //loop read



      /** begin timer **/
    struct timeval starttest2, endtest2;
    gettimeofday(&starttest2,NULL);
    long mytime2, seconds2, useconds2;
    seconds2 = starttest2.tv_sec;
    useconds2 = starttest2.tv_usec;
      
    printf("\n\nStart time of test: %ld sec %ld usec\n",seconds2,useconds2);
      //get a fresh timestamp
    gettimeofday(&starttest2,NULL);




      /** end timer **/
    gettimeofday(&endtest2,NULL);
    seconds2 = endtest2.tv_sec;
    useconds2 = endtest2.tv_usec;
      
    printf("\nEnd time of test:   %ld sec %ld usec\n",seconds2,useconds2);

    seconds2 = endtest2.tv_sec - starttest2.tv_sec;
    useconds2 = endtest2.tv_usec - starttest2.tv_usec;
      
    mytime2 = seconds2*1000000. + useconds2*1.; //elapsed time in usec

    printf("\nElapsed time:\t\t\t %ld usec\n\n", mytime2);
    

    fclose(pFile);

    break;

  }

}
  


static int pcie_send(WDC_DEVICE_HANDLE hDev, int mode, int nword, UINT32 *buff_send)
{
/* imode =0 single word transfer, imode =1 DMA */
#include "wdc_defs.h"
    static DWORD dwAddrSpace;
    static DWORD dwDMABufSize;

    static UINT32 *buf_send;
    static WD_DMA *pDma_send;
    static DWORD dwStatus;
    static DWORD dwOptions_send = DMA_TO_DEVICE;
    static DWORD dwOffset;
    static UINT32 u32Data;
    static PVOID pbuf_send;
    int nwrite,i,j, iprint;
    static int ifr=0;

    if (ifr == 0) {
      ifr=1;
      dwDMABufSize = 140000;
      dwStatus = WDC_DMAContigBufLock(hDev, &pbuf_send, dwOptions_send, dwDMABufSize, &pDma_send);
      if (WD_STATUS_SUCCESS != dwStatus) {
             printf("Failed locking a send Contiguous DMA buffer. Error 0x%lx - %s\n", dwStatus, Stat2Str(dwStatus));
      }
      buf_send = pbuf_send;
    }
    iprint =0;
    if(mode ==1 ) {
      for (i=0; i< nword; i++) {
        *(buf_send+i) = *buff_send++;
/*	printf("%d \n",*(buf_send+i));   */
      }
    }
    if(mode == 0) {
     nwrite = nword*4;
     /*setup transmiiter */
     dwAddrSpace =2;
     u32Data = 0x20000000;
     dwOffset = 0x18;
     WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
     dwAddrSpace =2;
     u32Data = 0x40000000+nwrite;
     dwOffset = 0x18;
     WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
     for (j=0; j< nword; j++) {
       dwAddrSpace =0;
       dwOffset = 0x0;
       u32Data = *buff_send++;
       WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
     }
     for (i=0; i<20000; i++) {
       dwAddrSpace =2;
       dwOffset = 0xC;
       WDC_ReadAddr32(hDev, dwAddrSpace, dwOffset, &u32Data);
       if(iprint ==1) printf(" status reed %d %X \n", i, u32Data);
       if(((u32Data & 0x80000000) == 0) && iprint == 1) printf(" Data Transfer complete %d \n", i);
       if((u32Data & 0x80000000) == 0) break;
     }
    }
    if( mode ==1 ){
      nwrite = nword*4;
      WDC_DMASyncCpu(pDma_send);
/*
      printf(" nwrite = %d \n", nwrite);
      printf(" pcie_send hDev = %d\n", hDev);
      printf(" buf_send = %X\n",*buf_send);
*/
     /*setup transmiiter */
      dwAddrSpace =2;
      u32Data = 0x20000000;
      dwOffset = 0x18;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
      dwAddrSpace =2;
      u32Data = 0x40000000+nwrite;
      dwOffset = 0x18;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);

/* set up sending DMA starting address */

      dwAddrSpace =2;
      u32Data = 0x20000000;
      dwOffset = 0x0;
      u32Data = pDma_send->Page->pPhysicalAddr & 0xffffffff;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);

      dwAddrSpace =2;
      u32Data = 0x20000000;
      dwOffset = 0x4;
      u32Data = (pDma_send->Page->pPhysicalAddr >> 32) & 0xffffffff;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);

/* byte count */
      dwAddrSpace =2;
      dwOffset = 0x8;
      u32Data = nwrite;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);

/* write this will start DMA */
      dwAddrSpace =2;
      dwOffset = 0xc;
      u32Data = 0x00100000;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);

      for (i=0; i<20000; i++) {
        dwAddrSpace =2;
	dwOffset = 0xC;
        WDC_ReadAddr32(hDev, dwAddrSpace, dwOffset, &u32Data);
	if(iprint ==1) printf(" DMA status reed %d %X \n", i, u32Data);
	if(((u32Data & 0x80000000) == 0) && iprint == 1) printf(" DMA complete %d \n", i);
	if((u32Data & 0x80000000) == 0) break;
      }
      WDC_DMASyncIo(pDma_send);
    }
    return i;
    }

static int pcie_send_1(WDC_DEVICE_HANDLE hDev, int mode, int nword, UINT32 *buff_send)
{
/* imode =0 single word transfer, imode =1 DMA */
#include "wdc_defs.h"
    static DWORD dwAddrSpace;
    static DWORD dwDMABufSize;

    static UINT32 *buf_send;
    static WD_DMA *pDma_send;
    static DWORD dwStatus;
    static DWORD dwOptions_send = DMA_TO_DEVICE;
    static DWORD dwOffset;
    static UINT32 u32Data;
    static PVOID pbuf_send;
    int nwrite,i,j, iprint;
    static int ifr=0;

    if (ifr == 0) {
      ifr=1;
      dwDMABufSize = 140000;
      dwStatus = WDC_DMAContigBufLock(hDev, &pbuf_send, dwOptions_send, dwDMABufSize, &pDma_send);
      if (WD_STATUS_SUCCESS != dwStatus) {
             printf("Failed locking a send Contiguous DMA buffer. Error 0x%lx - %s\n", dwStatus, Stat2Str(dwStatus));
      }
      buf_send = pbuf_send;
    }
    iprint =0;
    if(mode ==1 ) {
      for (i=0; i< nword; i++) {
        *(buf_send+i) = *buff_send++;
/*	printf("%d \n",*(buf_send+i));   */
      }
    }
    if(mode == 0) {
     nwrite = nword*4;
     /*setup transmiiter */
     dwAddrSpace =2;
     u32Data = 0x20000000;
     dwOffset = 0x20;
     WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
     dwAddrSpace =2;
     u32Data = 0x40000000+nwrite;
     dwOffset = 0x20;
     WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
     for (j=0; j< nword; j++) {
       dwAddrSpace =4;
       dwOffset = 0x0;
       u32Data = *buff_send++;
       WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
     }
     for (i=0; i<20000; i++) {
       dwAddrSpace =2;
       dwOffset = 0xC;
       WDC_ReadAddr32(hDev, dwAddrSpace, dwOffset, &u32Data);
       if(iprint ==1) printf(" status reed %d %X \n", i, u32Data);
       if(((u32Data & 0x80000000) == 0) && iprint == 1) printf(" Data Transfer complete %d \n", i);
       if((u32Data & 0x80000000) == 0) break;
     }
    }
    if( mode ==1 ){
      nwrite = nword*4;
      WDC_DMASyncCpu(pDma_send);
/*
      printf(" nwrite = %d \n", nwrite);
      printf(" pcie_send hDev = %d\n", hDev);
      printf(" buf_send = %X\n",*buf_send);
*/
     /*setup transmiiter */
      dwAddrSpace =2;
      u32Data = 0x20000000;
      dwOffset = 0x20;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
      dwAddrSpace =2;
      u32Data = 0x40000000+nwrite;
      dwOffset = 0x20;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);

/* set up sending DMA starting address */

      dwAddrSpace =2;
      u32Data = 0x20000000;
      dwOffset = 0x0;
      u32Data = pDma_send->Page->pPhysicalAddr & 0xffffffff;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);

      dwAddrSpace =2;
      u32Data = 0x20000000;
      dwOffset = 0x4;
      u32Data = (pDma_send->Page->pPhysicalAddr >> 32) & 0xffffffff;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);

/* byte count */
      dwAddrSpace =2;
      dwOffset = 0x8;
      u32Data = nwrite;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);

/* write this will start DMA */
      dwAddrSpace =2;
      dwOffset = 0xc;
      u32Data = 0x00200000;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);

      for (i=0; i<20000; i++) {
        dwAddrSpace =2;
	dwOffset = 0xC;
        WDC_ReadAddr32(hDev, dwAddrSpace, dwOffset, &u32Data);
	if(iprint ==1) printf(" DMA status reed %d %X \n", i, u32Data);
	if(((u32Data & 0x80000000) == 0) && iprint == 1) printf(" DMA complete %d \n", i);
	if((u32Data & 0x80000000) == 0) break;
      }
      WDC_DMASyncIo(pDma_send);
    }
    return i;
    }


 static int pcie_rec(WDC_DEVICE_HANDLE hDev, int mode, int istart, int nword, int ipr_status, UINT32 *buff_rec)
{
/* imode =0 single word transfer, imode =1 DMA */
#include "wdc_defs.h"
    static DWORD dwAddrSpace;
    static DWORD dwDMABufSize;

    static UINT32 *buf_rec;
    static WD_DMA *pDma_rec;
    static DWORD dwStatus;
    static DWORD dwOptions_rec = DMA_FROM_DEVICE;
    static DWORD dwOffset;
    static UINT32 u32Data;
    static UINT64 u64Data;
    static PVOID pbuf_rec;
    int nread,i,j, iprint,icomp;
    static int ifr=0;

    if (ifr == 0) {
      ifr=1;
      dwDMABufSize = 140000;
      dwStatus = WDC_DMAContigBufLock(hDev, &pbuf_rec, dwOptions_rec, dwDMABufSize, &pDma_rec);
      if (WD_STATUS_SUCCESS != dwStatus) {
             printf("Failed locking a send Contiguous DMA buffer. Error 0x%lx - %s\n", dwStatus, Stat2Str(dwStatus));
      }
      buf_rec = pbuf_rec;
    }
    iprint =0;
//    printf(" istart = %d\n", istart);
//   printf(" mode   = %d\n", mode);
/** set up the receiver **/
    if((istart == 1) | (istart == 3)) {
// initalize transmitter mode register...
//     printf(" nword = %d \n",nword);
/*
     if(ipr_status ==1) {
      dwAddrSpace =2;
      u64Data =0;
      dwOffset = 0x18;
      WDC_ReadAddr64(hDev, dwAddrSpace, dwOffset, &u64Data);
      printf (" status word before set = %x, %x \n",(u64Data>>32), (u64Data &0xffff));
     }
*/
     dwAddrSpace =2;
     u32Data = 0xf0000008;
     dwOffset = 0x28;
     WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);

     /*initialize the receiver */
     dwAddrSpace =2;
     u32Data = 0x20000000;
     dwOffset = 0x1c;
     WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
     /* write byte count **/
     dwAddrSpace =2;
     u32Data = 0x40000000+nword*4;
     dwOffset = 0x1c;
     WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
     if(ipr_status ==1) {
      dwAddrSpace =2;
      u64Data =0;
      dwOffset = 0x18;
      WDC_ReadAddr64(hDev, dwAddrSpace, dwOffset, &u64Data);
      printf (" status word before read = %x, %x \n",(u64Data>>32), (u64Data &0xffff));
     }

     return 0;
    }
    if ((istart == 2) | (istart == 3)) {
//     if(ipr_status ==1) {
//      dwAddrSpace =2;
//      u64Data =0;
//      dwOffset = 0x18;
//      WDC_ReadAddr64(hDev, dwAddrSpace, dwOffset, &u64Data);
//      printf (" status word before read = %x, %x \n",(u64Data>>32), (u64Data &0xffff));
//     }
     if(mode == 0) {
      nread = nword/2+1;
      if(nword%2 == 0) nread = nword/2;
      for (j=0; j< nread; j++) {
       dwAddrSpace =0;
       dwOffset = 0x0;
       u64Data =0xbad;
       WDC_ReadAddr64(hDev,dwAddrSpace, dwOffset, &u64Data);
//       printf("u64Data = %16X\n",u64Data);
       *buff_rec++ = (u64Data &0xffffffff);
       *buff_rec++ = u64Data >>32;
//       printf("%x \n",(u64Data &0xffffffff));
//       printf("%x \n",(u64Data >>32 ));
//       if(j*2+1 > nword) *buff_rec++ = (u64Data)>>32;
//       *buff_rec++ = 0x0;
      }
      if(ipr_status ==1) {
       dwAddrSpace =2;
       u64Data =0;
       dwOffset = 0x18;
       WDC_ReadAddr64(hDev, dwAddrSpace, dwOffset, &u64Data);
       printf (" status word after read = %x, %x \n",(u64Data>>32), (u64Data &0xffff));
      }
      return 0;
     }
     if( mode ==1 ){
      nread = nword*4;
      WDC_DMASyncCpu(pDma_rec);
/*
      printf(" nwrite = %d \n", nwrite);
      printf(" pcie_send hDev = %d\n", hDev);
      printf(" buf_send = %X\n",*buf_send);
*/
/*setup receiver
      dwAddrSpace =2;
      u32Data = 0x20000000;
      dwOffset = 0x1c;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
      dwAddrSpace =2;
      u32Data = 0x40000000+nread;
      dwOffset = 0x1c;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
*/
/* set up sending DMA starting address */

      dwAddrSpace =2;
      u32Data = 0x20000000;
      dwOffset = 0x0;
      u32Data = pDma_rec->Page->pPhysicalAddr & 0xffffffff;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);

      dwAddrSpace =2;
      u32Data = 0x20000000;
      dwOffset = 0x4;
      u32Data = (pDma_rec->Page->pPhysicalAddr >> 32) & 0xffffffff;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);

/* byte count */
      dwAddrSpace =2;
      dwOffset = 0x8;
      u32Data = nread;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);

/* write this will start DMA */
      dwAddrSpace =2;
      dwOffset = 0xc;
      u32Data = 0x00100040;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
      icomp=0;
      for (i=0; i<20000; i++) {
        dwAddrSpace =2;
	dwOffset = 0xC;
        WDC_ReadAddr32(hDev, dwAddrSpace, dwOffset, &u32Data);
	if(iprint ==1) printf(" DMA status read %d %X \n", i, u32Data);
	if(((u32Data & 0x80000000) == 0)) {
          icomp=1;
          if(iprint == 1) printf(" DMA complete %d \n", i);
        }
	if((u32Data & 0x80000000) == 0) break;
      }
      if(icomp == 0) {
        printf("DMA timeout\n");
        return 1;
      }
      WDC_DMASyncIo(pDma_rec);
      for (i=0; i< nword; i++) {
        *buff_rec++ = *(buf_rec+i);
/*	printf("%d \n",*(buf_send+i));   */
      }
     }
    }
    return 0;
    }


 static int pcie_rec_2(WDC_DEVICE_HANDLE hDev, int mode, int istart, int nword, int ipr_status, UINT32 *buff_rec)
{
/* imode =0 single word transfer, imode =1 DMA */
/* nword assume to be number of 16 bits word */

#include "wdc_defs.h"
#define  t1_tr_bar 0
#define  t2_tr_bar 4
#define  cs_bar 2

/**  command register location **/

#define  tx_mode_reg 0x28
#define  t1_cs_reg 0x18
#define  r1_cs_reg 0x1c
#define  t2_cs_reg 0x20
#define  r2_cs_reg 0x24

#define  tx_md_reg 0x28

#define  cs_dma_add_low_reg 0x0
#define  cs_dma_add_high_reg  0x4
#define  cs_dma_by_cnt 0x8
#define  cs_dma_cntrl 0xc
#define  cs_dma_msi_abort 0x10

/** define status bits **/

#define  cs_init  0x20000000
#define  cs_mode_p 0x8000000
#define  cs_mode_n 0x0
#define  cs_start 0x40000000
#define  cs_done  0x80000000

#define  dma_tr1  0x100000
#define  dma_tr2  0x200000
#define  dma_tr12 0x300000
#define  dma_3dw_trans 0x0
#define  dma_3dw_rec   0x40
#define  dma_in_progress 0x80000000

#define  dma_abort 0x2

    static DWORD dwAddrSpace;
    static DWORD dwDMABufSize;

    static UINT32 *buf_rec;
    static WD_DMA *pDma_rec;
    static DWORD dwStatus;
    static DWORD dwOptions_rec = DMA_FROM_DEVICE;
    static DWORD dwOffset;
    static UINT32 u32Data;
    static UINT64 u64Data;
    static PVOID pbuf_rec;
    int nread,i,j, iprint,icomp,is;
    static int ifr=0;

    if (ifr == 0) {
      ifr=1;
      dwDMABufSize = 140000;
      dwStatus = WDC_DMAContigBufLock(hDev, &pbuf_rec, dwOptions_rec, dwDMABufSize, &pDma_rec);
      if (WD_STATUS_SUCCESS != dwStatus) {
             printf("Failed locking a send Contiguous DMA buffer. Error 0x%lx - %s\n", dwStatus, Stat2Str(dwStatus));
      }
      buf_rec = pbuf_rec;
    }
    iprint =0;
 //   printf(" istart = %d\n", istart);
 //   printf(" mode   = %d\n", mode);
/** set up the receiver **/
    if((istart == 1) | (istart == 3)) {
// initalize transmitter mode register...
     dwAddrSpace =2;
     u32Data = 0xf0000008;
     dwOffset = tx_mode_reg;
     WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
     if(mode == 1) {
/* write this will abort previous DMA */
       dwAddrSpace =2;
       dwOffset = cs_dma_msi_abort;
       u32Data = dma_abort;
       WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
/* clear DMA register after the abort */
       dwAddrSpace =2;
       dwOffset = cs_dma_msi_abort;
       u32Data = 0;
       WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
     }
     /*initialize the receiver */
     dwAddrSpace =cs_bar;
     u32Data = cs_init;
     dwOffset = r2_cs_reg;
     WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
     /* write byte count **/
     dwAddrSpace =cs_bar;
     u32Data = cs_start+nword*2;
     dwOffset = r2_cs_reg;
     WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
     if(ipr_status ==1) {
      dwAddrSpace =cs_bar;
      u64Data =0;
      dwOffset = t2_cs_reg;
      WDC_ReadAddr64(hDev, dwAddrSpace, dwOffset, &u64Data);
      printf (" status word before read = %x, %x \n",(u64Data>>32), (u64Data &0xffff));
     }

     return 0;
    }
    if ((istart == 2) | (istart == 3)) {
//     if(ipr_status ==1) {
//      dwAddrSpace =2;
//      u64Data =0;
//      dwOffset = 0x18;
//      WDC_ReadAddr64(hDev, dwAddrSpace, dwOffset, &u64Data);
//      printf (" status word before read = %x, %x \n",(u64Data>>32), (u64Data &0xffff));
//     }
     if(mode == 0) {
      nread = nword/4+1;
      if(nword%4 == 0) nread = nword/4;
      for (j=0; j< nread; j++) {
       dwAddrSpace =t2_tr_bar;
       dwOffset = 0x0;
       u64Data =0xbad;
       WDC_ReadAddr64(hDev,dwAddrSpace, dwOffset, &u64Data);
//       printf("u64Data = %16X\n",u64Data);
       *buff_rec++ = (u64Data &0xffffffff);
       *buff_rec++ = u64Data >>32;
//       printf("%x \n",(u64Data &0xffffffff));
//       printf("%x \n",(u64Data >>32 ));
//       if(j*2+1 > nword) *buff_rec++ = (u64Data)>>32;
//       *buff_rec++ = 0x0;
      }
      if(ipr_status ==1) {
       dwAddrSpace =cs_bar;
       u64Data =0;
       dwOffset = t2_cs_reg;
       WDC_ReadAddr64(hDev, dwAddrSpace, dwOffset, &u64Data);
       printf (" status word after read = %x, %x \n",(u64Data>>32), (u64Data &0xffff));
      }
      return 0;
     }
     if( mode ==1 ){            ///**** not up to date ****///
      nread = nword*2;
      WDC_DMASyncCpu(pDma_rec);
/*
      printf(" nwrite = %d \n", nwrite);
      printf(" pcie_send hDev = %d\n", hDev);
      printf(" buf_send = %X\n",*buf_send);
*/
/*setup receiver
      dwAddrSpace =2;
      u32Data = 0x20000000;
      dwOffset = 0x1c;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
      dwAddrSpace =2;
      u32Data = 0x40000000+nread;
      dwOffset = 0x1c;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
*/
/* set up sending DMA starting address */

      dwAddrSpace =2;
      u32Data = 0x20000000;
      dwOffset = 0x0;
      u32Data = pDma_rec->Page->pPhysicalAddr & 0xffffffff;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);

      dwAddrSpace =2;
      u32Data = 0x20000000;
      dwOffset = 0x4;
      u32Data = (pDma_rec->Page->pPhysicalAddr >> 32) & 0xffffffff;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);

/* byte count */
      dwAddrSpace =2;
      dwOffset = 0x8;
      u32Data = nread;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);

/* write this will start DMA */
//      dwAddrSpace =2;
//      dwOffset = 0xc;
//      u32Data = 0x00100040;
//      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);

/* write this will start DMA */
      dwAddrSpace =2;
      dwOffset = cs_dma_cntrl;
      is = (pDma_rec->Page->pPhysicalAddr >> 32) & 0xffffffff;
      if(is == 0) {
//**         if(iwrite !=1 ) printf(" use 3dw \n");
       u32Data = dma_tr2+dma_3dw_rec;
      }
      else {
       u32Data = dma_tr2+dma_4dw_rec;
//**        if(iwrite !=1 ) printf(" use 4dw \n");
      }
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);


      icomp=0;
      for (i=0; i<20000; i++) {
        dwAddrSpace =2;
	dwOffset = 0xc;
        WDC_ReadAddr32(hDev, dwAddrSpace, dwOffset, &u32Data);
	if(iprint ==1) printf(" DMA status read %d %X \n", i, u32Data);
	if(((u32Data & 0x80000000) == 0)) {
          icomp=1;
//          if(iprint == 1) printf(" DMA complete %d \n", i);
          printf(" DMA complete %d \n", i);
        }
	if((u32Data & 0x80000000) == 0) break;
      }
      if(icomp == 0) {
        printf("DMA timeout\n");
        return 1;
      }
      WDC_DMASyncIo(pDma_rec);
      for (i=0; i< nword; i++) {
        *buff_rec++ = *(buf_rec+i);
/*	printf("%d \n",*(buf_send+i));   */
      }
     }
    }
    return 0;
    }



 static int pcie_rec_16b(WDC_DEVICE_HANDLE hDev, int mode, int istart, int nword, int ipr_status, UINT32 *buff_rec)
{
/* imode =0 single word transfer, imode =1 DMA */
#include "wdc_defs.h"
    static DWORD dwAddrSpace;
    static DWORD dwDMABufSize;

    static UINT32 *buf_rec;
    static WD_DMA *pDma_rec;
    static DWORD dwStatus;
    static DWORD dwOptions_rec = DMA_FROM_DEVICE;
    static DWORD dwOffset;
    static UINT32 u32Data;
    static UINT64 u64Data;
    static PVOID pbuf_rec;
    int nread,i,j, iprint,icomp;
    static int ifr=0;

    if (ifr == 0) {
      ifr=1;
      dwDMABufSize = 140000;
      dwStatus = WDC_DMAContigBufLock(hDev, &pbuf_rec, dwOptions_rec, dwDMABufSize, &pDma_rec);
      if (WD_STATUS_SUCCESS != dwStatus) {
             printf("Failed locking a send Contiguous DMA buffer. Error 0x%lx - %s\n", dwStatus, Stat2Str(dwStatus));
      }
      buf_rec = pbuf_rec;
    }
    iprint =0;
//    printf(" istart = %d\n", istart);
//   printf(" mode   = %d\n", mode);
/** set up the receiver **/
    if((istart == 1) | (istart == 3)) {
// initalize transmitter mode register...
//     printf(" nword = %d \n",nword);
/*
     if(ipr_status ==1) {
      dwAddrSpace =2;
      u64Data =0;
      dwOffset = 0x18;
      WDC_ReadAddr64(hDev, dwAddrSpace, dwOffset, &u64Data);
      printf (" status word before set = %x, %x \n",(u64Data>>32), (u64Data &0xffff));
     }
*/
     dwAddrSpace =2;
     u32Data = 0xf0000008;
     dwOffset = 0x28;
     WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);

     /*initialize the receiver */
     dwAddrSpace =2;
     u32Data = 0x20000000;
     dwOffset = 0x1c;
     WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
     /* write byte count **/
     dwAddrSpace =2;
     u32Data = 0x40000000+nword*2;
     dwOffset = 0x1c;
     WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
     if(ipr_status ==1) {
      dwAddrSpace =2;
      u64Data =0;
      dwOffset = 0x18;
      WDC_ReadAddr64(hDev, dwAddrSpace, dwOffset, &u64Data);
      printf (" status word before read = %x, %x \n",(u64Data>>32), (u64Data &0xffff));
     }

     return 0;
    }
    if ((istart == 2) | (istart == 3)) {
//     if(ipr_status ==1) {
//      dwAddrSpace =2;
//      u64Data =0;
//      dwOffset = 0x18;
//      WDC_ReadAddr64(hDev, dwAddrSpace, dwOffset, &u64Data);
//      printf (" status word before read = %x, %x \n",(u64Data>>32), (u64Data &0xffff));
//     }
     if(mode == 0) {
      nread = nword/4+1;
      if(nword%2 == 0) nread = nword/4;
      for (j=0; j< nread; j++) {
       dwAddrSpace =0;
       dwOffset = 0x0;
       u64Data =0xbad;
       WDC_ReadAddr64(hDev,dwAddrSpace, dwOffset, &u64Data);
//       printf("u64Data = %16X\n",u64Data);
       *buff_rec++ = (u64Data &0xffffffff);
       *buff_rec++ = u64Data >>32;
//       printf("%x \n",(u64Data &0xffffffff));
//       printf("%x \n",(u64Data >>32 ));
//       if(j*2+1 > nword) *buff_rec++ = (u64Data)>>32;
//       *buff_rec++ = 0x0;
      }
      if(ipr_status ==1) {
       dwAddrSpace =2;
       u64Data =0;
       dwOffset = 0x18;
       WDC_ReadAddr64(hDev, dwAddrSpace, dwOffset, &u64Data);
       printf (" status word after read = %x, %x \n",(u64Data>>32), (u64Data &0xffff));
      }
      return 0;
     }
     if( mode ==1 ){
      nread = nword*4;
      WDC_DMASyncCpu(pDma_rec);
/*
      printf(" nwrite = %d \n", nwrite);
      printf(" pcie_send hDev = %d\n", hDev);
      printf(" buf_send = %X\n",*buf_send);
*/
/*setup receiver
      dwAddrSpace =2;
      u32Data = 0x20000000;
      dwOffset = 0x1c;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
      dwAddrSpace =2;
      u32Data = 0x40000000+nread;
      dwOffset = 0x1c;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
*/
/* set up sending DMA starting address */

      dwAddrSpace =2;
      u32Data = 0x20000000;
      dwOffset = 0x0;
      u32Data = pDma_rec->Page->pPhysicalAddr & 0xffffffff;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);

      dwAddrSpace =2;
      u32Data = 0x20000000;
      dwOffset = 0x4;
      u32Data = (pDma_rec->Page->pPhysicalAddr >> 32) & 0xffffffff;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);

/* byte count */
      dwAddrSpace =2;
      dwOffset = 0x8;
      u32Data = nread;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);

/* write this will start DMA */
      dwAddrSpace =2;
      dwOffset = 0xc;
      u32Data = 0x00100040;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
      icomp=0;
      for (i=0; i<20000; i++) {
        dwAddrSpace =2;
	dwOffset = 0xC;
        WDC_ReadAddr32(hDev, dwAddrSpace, dwOffset, &u32Data);
	if(iprint ==1) printf(" DMA status read %d %X \n", i, u32Data);
	if(((u32Data & 0x80000000) == 0)) {
          icomp=1;
          if(iprint == 1) printf(" DMA complete %d \n", i);
        }
	if((u32Data & 0x80000000) == 0) break;
      }
      if(icomp == 0) {
        printf("DMA timeout\n");
        return 1;
      }
      WDC_DMASyncIo(pDma_rec);
      for (i=0; i< nword; i++) {
        *buff_rec++ = *(buf_rec+i);
/*	printf("%d \n",*(buf_send+i));   */
      }
     }
    }
    return 0;
    }


static int pcie_send_6_1(WDC_DEVICE_HANDLE hDev2, int mode, int nword, UINT32 *buff_send)
{
/* imode =0 single word transfer, imode =1 DMA */
#include "wdc_defs.h"
    static DWORD dwAddrSpace;
    static DWORD dwDMABufSize;

    static UINT32 *buf_send;
    static WD_DMA *pDma_send;
    static DWORD dwStatus;
    static DWORD dwOptions_send = DMA_TO_DEVICE;
    static DWORD dwOffset;
    static UINT32 u32Data;
    static PVOID pbuf_send;
    int nwrite,i,j, iprint;
    static int ifr=0;

    if (ifr == 0) {
      ifr=1;
      dwDMABufSize = 140000;
      dwStatus = WDC_DMAContigBufLock(hDev2, &pbuf_send, dwOptions_send, dwDMABufSize, &pDma_send);
      if (WD_STATUS_SUCCESS != dwStatus) {
             printf("Failed locking a send Contiguous DMA buffer. Error 0x%lx - %s\n", dwStatus, Stat2Str(dwStatus));
      }
      buf_send = pbuf_send;
    }
    iprint =1;
    if(iprint ==1) printf(" enter pcie_send_6_1 \n");
    if(mode ==1 ) {
      for (i=0; i< nword; i++) {
        *(buf_send+i) = *buff_send++;
/*	printf("%d \n",*(buf_send+i));   */
      }
    }
    if(mode == 0) {
     nwrite = nword*4;
     /*setup transmiiter */
     dwAddrSpace =2;
     u32Data = 0x20000000;
     dwOffset = 0x18;
     WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);
     dwAddrSpace =2;
     u32Data = 0x40000000+nwrite;
     dwOffset = 0x18;
     WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);
     for (j=0; j< nword; j++) {
       dwAddrSpace =0;
       dwOffset = 0x0;
       u32Data = *buff_send++;
       WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);
     }
     for (i=0; i<20000; i++) {
       dwAddrSpace =2;
       dwOffset = 0xC;
       WDC_ReadAddr32(hDev2, dwAddrSpace, dwOffset, &u32Data);
       if(iprint ==1) printf(" status reed %d %X \n", i, u32Data);
       if(((u32Data & 0x80000000) == 0) && (iprint == 1)) printf(" Data Transfer complete %d \n", i);
       if((u32Data & 0x80000000) == 0) break;
     }
    }
    if( mode ==1 ){
      nwrite = nword*4;
      WDC_DMASyncCpu(pDma_send);
/*
      printf(" nwrite = %d \n", nwrite);
      printf(" pcie_send hDev = %d\n", hDev);
      printf(" buf_send = %X\n",*buf_send);
*/
     /*setup transmiiter */
      dwAddrSpace =2;
      u32Data = 0x20000000;
      dwOffset = 0x18;
      WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);
      dwAddrSpace =2;
      u32Data = 0x40000000+nwrite;
      dwOffset = 0x18;
      WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);

/* set up sending DMA starting address */

      dwAddrSpace =2;
      u32Data = 0x20000000;
      dwOffset = 0x0;
      u32Data = pDma_send->Page->pPhysicalAddr & 0xffffffff;
      WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);

      dwAddrSpace =2;
      u32Data = 0x20000000;
      dwOffset = 0x4;
      u32Data = (pDma_send->Page->pPhysicalAddr >> 32) & 0xffffffff;
      WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);

/* byte count */
      dwAddrSpace =2;
      dwOffset = 0x8;
      u32Data = nwrite;
      WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);

/* write this will start DMA */
      dwAddrSpace =2;
      dwOffset = 0xc;
      u32Data = 0x00100000;
      WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);

      for (i=0; i<20000; i++) {
        dwAddrSpace =2;
	dwOffset = 0xC;
        WDC_ReadAddr32(hDev2, dwAddrSpace, dwOffset, &u32Data);
	if(iprint ==1) printf(" DMA status reed %d %X \n", i, u32Data);
	if(((u32Data & 0x80000000) == 0) &&( iprint == 1)) printf(" DMA complete %d \n", i);
	if((u32Data & 0x80000000) == 0) break;
      }
      WDC_DMASyncIo(pDma_send);
    }
    return i;
    }


 static int pcie_rec_6_1(WDC_DEVICE_HANDLE hDev2, int mode, int istart, int nword, int ipr_status, UINT32 *buff_rec)
{
/* imode =0 single word transfer, imode =1 DMA */
#include "wdc_defs.h"
    static DWORD dwAddrSpace;
    static DWORD dwDMABufSize;

    static UINT32 *buf_rec;
    static WD_DMA *pDma_rec;
    static DWORD dwStatus;
    static DWORD dwOptions_rec = DMA_FROM_DEVICE;
    static DWORD dwOffset;
    static UINT32 u32Data;
    static UINT64 u64Data;
    static PVOID pbuf_rec;
    int nread,i,j, iprint,icomp;
    static int ifr=0;

    if (ifr == 0) {
      ifr=1;
      dwDMABufSize = 140000;
      dwStatus = WDC_DMAContigBufLock(hDev2, &pbuf_rec, dwOptions_rec, dwDMABufSize, &pDma_rec);
      if (WD_STATUS_SUCCESS != dwStatus) {
             printf("Failed locking a send Contiguous DMA buffer. Error 0x%lx - %s\n", dwStatus, Stat2Str(dwStatus));
      }
      buf_rec = pbuf_rec;
    }
    iprint =0;
 //   printf(" istart = %d\n", istart);
 //   printf(" mode   = %d\n", mode);
/** set up the receiver **/
    if((istart == 1) | (istart == 3)) {
// initalize transmitter mode register...
 //    dwAddrSpace =2;
 //    u32Data = 0xf0000008;
 //    dwOffset = 0x28;
 //    WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);

     /*initialize the receiver */
     dwAddrSpace =2;
     u32Data = 0x20000000;
     dwOffset = 0x1c;
     WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);
     /* write byte count **/
     dwAddrSpace =2;
     u32Data = 0x40000000+nword*2;
     dwOffset = 0x1c;
     WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);
     if(ipr_status ==1) {
      dwAddrSpace =2;
      u64Data =0;
      dwOffset = 0x18;
      WDC_ReadAddr64(hDev2, dwAddrSpace, dwOffset, &u64Data);
      printf (" status word before read hDev2 = %x, %x \n",(u64Data>>32), (u64Data &0xffff));
     }

     return 0;
    }
    if ((istart == 2) | (istart == 3)) {
//     if(ipr_status ==1) {
//      dwAddrSpace =2;
//      u64Data =0;
//      dwOffset = 0x18;
//      WDC_ReadAddr64(hDev, dwAddrSpace, dwOffset, &u64Data);
//      printf (" status word before read = %x, %x \n",(u64Data>>32), (u64Data &0xffff));
//     }
     if(mode == 0) {
      nread = nword/4+1;
      if(nword%4 == 0) nread = nword/4;
      for (j=0; j< nread; j++) {
       dwAddrSpace =0;
       dwOffset = 0x0;
       u64Data =0xbad;
       WDC_ReadAddr64(hDev2,dwAddrSpace, dwOffset, &u64Data);
//       printf("u64Data = %16X\n",u64Data);
       *buff_rec++ = (u64Data &0xffffffff);
       *buff_rec++ = u64Data >>32;
//       printf("%x \n",(u64Data &0xffffffff));
//       printf("%x \n",(u64Data >>32 ));
//       if(j*2+1 > nword) *buff_rec++ = (u64Data)>>32;
//       *buff_rec++ = 0x0;
      }
      if(ipr_status ==1) {
       dwAddrSpace =2;
       u64Data =0;
       dwOffset = 0x18;
       WDC_ReadAddr64(hDev2, dwAddrSpace, dwOffset, &u64Data);
       printf (" status word after read hDev2 = %x, %x \n",(u64Data>>32), (u64Data &0xffff));
      }
      return 0;
     }
     if( mode ==1 ){            ///**** not up to date ****///
      nread = nword*4;
      WDC_DMASyncCpu(pDma_rec);
/*
      printf(" nwrite = %d \n", nwrite);
      printf(" pcie_send hDev = %d\n", hDev);
      printf(" buf_send = %X\n",*buf_send);
*/
/*setup receiver
      dwAddrSpace =2;
      u32Data = 0x20000000;
      dwOffset = 0x1c;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
      dwAddrSpace =2;
      u32Data = 0x40000000+nread;
      dwOffset = 0x1c;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
*/
/* set up sending DMA starting address */

      dwAddrSpace =2;
      u32Data = 0x20000000;
      dwOffset = 0x0;
      u32Data = pDma_rec->Page->pPhysicalAddr & 0xffffffff;
      WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);

      dwAddrSpace =2;
      u32Data = 0x20000000;
      dwOffset = 0x4;
      u32Data = (pDma_rec->Page->pPhysicalAddr >> 32) & 0xffffffff;
      WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);

/* byte count */
      dwAddrSpace =2;
      dwOffset = 0x8;
      u32Data = nread;
      WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);

/* write this will start DMA */
      dwAddrSpace =2;
      dwOffset = 0xc;
      u32Data = 0x00100040;
      WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);
      icomp=0;
      for (i=0; i<20000; i++) {
        dwAddrSpace =2;
	dwOffset = 0xC;
        WDC_ReadAddr32(hDev2, dwAddrSpace, dwOffset, &u32Data);
	if(iprint ==1) printf(" DMA status read %d %X \n", i, u32Data);
	if(((u32Data & 0x80000000) == 0)) {
          icomp=1;
          if(iprint == 1) printf(" DMA complete %d \n", i);
        }
	if((u32Data & 0x80000000) == 0) break;
      }
      if(icomp == 0) {
        printf("DMA timeout\n");
        return 1;
      }
      WDC_DMASyncIo(pDma_rec);
      for (i=0; i< nword; i++) {
        *buff_rec++ = *(buf_rec+i);
/*	printf("%d \n",*(buf_send+i));   */
      }
     }
    }
    return 0;
    }



 static int pcie_rec_6_2(WDC_DEVICE_HANDLE hDev2, int mode, int istart, int nword, int ipr_status, UINT32 *buff_rec)
{
/* imode =0 single word transfer, imode =1 DMA */
#include "wdc_defs.h"
#define  t1_tr_bar 0
#define  t2_tr_bar 4
#define  cs_bar 2

/**  command register location **/

#define  tx_mode_reg 0x28
#define  t1_cs_reg 0x18
#define  r1_cs_reg 0x1c
#define  t2_cs_reg 0x20
#define  r2_cs_reg 0x24

#define  tx_md_reg 0x28

#define  cs_dma_add_low_reg 0x0
#define  cs_dma_add_high_reg  0x4
#define  cs_dma_by_cnt 0x8
#define  cs_dma_cntrl 0xc
#define  cs_dma_msi_abort 0x10

/** define status bits **/

#define  cs_init  0x20000000
#define  cs_mode_p 0x8000000
#define  cs_mode_n 0x0
#define  cs_start 0x40000000
#define  cs_done  0x80000000

#define  dma_tr1  0x100000
#define  dma_tr2  0x200000
#define  dma_tr12 0x300000
#define  dma_3dw_trans 0x0
#define  dma_3dw_rec   0x40
#define  dma_in_progress 0x80000000

#define  dma_abort 0x2

    static DWORD dwAddrSpace;
    static DWORD dwDMABufSize;

    static UINT32 *buf_rec;
    static WD_DMA *pDma_rec;
    static DWORD dwStatus;
    static DWORD dwOptions_rec = DMA_FROM_DEVICE;
    static DWORD dwOffset;
    static UINT32 u32Data;
    static UINT64 u64Data;
    static PVOID pbuf_rec;
    int nread,i,j, iprint,icomp;
    static int ifr=0;

    if (ifr == 0) {
      ifr=1;
      dwDMABufSize = 140000;
      dwStatus = WDC_DMAContigBufLock(hDev2, &pbuf_rec, dwOptions_rec, dwDMABufSize, &pDma_rec);
      if (WD_STATUS_SUCCESS != dwStatus) {
             printf("Failed locking a send Contiguous DMA buffer. Error 0x%lx - %s\n", dwStatus, Stat2Str(dwStatus));
      }
      buf_rec = pbuf_rec;
    }
    iprint =0;
 //   printf(" istart = %d\n", istart);
 //   printf(" mode   = %d\n", mode);
/** set up the receiver **/
    if((istart == 1) | (istart == 3)) {
// initalize transmitter mode register...
//     dwAddrSpace =2;
//     u32Data = 0xf0000008;
//     dwOffset = tx_mode_reg;
//     WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);

     /*initialize the receiver */
     dwAddrSpace =cs_bar;
     u32Data = cs_init;
     dwOffset = r2_cs_reg;
     WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);
     /* write byte count **/
     dwAddrSpace =cs_bar;
     u32Data = cs_start+nword*2;
     dwOffset = r2_cs_reg;
     WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);
     if(ipr_status ==1) {
      dwAddrSpace =cs_bar;
      u64Data =0;
      dwOffset = t2_cs_reg;
      WDC_ReadAddr64(hDev2, dwAddrSpace, dwOffset, &u64Data);
      printf (" status word before read = %x, %x \n",(u64Data>>32), (u64Data &0xffff));
     }

     return 0;
    }
    if ((istart == 2) | (istart == 3)) {
//     if(ipr_status ==1) {
//      dwAddrSpace =2;
//      u64Data =0;
//      dwOffset = 0x18;
//      WDC_ReadAddr64(hDev, dwAddrSpace, dwOffset, &u64Data);
//      printf (" status word before read = %x, %x \n",(u64Data>>32), (u64Data &0xffff));
//     }
     if(mode == 0) {
      nread = nword/4+1;
      if(nword%4 == 0) nread = nword/4;
      for (j=0; j< nread; j++) {
       dwAddrSpace =t2_tr_bar;
       dwOffset = 0x0;
       u64Data =0xbad;
       WDC_ReadAddr64(hDev2,dwAddrSpace, dwOffset, &u64Data);
//       printf("u64Data = %16X\n",u64Data);
       *buff_rec++ = (u64Data &0xffffffff);
       *buff_rec++ = u64Data >>32;
//       printf("%x \n",(u64Data &0xffffffff));
//       printf("%x \n",(u64Data >>32 ));
//       if(j*2+1 > nword) *buff_rec++ = (u64Data)>>32;
//       *buff_rec++ = 0x0;
      }
      if(ipr_status ==1) {
       dwAddrSpace =cs_bar;
       u64Data =0;
       dwOffset = t2_cs_reg;
       WDC_ReadAddr64(hDev2, dwAddrSpace, dwOffset, &u64Data);
       printf (" status word after read = %x, %x \n",(u64Data>>32), (u64Data &0xffff));
      }
      return 0;
     }
     if( mode ==1 ){            ///**** not up to date ****///
      nread = nword*4;
      WDC_DMASyncCpu(pDma_rec);
/*
      printf(" nwrite = %d \n", nwrite);
      printf(" pcie_send hDev = %d\n", hDev);
      printf(" buf_send = %X\n",*buf_send);
*/
/*setup receiver
      dwAddrSpace =2;
      u32Data = 0x20000000;
      dwOffset = 0x1c;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
      dwAddrSpace =2;
      u32Data = 0x40000000+nread;
      dwOffset = 0x1c;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
*/
/* set up sending DMA starting address */

      dwAddrSpace =2;
      u32Data = 0x20000000;
      dwOffset = 0x0;
      u32Data = pDma_rec->Page->pPhysicalAddr & 0xffffffff;
      WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);

      dwAddrSpace =2;
      u32Data = 0x20000000;
      dwOffset = 0x4;
      u32Data = (pDma_rec->Page->pPhysicalAddr >> 32) & 0xffffffff;
      WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);

/* byte count */
      dwAddrSpace =2;
      dwOffset = 0x8;
      u32Data = nread;
      WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);

/* write this will start DMA */
      dwAddrSpace =2;
      dwOffset = 0xc;
      u32Data = 0x00100040;
      WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);
      icomp=0;
      for (i=0; i<20000; i++) {
        dwAddrSpace =2;
	dwOffset = 0xC;
        WDC_ReadAddr32(hDev2, dwAddrSpace, dwOffset, &u32Data);
	if(iprint ==1) printf(" DMA status read %d %X \n", i, u32Data);
	if(((u32Data & 0x80000000) == 0)) {
          icomp=1;
          if(iprint == 1) printf(" DMA complete %d \n", i);
        }
	if((u32Data & 0x80000000) == 0) break;
      }
      if(icomp == 0) {
        printf("DMA timeout\n");
        return 1;
      }
      WDC_DMASyncIo(pDma_rec);
      for (i=0; i< nword; i++) {
        *buff_rec++ = *(buf_rec+i);
/*	printf("%d \n",*(buf_send+i));   */
      }
     }
    }
    return 0;
    }



    static int xmit_boot(WDC_DEVICE_HANDLE hDev, int imod_xmit)
{
#include "wdc_defs.h"
#define  mb_xmit_conf_add 0x2

    FILE *inpf;
    int imod,ichip,count,counta,ichip_c,dummy1,ik,ij,i;
    unsigned char charchannel,carray[4000];
    int nsend,nword,k;
    UINT32 buf_send[10000],send_array[10000];
    UINT32 *px;
    struct timespec tim,tim2;
    tim.tv_sec=0;
    tim.tv_nsec = 128000;
//
//    boot up xmit module 1st
//
      nsend=500;
      px = &buf_send;
      printf(" boot xmit module \n");
      inpf = fopen("../../xmit_fpga","r");
      imod=imod_xmit;
      ichip=mb_xmit_conf_add;
      buf_send[0]=(imod<<11)+(ichip<<8)+0x0+(0x0<<16);  // turn conf to be on
      i=1;
      k=1;
      i = pcie_send(hDev, i, k, px);
//      for (i=0; i<100000; i++) {
//          ik= i%2;
//          dummy1= (ik+i)*(ik+i);
//      }


        /* read data as characters (28941) */
      usleep(1000);   // wait fior a while
      count = 0;
      counta= 0;
      ichip_c = 7; // set ichip_c to stay away from any other command in the
      dummy1 =0;
      while (fread(&charchannel,sizeof(char),1,inpf)==1) {
       carray[count] = charchannel;
       count++;
       counta++;
       if((count%(nsend*2)) == 0) {
//        printf(" loop = %d\n",dummy1);
        buf_send[0] = (imod <<11) +(ichip_c <<8)+ (carray[0]<<16);
        send_array[0] =buf_send[0];
        if(dummy1 <= 5 ) printf(" counta = %d, first word = %x, %x, %x %x %x \n",counta,buf_send[0], carray[0], carray[1]
        ,carray[2], carray[3]);
        for (ij=0; ij< nsend; ij++) {
         if(ij== (nsend-1)) buf_send[ij+1] = carray[2*ij+1]+(0x0<<16);
         else buf_send[ij+1] = carray[2*ij+1]+ (carray[2*ij+2]<<16);
//         buf_send[ij+1] = carray[2*ij+1]+ (carray[2*ij+2]<<16);
         send_array[ij+1] = buf_send[ij+1];
        }
        nword =nsend+1;
        i=1;
//       if(dummy1 == 0)
        ij = pcie_send(hDev, i, nword, px);
        nanosleep(&tim , &tim2);
        dummy1 = dummy1+1;
        count =0;
       }
      }
      if(feof(inpf)) {
       printf("You have reached the end-of-file word count= %d %d\n", counta, count);
       buf_send[0] = (imod <<11) +(ichip_c <<8)+ (carray[0]<<16);
       if ( count > 1) {
        if( ((count-1)%2) ==0) {
         ik =(count-1)/2;
        }
        else {
         ik =(count-1)/2+1;
        }
        ik=ik+2;   // add one more for safety
        printf("ik= %d\n",ik);
        for (ij=0; ij<ik; ij++){
         if(ij == (ik-1)) buf_send[ij+1] = carray[(2*ij)+1]+(((imod<<11)+(ichip<<8)+0x0)<<16);
         else buf_send[ij+1] = carray[(2*ij)+1]+ (carray[(2*ij)+2]<<16);
         send_array[ij+1] = buf_send[ij+1];
        }
       }
       else ik=1;

           for (ij=ik-10; ij< ik+1; ij++) {
            printf("Last data = %d, %x\n",ij,buf_send[ij]);
           }

       nword =ik+1;
       i=1;
       i = pcie_send(hDev, i, nword, px);
      }
      usleep(2000);    // wait for 2ms to cover the packet time plus fpga init time
      fclose(inpf);
      return i;
}


    static int fem_boot(WDC_DEVICE_HANDLE hDev, int imod_fem)
{
#include "wdc_defs.h"
#define  mb_feb_conf_add 0x2

    FILE *inpf;
    int imod,ichip,count,counta,ichip_c,dummy1,ik,ij,i;
    unsigned char charchannel,carray[4000];
    int nsend,nword,k;
    UINT32 buf_send[10000],send_array[10000];
    UINT32 *px;
    struct timespec tim,tim2;
    tim.tv_sec=0;
    tim.tv_nsec = 128000;
//
//    boot up xmit module 1st
//
      nsend=500;
      px = &buf_send;
//
//    Boot stratix after XMIT module
//
      inpf = fopen("/home/ub/feb_fpga_test","r");
      imod=imod_fem;
      ichip=mb_feb_conf_add;
      buf_send[0]=(imod<<11)+(ichip<<8)+0x0+(0x0<<16);  // turn conf to be on
      i=1;
      k=1;
      i = pcie_send(hDev, i, k, px);
//      for (i=0; i<100000; i++) {
//          ik= i%2;
//          dummy1= (ik+i)*(ik+i);
//      }


        /* read data as characters (28941) */
      usleep(1000);   // wait fior a while
      count = 0;
      counta= 0;
      ichip_c = 7; // set ichip_c to stay away from any other command in the
      dummy1 =0;
      while (fread(&charchannel,sizeof(char),1,inpf)==1) {
       carray[count] = charchannel;
       count++;
       counta++;
       if((count%(nsend*2)) == 0) {
//        printf(" loop = %d\n",dummy1);
        buf_send[0] = (imod <<11) +(ichip_c <<8)+ (carray[0]<<16);
        send_array[0] =buf_send[0];
        if(dummy1 <= 5 ) printf(" counta = %d, first word = %x, %x, %x %x %x \n",counta,buf_send[0], carray[0], carray[1]
        ,carray[2], carray[3]);
        for (ij=0; ij< nsend; ij++) {
         if(ij== (nsend-1)) buf_send[ij+1] = carray[2*ij+1]+(0x0<<16);
         else buf_send[ij+1] = carray[2*ij+1]+ (carray[2*ij+2]<<16);
//         buf_send[ij+1] = carray[2*ij+1]+ (carray[2*ij+2]<<16);
         send_array[ij+1] = buf_send[ij+1];
        }
        nword =nsend+1;
        i=1;
//       if(dummy1 == 0)
        ij = pcie_send(hDev, i, nword, px);
        nanosleep(&tim , &tim2);
        dummy1 = dummy1+1;
        count =0;
       }
      }
      if(feof(inpf)) {
       printf("You have reached the end-of-file word count= %d %d\n", counta, count);
       buf_send[0] = (imod <<11) +(ichip_c <<8)+ (carray[0]<<16);
       if ( count > 1) {
        if( ((count-1)%2) ==0) {
         ik =(count-1)/2;
        }
        else {
         ik =(count-1)/2+1;
        }
        ik=ik+2;   // add one more for safety
        printf("ik= %d\n",ik);
        for (ij=0; ij<ik; ij++){
         if(ij == (ik-1)) buf_send[ij+1] = carray[(2*ij)+1]+(((imod<<11)+(ichip<<8)+0x0)<<16);
         else buf_send[ij+1] = carray[(2*ij)+1]+ (carray[(2*ij)+2]<<16);
         send_array[ij+1] = buf_send[ij+1];
        }
       }
       else ik=1;

           for (ij=ik-10; ij< ik+1; ij++) {
            printf("Last data = %d, %x\n",ij,buf_send[ij]);
           }

       nword =ik+1;
       i=1;
       i = pcie_send(hDev, i, nword, px);
      }
       usleep(2000);    // wait for 2ms to cover the packet time plus fpga init time
       fclose(inpf);
      return i;
}




/* -----------------------------------------------
    Read/write memory and I/O addresses
   ----------------------------------------------- */
/* Read/write address menu options */
enum {
    MENU_RW_ADDR_SET_ADDR_SPACE = 1,
    MENU_RW_ADDR_SET_MODE,
    MENU_RW_ADDR_SET_TRANS_TYPE,
    MENU_RW_ADDR_READ,
    MENU_RW_ADDR_WRITE,
    MENU_RW_ADDR_EXIT = DIAG_EXIT_MENU,
};

#define ACTIVE_ADDR_SPACE_NEEDS_INIT 0xFF

/* Read/write memory or I/O space address menu */
static void MenuReadWriteAddr(WDC_DEVICE_HANDLE hDev)
{
    DWORD option;
    static DWORD dwAddrSpace = ACTIVE_ADDR_SPACE_NEEDS_INIT;
    static WDC_ADDR_MODE mode = WDC_MODE_32;
    static BOOL fBlock = FALSE;

    /* Initialize active address space */
    if (ACTIVE_ADDR_SPACE_NEEDS_INIT == dwAddrSpace)
    {
        DWORD dwNumAddrSpaces = PCIE_GetNumAddrSpaces(hDev);
        
        /* Find the first active address space */
        for (dwAddrSpace = 0; dwAddrSpace < dwNumAddrSpaces; dwAddrSpace++)
        {
            if (WDC_AddrSpaceIsActive(hDev, dwAddrSpace))
                break;
        }
        
        /* Sanity check */
        if (dwAddrSpace == dwNumAddrSpaces)
        {
            PCIE_ERR("MenuReadWriteAddr: Error - no active address spaces found\n");
            dwAddrSpace = ACTIVE_ADDR_SPACE_NEEDS_INIT;
            return;
        }
    }

    do
    {
        printf("\n");
        printf("Read/write the device's memory and IO ranges\n");
        printf("---------------------------------------------\n");
        printf("%d. Change active address space for read/write "
            "(currently: BAR %ld)\n", MENU_RW_ADDR_SET_ADDR_SPACE, dwAddrSpace);
        printf("%d. Change active read/write mode (currently: %s)\n",
            MENU_RW_ADDR_SET_MODE,
            (WDC_MODE_8 == mode) ? "8 bit" : (WDC_MODE_16 == mode) ? "16 bit" :
            (WDC_MODE_32 == mode) ? "32 bit" : "64 bit");
        printf("%d. Toggle active transfer type (currently: %s)\n",
            MENU_RW_ADDR_SET_TRANS_TYPE,
            (fBlock ? "block transfers" : "non-block transfers"));
        printf("%d. Read from active address space\n", MENU_RW_ADDR_READ);
        printf("%d. Write to active address space\n", MENU_RW_ADDR_WRITE);
        printf("%d. Exit menu\n", MENU_RW_ADDR_EXIT);
        printf("\n");
        
        if (DIAG_INPUT_FAIL == DIAG_GetMenuOption(&option,
            MENU_RW_ADDR_WRITE))
        {
            continue;
        }
        
        switch (option)
        {
        case MENU_RW_ADDR_EXIT: /* Exit menu */
            break;
        case MENU_RW_ADDR_SET_ADDR_SPACE: /* Set active address space for read/write address requests */
        {
            SetAddrSpace(hDev, &dwAddrSpace);
            break;
        }
        case MENU_RW_ADDR_SET_MODE: /* Set active mode for read/write address requests */
            WDC_DIAG_SetMode(&mode);
            break;
        case MENU_RW_ADDR_SET_TRANS_TYPE: /* Toggle active transfer type */
            fBlock = !fBlock;
            break;
        case MENU_RW_ADDR_READ:  /* Read from a memory or I/O address */
        case MENU_RW_ADDR_WRITE: /* Write to a memory or I/O address */
        {
            WDC_DIRECTION direction =
                (MENU_RW_ADDR_READ == option) ? WDC_READ : WDC_WRITE;

            if (fBlock)
                WDC_DIAG_ReadWriteBlock(hDev, direction, dwAddrSpace);
            else
                WDC_DIAG_ReadWriteAddr(hDev, direction, dwAddrSpace, mode);
            
            break;
        }
        }
    } while (MENU_RW_ADDR_EXIT != option);
}

static void SetAddrSpace(WDC_DEVICE_HANDLE hDev, PDWORD pdwAddrSpace)
{
    DWORD dwAddrSpace;
    DWORD dwNumAddrSpaces = PCIE_GetNumAddrSpaces(hDev);
    PCIE_ADDR_SPACE_INFO addrSpaceInfo;
    
    printf("\n");
    printf("Select an active address space:\n");
    printf("-------------------------------\n");

    for (dwAddrSpace = 0; dwAddrSpace < dwNumAddrSpaces; dwAddrSpace++)
    {
        BZERO(addrSpaceInfo);
        addrSpaceInfo.dwAddrSpace = dwAddrSpace;
        if (!PCIE_GetAddrSpaceInfo(hDev, &addrSpaceInfo))
        {
            PCIE_ERR("SetAddrSpace: Error - Failed to get address space information: %s",
                PCIE_GetLastErr());
            return;
        }

        printf("%ld. %-*s %-*s %s\n",
            dwAddrSpace + 1,
            MAX_NAME_DISPLAY, addrSpaceInfo.sName,
            MAX_TYPE - 1, addrSpaceInfo.sType,
            addrSpaceInfo.sDesc);
    }
    printf("\n");

    if (DIAG_INPUT_SUCCESS != DIAG_InputDWORD((PVOID)&dwAddrSpace,
        "Enter option", FALSE, 1, dwNumAddrSpaces))
    {
         return;
    }

    dwAddrSpace--;
    if (!WDC_AddrSpaceIsActive(hDev, dwAddrSpace))
    {
        printf("You have selected an inactive address space\n");
        return;
    }
            
    *pdwAddrSpace = dwAddrSpace;
}

/* -----------------------------------------------
    Read/write the configuration space
   ----------------------------------------------- */
/* Read/write the configuration space menu options */
enum {
    MENU_RW_CFG_SPACE_READ_OFFSET = 1,
    MENU_RW_CFG_SPACE_WRITE_OFFSET,
    MENU_RW_CFG_SPACE_READ_ALL_REGS,
    MENU_RW_CFG_SPACE_READ_REG,
    MENU_RW_CFG_SPACE_WRITE_REG,
    MENU_RW_CFG_SPACE_EXIT = DIAG_EXIT_MENU,
};

/* Display read/write configuration space menu */
static void MenuReadWriteCfgSpace(WDC_DEVICE_HANDLE hDev)
{
    DWORD option;
  
    do {
        /* Display pre-defined registers' information */
        if (PCIE_CFG_REGS_NUM)
        {
            printf("\n");
            printf("Configuration registers:\n");
            printf("------------------------\n");
            WDC_DIAG_RegsInfoPrint(gpPCIE_CfgRegs, PCIE_CFG_REGS_NUM,
                WDC_DIAG_REG_PRINT_ALL & ~WDC_DIAG_REG_PRINT_ADDR_SPACE);
        }

        printf("\n");
        printf("Read/write the device's configuration space\n");
        printf("--------------------------------------------\n");
        printf("%d. Read from an offset\n", MENU_RW_CFG_SPACE_READ_OFFSET);
        printf("%d. Write to an offset\n", MENU_RW_CFG_SPACE_WRITE_OFFSET);
        if (PCIE_CFG_REGS_NUM)
        {
            printf("%d. Read all configuration registers defined for the device (see list above)\n",
                MENU_RW_CFG_SPACE_READ_ALL_REGS);
            printf("%d. Read from a named register\n", MENU_RW_CFG_SPACE_READ_REG);
            printf("%d. Write to a named register\n", MENU_RW_CFG_SPACE_WRITE_REG);
        }
        printf("%d. Exit menu\n", MENU_RW_CFG_SPACE_EXIT);
        printf("\n");

        if (DIAG_INPUT_FAIL == DIAG_GetMenuOption(&option,
            PCIE_CFG_REGS_NUM ? MENU_RW_CFG_SPACE_WRITE_REG :
            MENU_RW_CFG_SPACE_WRITE_OFFSET))
        {
            continue;
        }

        switch (option)
        {
        case MENU_RW_CFG_SPACE_EXIT: /* Exit menu */
            break;
        case MENU_RW_CFG_SPACE_READ_OFFSET: /* Read from a configuration space offset */
            WDC_DIAG_ReadWriteBlock(hDev, WDC_READ, WDC_AD_CFG_SPACE);
            break;
        case MENU_RW_CFG_SPACE_WRITE_OFFSET: /* Write to a configuration space offset */
            WDC_DIAG_ReadWriteBlock(hDev, WDC_WRITE, WDC_AD_CFG_SPACE);
            break;
        case MENU_RW_CFG_SPACE_READ_ALL_REGS:
            WDC_DIAG_ReadRegsAll(hDev, gpPCIE_CfgRegs, PCIE_CFG_REGS_NUM, TRUE);
            break;
        case MENU_RW_CFG_SPACE_READ_REG:  /* Read from a configuration register */
            WDC_DIAG_ReadWriteReg(hDev, gpPCIE_CfgRegs, PCIE_CFG_REGS_NUM, WDC_READ, TRUE);
            break;
        case MENU_RW_CFG_SPACE_WRITE_REG: /* Write to a configuration register */
            WDC_DIAG_ReadWriteReg(hDev, gpPCIE_CfgRegs, PCIE_CFG_REGS_NUM, WDC_WRITE, TRUE);
            break;
        }
    } while (MENU_RW_CFG_SPACE_EXIT != option);
}

/* -----------------------------------------------
    Read/write the run-time registers
   ----------------------------------------------- */
/* Read/write the run-time registers menu options */
enum {
    MENU_RW_REGS_READ_ALL = 1,
    MENU_RW_REGS_READ_REG,
    MENU_RW_REGS_WRITE_REG,
    MENU_RW_REGS_EXIT = DIAG_EXIT_MENU,
};

/* Display read/write run-time registers menu */
static void MenuReadWriteRegs(WDC_DEVICE_HANDLE hDev)
{
    DWORD option;
    
    if (!PCIE_REGS_NUM)
    {
        printf("There are currently no pre-defined run-time registers\n");
        return;
    }
  
    do {
        /* Display pre-defined registers' information */
        printf("\n");
        printf("PCIE run-time registers:\n");
        printf("--------------------------\n");   
        WDC_DIAG_RegsInfoPrint(gpPCIE_Regs, PCIE_REGS_NUM, WDC_DIAG_REG_PRINT_ALL);

        printf("\n");
        printf("Read/write the PCIE run-time registers\n");
        printf("-----------------------------------------\n");
        printf("%d. Read all run-time registers defined for the device (see list above)\n",
            MENU_RW_REGS_READ_ALL);
        printf("%d. Read from a specific register\n", MENU_RW_REGS_READ_REG);
        printf("%d. Write to a specific register\n", MENU_RW_REGS_WRITE_REG);
        printf("%d. Exit menu\n", MENU_RW_REGS_EXIT);
        printf("\n");

        if (DIAG_INPUT_FAIL == DIAG_GetMenuOption(&option,
            MENU_RW_REGS_WRITE_REG))
        {
            continue;
        }

        switch (option)
        {
        case MENU_RW_REGS_EXIT: /* Exit menu */
            break;
        case MENU_RW_REGS_READ_ALL:
            WDC_DIAG_ReadRegsAll(hDev, gpPCIE_Regs, PCIE_REGS_NUM, FALSE);
            break;
        case MENU_RW_REGS_READ_REG:  /* Read from a register */
            WDC_DIAG_ReadWriteReg(hDev, gpPCIE_Regs, PCIE_REGS_NUM, WDC_READ, FALSE);
            break;
        case MENU_RW_REGS_WRITE_REG: /* Write to a register */
            WDC_DIAG_ReadWriteReg(hDev, gpPCIE_Regs, PCIE_REGS_NUM, WDC_WRITE, FALSE);
            break;
        }
    } while (MENU_RW_REGS_EXIT != option);
}

/* -----------------------------------------------
    Interrupt handling
   ----------------------------------------------- */
/* Interrupts menu options */
enum {
    MENU_INT_ENABLE_DISABLE = 1,
    MENU_INT_EXIT = DIAG_EXIT_MENU,
};

/* Enable/Disable interrupts menu */
static void MenuInterrupts(WDC_DEVICE_HANDLE hDev)
{
    DWORD option, dwIntOptions;
    BOOL fIntEnable, fIsMsi;

    dwIntOptions = WDC_GET_INT_OPTIONS(hDev);
    fIsMsi = WDC_INT_IS_MSI(dwIntOptions);
    if (dwIntOptions & INTERRUPT_LEVEL_SENSITIVE)
    {
        /* TODO: You can remove this message after you have modified the
           implementation of PCIE_IntEnable() in pcie_lib.c to 
           correctly acknowledge level-sensitive interrupts (see guidelines
           in PCIE_IntEnable()) */
        printf("\n");
        printf("WARNING!!!\n");
        printf("----------\n");
        printf("Your hardware has level sensitive interrupts.\n");
        printf("Before enabling the interrupts, %s first modify the source "
           "code of PCIE_IntEnable(), in the file pcie_lib.c, to "
           "correctly acknowledge\n%s interrupts when they occur (as dictated by "
           "the hardware's specifications)\n",
           fIsMsi ? "it's recommended that you" : "you must",
           fIsMsi ? "level sensitive" : "");    }

    do
    {
        fIntEnable = !PCIE_IntIsEnabled(hDev);

        printf("\n");
        printf("Interrupts\n");
        printf("-----------\n");
        printf("%d. %s interrupts\n", MENU_INT_ENABLE_DISABLE,
            fIntEnable ? "Enable" : "Disable");
        printf("%d. Exit menu\n", MENU_INT_EXIT);
        printf("\n");

        if (DIAG_INPUT_FAIL == DIAG_GetMenuOption(&option,
            MENU_RW_ADDR_WRITE))
        {
            continue;
        }

        switch (option)
        {
        case MENU_INT_EXIT: /* Exit menu */
            break;
        case MENU_INT_ENABLE_DISABLE: /* Enable/disable interrupts */
            if (fIntEnable)
            {
                DWORD dwStatus = PCIE_IntEnable(hDev, DiagIntHandler);

                if (WD_STATUS_SUCCESS == dwStatus)
                    printf("Interrupts enabled\n");
                else
                {
                    PCIE_ERR("Failed enabling interrupts. Error 0x%lx - %s\n",
                       dwStatus, Stat2Str(dwStatus));
                }
            }
            else
            {
                if (WD_STATUS_SUCCESS == PCIE_IntDisable(hDev))
                    printf("Interrupts disabled\n");
                else
                    PCIE_ERR("Failed disabling interrupts: %s", PCIE_GetLastErr());
            }
            break;
        }
    } while (MENU_INT_EXIT != option);
}

/* Diagnostics interrupt handler routine */
static void DiagIntHandler(WDC_DEVICE_HANDLE hDev, PCIE_INT_RESULT *pIntResult)
{
    /* TODO: You can modify this function in order to implement your own
             diagnostics interrupt handler routine */

    printf("Got interrupt number %ld\n", pIntResult->dwCounter);
    printf("Interrupt Type: %s\n",
        WDC_DIAG_IntTypeDescriptionGet(pIntResult->dwEnabledIntType));
    if (WDC_INT_IS_MSI(pIntResult->dwEnabledIntType))
        printf("Message Data: 0x%lx\n", pIntResult->dwLastMessage);
}

/* ----------------------------------------------------
    Plug-and-play and power management events handling
   ---------------------------------------------------- */
/* Events menu options */
enum {
    MENU_EVENTS_REGISTER_UNREGISTER = 1,
    MENU_EVENTS_EXIT = DIAG_EXIT_MENU,
};

/* Register/unregister Plug-and-play and power management events */
static void MenuEvents(WDC_DEVICE_HANDLE hDev)
{
    DWORD option;
    BOOL fRegister;

    do
    {
        fRegister = !PCIE_EventIsRegistered(hDev);
        
        printf("\n");
        printf("Plug-and-play and power management events\n");
        printf("------------------------------------------\n");
        printf("%d. %s events\n", MENU_EVENTS_REGISTER_UNREGISTER,
            fRegister ? "Register" : "Unregister");
        printf("%d. Exit menu\n", MENU_EVENTS_EXIT);
        printf("\n");
        
        if (DIAG_INPUT_FAIL == DIAG_GetMenuOption(&option,
            MENU_EVENTS_REGISTER_UNREGISTER))
        {
            continue;
        }

        switch (option)
        {
        case MENU_EVENTS_EXIT: /* Exit menu */
            break;
        case MENU_EVENTS_REGISTER_UNREGISTER: /* Register/unregister events */
            if (fRegister)
            {
                if (WD_STATUS_SUCCESS == PCIE_EventRegister(hDev, DiagEventHandler))
                    printf("Events registered\n");
                else
                    PCIE_ERR("Failed to register events. Last error:\n%s", PCIE_GetLastErr());
            }
            else
            {
                if (WD_STATUS_SUCCESS == PCIE_EventUnregister(hDev))
                    printf("Events unregistered\n");
                else
                    PCIE_ERR("Failed to unregister events. Last Error:\n%s", PCIE_GetLastErr());
            }
            break;
        }
    } while (MENU_EVENTS_EXIT != option);
}

/* Plug-and-play and power management events handler routine */
static void DiagEventHandler(WDC_DEVICE_HANDLE hDev, DWORD dwAction)
{
    /* TODO: You can modify this function in order to implement your own
             diagnostics events handler routine */

    printf("\nReceived event notification (device handle 0x%p): ", hDev);
    switch (dwAction)
    {
    case WD_INSERT:
        printf("WD_INSERT\n");
        break;
    case WD_REMOVE:
        printf("WD_REMOVE\n");
        break;
    case WD_POWER_CHANGED_D0:
        printf("WD_POWER_CHANGED_D0\n");
        break;
    case WD_POWER_CHANGED_D1:
        printf("WD_POWER_CHANGED_D1\n");
        break;
    case WD_POWER_CHANGED_D2:
        printf("WD_POWER_CHANGED_D2\n");
        break;
    case WD_POWER_CHANGED_D3:
        printf("WD_POWER_CHANGED_D3\n");
        break;
    case WD_POWER_SYSTEM_WORKING:
        printf("WD_POWER_SYSTEM_WORKING\n");
        break;
    case WD_POWER_SYSTEM_SLEEPING1:
        printf("WD_POWER_SYSTEM_SLEEPING1\n");
        break;
    case WD_POWER_SYSTEM_SLEEPING2:
        printf("WD_POWER_SYSTEM_SLEEPING2\n");
        break;
    case WD_POWER_SYSTEM_SLEEPING3:
        printf("WD_POWER_SYSTEM_SLEEPING3\n");
        break;
    case WD_POWER_SYSTEM_HIBERNATE:
        printf("WD_POWER_SYSTEM_HIBERNATE\n");
        break;
    case WD_POWER_SYSTEM_SHUTDOWN:
        printf("WD_POWER_SYSTEM_SHUTDOWN\n");
        break;
    default:
        printf("0x%lx\n", dwAction);
        break;
    }
}

