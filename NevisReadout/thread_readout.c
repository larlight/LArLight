/************************************************************************
*  File: pcie_diag.c
*
*  Sample user-mode diagnostics application for accessing PCIE
*  devices using WinDriver's API.
*  Code was generated by DriverWizard v10.21.
*
*  Jungo Confidential. Copyright (c) 2011 Jungo Ltd.  http://www.jungo.com
*************************************************************************/

#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <unistd.h>
#include <fcntl.h>
#include <pthread.h>
#include "wdc_defs.h"
#include "wdc_lib.h"
#include "utils.h"
#include "status_strings.h"
#include "samples/shared/diag_lib.h"
#include "samples/shared/wdc_diag_lib.h"
#include "samples/shared/pci_regs.h"
#include "pcie_lib.h"

/*************************************************************
  General definitions
 *************************************************************/
/* Error messages display */
#define PCIE_ERR printf

/*************************************************************
  Global variables
 *************************************************************/
/* User's input command */
static CHAR gsInput[256];

/* --------------------------------------------------
    PCIE configuration registers information
   -------------------------------------------------- */
/* Configuration registers information array */
const WDC_REG gPCIE_CfgRegs[] = {
    { WDC_AD_CFG_SPACE, PCI_VID, WDC_SIZE_16, WDC_READ_WRITE, "VID", "Vendor ID" },
    { WDC_AD_CFG_SPACE, PCI_DID, WDC_SIZE_16, WDC_READ_WRITE, "DID", "Device ID" },
    { WDC_AD_CFG_SPACE, PCI_CR, WDC_SIZE_16, WDC_READ_WRITE, "CMD", "Command" },
    { WDC_AD_CFG_SPACE, PCI_SR, WDC_SIZE_16, WDC_READ_WRITE, "STS", "Status" },
    { WDC_AD_CFG_SPACE, PCI_REV, WDC_SIZE_32, WDC_READ_WRITE, "RID_CLCD", "Revision ID & Class Code" },
    { WDC_AD_CFG_SPACE, PCI_CCSC, WDC_SIZE_8, WDC_READ_WRITE, "SCC", "Sub Class Code" },
    { WDC_AD_CFG_SPACE, PCI_CCBC, WDC_SIZE_8, WDC_READ_WRITE, "BCC", "Base Class Code" },
    { WDC_AD_CFG_SPACE, PCI_CLSR, WDC_SIZE_8, WDC_READ_WRITE, "CALN", "Cache Line Size" },
    { WDC_AD_CFG_SPACE, PCI_LTR, WDC_SIZE_8, WDC_READ_WRITE, "LAT", "Latency Timer" },
    { WDC_AD_CFG_SPACE, PCI_HDR, WDC_SIZE_8, WDC_READ_WRITE, "HDR", "Header Type" },
    { WDC_AD_CFG_SPACE, PCI_BISTR, WDC_SIZE_8, WDC_READ_WRITE, "BIST", "Built-in Self Test" },
    { WDC_AD_CFG_SPACE, PCI_BAR0, WDC_SIZE_32, WDC_READ_WRITE, "BADDR0", "Base Address 0" },
    { WDC_AD_CFG_SPACE, PCI_BAR1, WDC_SIZE_32, WDC_READ_WRITE, "BADDR1", "Base Address 1" },
    { WDC_AD_CFG_SPACE, PCI_BAR2, WDC_SIZE_32, WDC_READ_WRITE, "BADDR2", "Base Address 2" },
    { WDC_AD_CFG_SPACE, PCI_BAR3, WDC_SIZE_32, WDC_READ_WRITE, "BADDR3", "Base Address 3" },
    { WDC_AD_CFG_SPACE, PCI_BAR4, WDC_SIZE_32, WDC_READ_WRITE, "BADDR4", "Base Address 4" },
    { WDC_AD_CFG_SPACE, PCI_BAR5, WDC_SIZE_32, WDC_READ_WRITE, "BADDR5", "Base Address 5" },
    { WDC_AD_CFG_SPACE, PCI_CIS, WDC_SIZE_32, WDC_READ_WRITE, "CIS", "CardBus CIS Pointer" },
    { WDC_AD_CFG_SPACE, PCI_SVID, WDC_SIZE_16, WDC_READ_WRITE, "SVID", "Sub-system Vendor ID" },
    { WDC_AD_CFG_SPACE, PCI_SDID, WDC_SIZE_16, WDC_READ_WRITE, "SDID", "Sub-system Device ID" },
    { WDC_AD_CFG_SPACE, PCI_EROM, WDC_SIZE_32, WDC_READ_WRITE, "EROM", "Expansion ROM Base Address" },
    { WDC_AD_CFG_SPACE, PCI_CAP, WDC_SIZE_8, WDC_READ_WRITE, "NEW_CAP", "New Capabilities Pointer" },
    { WDC_AD_CFG_SPACE, PCI_ILR, WDC_SIZE_32, WDC_READ_WRITE, "INTLN", "Interrupt Line" },
    { WDC_AD_CFG_SPACE, PCI_IPR, WDC_SIZE_32, WDC_READ_WRITE, "INTPIN", "Interrupt Pin" },
    { WDC_AD_CFG_SPACE, PCI_MGR, WDC_SIZE_32, WDC_READ_WRITE, "MINGNT", "Minimum Required Burst Period" },
    { WDC_AD_CFG_SPACE, PCI_MLR, WDC_SIZE_32, WDC_READ_WRITE, "MAXLAT", "Maximum Latency" },
    };
#define PCIE_CFG_REGS_NUM sizeof(gPCIE_CfgRegs) / sizeof(WDC_REG)
/* TODO: For read-only or write-only registers, change the direction field of
         the relevant registers in gPCIE_CfgRegs to WDC_READ or WDC_WRITE. */
/* NOTE: You can define additional configuration registers in gPCIE_CfgRegs. */
const WDC_REG *gpPCIE_CfgRegs = gPCIE_CfgRegs;

/* -----------------------------------------------
    PCIE run-time registers information
   ----------------------------------------------- */
/* Run-time registers information array */
/* const WDC_REG gPCIE_Regs[]; */
const WDC_REG *gpPCIE_Regs = NULL;
/* TODO: You can remove the comment from the gPCIE_Regs array declaration and
         fill the array with run-time registers information for your device,
         in which case be sure to set gpPCIE_Regs to point to gPCIE_Regs. */
#define PCIE_REGS_NUM 0

/*************************************************************
  Static functions prototypes
 *************************************************************/
/* -----------------------------------------------
    Main diagnostics menu
   ----------------------------------------------- */
static void MenuMain(WDC_DEVICE_HANDLE *phDev, WDC_DEVICE_HANDLE *phDev1, WDC_DEVICE_HANDLE *phDev2, 
WDC_DEVICE_HANDLE *phDev3, WDC_DEVICE_HANDLE *phDev4, WDC_DEVICE_HANDLE *phDev5);

/* -----------------------------------------------
    Device find, open and close
   ----------------------------------------------- */
static WDC_DEVICE_HANDLE DeviceFindAndOpen(DWORD dwVendorId, DWORD dwDeviceId);
static BOOL DeviceFind(DWORD dwVendorId, DWORD dwDeviceId, WD_PCI_SLOT *pSlot);
static WDC_DEVICE_HANDLE DeviceOpen(const WD_PCI_SLOT *pSlot);
static void DeviceClose(WDC_DEVICE_HANDLE hDev);

/* -----------------------------------------------
    Read/write memory and I/O addresses
   ----------------------------------------------- */
static void MenuReadWriteAddr(WDC_DEVICE_HANDLE hDev);
static void SetAddrSpace(WDC_DEVICE_HANDLE hDev, PDWORD pdwAddrSpace);

/* -----------------------------------------------
    Read/write the configuration space
   ----------------------------------------------- */
static void MenuReadWriteCfgSpace(WDC_DEVICE_HANDLE hDev);

/* -----------------------------------------------
    Read/write the run-time registers
   ----------------------------------------------- */
static void MenuReadWriteRegs(WDC_DEVICE_HANDLE hDev);

/* -----------------------------------------------
    Interrupt handling
   ----------------------------------------------- */
static void MenuInterrupts(WDC_DEVICE_HANDLE hDev);
static void DiagIntHandler(WDC_DEVICE_HANDLE hDev, PCIE_INT_RESULT *pIntResult);

/* ----------------------------------------------------
    Plug-and-play and power management events handling
   ---------------------------------------------------- */
static void MenuEvents(WDC_DEVICE_HANDLE hDev);
static void DiagEventHandler(WDC_DEVICE_HANDLE hDev, DWORD dwAction);
static void Menujsebii_test(WDC_DEVICE_HANDLE hDev);

static void MenuMBtest(WDC_DEVICE_HANDLE hDev,WDC_DEVICE_HANDLE hDev1 ,WDC_DEVICE_HANDLE hDev2, 
		       WDC_DEVICE_HANDLE hDev3, WDC_DEVICE_HANDLE hDev4, WDC_DEVICE_HANDLE hDev5);

static int pcie_send(WDC_DEVICE_HANDLE hDev, int mode, int nword, UINT32 *buff_send);
static int pcie_rec(WDC_DEVICE_HANDLE hDev, int mode, int istart, int nword, int ipr_status, UINT32 *buff_rec);

static int xmit_boot(WDC_DEVICE_HANDLE hDev, int imod_xmit);
static int fem_boot(WDC_DEVICE_HANDLE hDev, int imod_fem);

static int pmt_adc_setup(WDC_DEVICE_HANDLE hDev, int imod_fem, int iframe);
static int tpc_adc_setup(WDC_DEVICE_HANDLE hDev, int imod_fem, int iframe, int itpc_adc, int ihuff, int icom_factor, int timesize);

static int fem_link_setup(WDC_DEVICE_HANDLE hDev, int imod_xmit, int imod_st, int supernova);

// PMT DMA thread functions
void *pt_trig_dma(void *threadarg);
void *pt_sn_dma(void *threadarg);
// PMT readout thread functions
static void *pt_sn_filewrite(void *nword_write);
static void *pt_trig_filewrite(void *nword_write);

// TPC DMA thread functions
void *pt_trig_dma_tpc(void *threadarg);
void *pt_sn_dma_tpc(void *threadarg);
// TPC readout thread functions
static void *pt_sn_filewrite_tpc(void *nword_write);
static void *pt_trig_filewrite_tpc(void *nword_write);

// Trigger data readout functions
void trig_module_read(WDC_DEVICE_HANDLE hDev);
void *pt_trig_read(void *threadarg);

#include "config_reader.h"

//
//     data storage
//
static int buff_snova[4000000];
static int buff_trig [4000000];
static int snova_pointer;
static int trig_pointer;
static int snova_wcount;
static int trig_wcount;
static int fd_trig_pt;
static int fd_sn_pt;
static int fd_trig_pt_m;
static int fd_monitor_pt;
//
static int fd_trig_pt_tpc;
static int fd_sn_pt_tpc;
static int fd_trig_pt_m_tpc;
static int fd_monitor_pt_tpc;
//
static DWORD dwDMABufSize;
static int itrig_m_d, itrig_m, ith_fr;

//
//#define dwDMABufSize = 1000000;
//
//
//

#define  jbuf_ev_size 1000000
pthread_mutex_t mutexlock;
static int write_point_n, read_point_n, write_point_s, read_point_s;
static int write_point_n_tpc, read_point_n_tpc, write_point_s_tpc, read_point_s_tpc;
//static int buffer_wc_n[jbuf_ev_size], buffer_wc_s[jbuf_ev_size];
static int buffer_ev_n[jbuf_ev_size], buffer_ev_s[jbuf_ev_size];
static int buffer_ev_n_tpc[jbuf_ev_size], buffer_ev_s_tpc[jbuf_ev_size];

//
//  for PMT
//
PVOID pbuf_rec_n1;
WD_DMA *pDma_rec_n1;

PVOID pbuf_rec_n2;
WD_DMA *pDma_rec_n2;


PVOID pbuf_rec_s;
WD_DMA *pDma_rec_s;
PVOID pbuf_rec_s1;
WD_DMA *pDma_rec_s1;
PVOID pbuf_rec_s2;
WD_DMA *pDma_rec_s2;
PVOID pbuf_rec_s3;
WD_DMA *pDma_rec_s3;
PVOID pbuf_rec_s4;
WD_DMA *pDma_rec_s4;
//
//  for TPC
//
PVOID pbuf_rec_n1_tpc;
WD_DMA *pDma_rec_n1_tpc;

PVOID pbuf_rec_n2_tpc;
WD_DMA *pDma_rec_n2_tpc;


PVOID pbuf_rec_s_tpc;
WD_DMA *pDma_rec_s_tpc;
PVOID pbuf_rec_s1_tpc;
WD_DMA *pDma_rec_s1_tpc;
PVOID pbuf_rec_s2_tpc;
WD_DMA *pDma_rec_s2_tpc;
PVOID pbuf_rec_s3_tpc;
WD_DMA *pDma_rec_s3_tpc;
PVOID pbuf_rec_s4_tpc;
WD_DMA *pDma_rec_s4_tpc;
//

/*************************************************************
  Functions implementation
 *************************************************************/
int main(void)
{

  struct timeval start;
  gettimeofday(&start,NULL);

  long seconds, useconds;
  seconds = start.tv_sec;
  useconds = start.tv_usec;
      
  printf("\nStart time of program: %ld sec %ld usec\n",seconds,useconds);


    WDC_DEVICE_HANDLE hDev = NULL;
    WDC_DEVICE_HANDLE hDev1 = NULL;
    WDC_DEVICE_HANDLE hDev2 = NULL;
    WDC_DEVICE_HANDLE hDev3 = NULL;
    WDC_DEVICE_HANDLE hDev4 = NULL;
    WDC_DEVICE_HANDLE hDev5 = NULL;

    DWORD dwStatus;

    printf("\n");
    printf("PCIE diagnostic utility.\n");
    printf("Application accesses hardware using " WD_PROD_NAME ".\n");

    /* Initialize the PCIE library */
    dwStatus = PCIE_LibInit();
    if (WD_STATUS_SUCCESS != dwStatus)
    {
        PCIE_ERR("pcie_diag: Failed to initialize the PCIE library: %s",
            PCIE_GetLastErr());
        return dwStatus;
    }

    /* Find and open a PCIE device (by default ID) */
    if (PCIE_DEFAULT_VENDOR_ID)
        hDev = DeviceFindAndOpen(PCIE_DEFAULT_VENDOR_ID, PCIE_DEFAULT_DEVICE_ID);
    if (PCIE_DEFAULT_VENDOR_ID)
        hDev1 = DeviceFindAndOpen(PCIE_DEFAULT_VENDOR_ID, PCIE_DEFAULT_DEVICE_ID+1);
    if (PCIE_DEFAULT_VENDOR_ID)
        hDev2 = DeviceFindAndOpen(PCIE_DEFAULT_VENDOR_ID, PCIE_DEFAULT_DEVICE_ID+2);
    if (PCIE_DEFAULT_VENDOR_ID)
        hDev3 = DeviceFindAndOpen(PCIE_DEFAULT_VENDOR_ID, PCIE_DEFAULT_DEVICE_ID+3);
    if (PCIE_DEFAULT_VENDOR_ID)
        hDev4 = DeviceFindAndOpen(PCIE_DEFAULT_VENDOR_ID, PCIE_DEFAULT_DEVICE_ID+4);
    if (PCIE_DEFAULT_VENDOR_ID)
        hDev5 = DeviceFindAndOpen(PCIE_DEFAULT_VENDOR_ID, PCIE_DEFAULT_DEVICE_ID+5);


    /* Display main diagnostics menu for communicating with the device */
    MenuMain(&hDev, &hDev1, &hDev2, &hDev3, &hDev4, &hDev5);

    /* Perform necessary cleanup before exiting the program */
    if (hDev)
        DeviceClose(hDev);
        DeviceClose(hDev1);
        DeviceClose(hDev2);
        DeviceClose(hDev3);
        DeviceClose(hDev4);
        DeviceClose(hDev5);

    dwStatus = PCIE_LibUninit();
    if (WD_STATUS_SUCCESS != dwStatus)
        PCIE_ERR("pcie_diag: Failed to uninit the PCIE library: %s", PCIE_GetLastErr());
    
    return dwStatus;
}

/* -----------------------------------------------
    Main diagnostics menu
   ----------------------------------------------- */
/* Main menu options */
enum {
    MENU_MAIN_SCAN_PCI_BUS = 1,
    MENU_MAIN_FIND_AND_OPEN,
    MENU_MAIN_RW_ADDR,
    MENU_MAIN_RW_CFG_SPACE,
    MENU_MAIN_RW_REGS,
    MENU_MAIN_ENABLE_DISABLE_INT,
    MENU_MAIN_EVENTS,
    MENU_MAIN_MB_TEST, /* add new route for testing */
    MENU_MAIN_JSEBII_TEST, /* add new route for testing */
    MENU_MAIN_EXIT = DIAG_EXIT_MENU,
};

/* Main diagnostics menu */
static void MenuMain(WDC_DEVICE_HANDLE *phDev, WDC_DEVICE_HANDLE *phDev1, WDC_DEVICE_HANDLE *phDev2, 
WDC_DEVICE_HANDLE *phDev3, WDC_DEVICE_HANDLE *phDev4, WDC_DEVICE_HANDLE *phDev5)
{
    DWORD option;
    
    do
    {
        printf("\n");
        printf("PCIE main menu\n");
        printf("--------------\n");
        printf("%d. Scan PCI bus\n", MENU_MAIN_SCAN_PCI_BUS);
        printf("%d. Find and open a PCIE device\n", MENU_MAIN_FIND_AND_OPEN);
        if (*phDev)
        {
            printf("%d. Read/write memory and IO addresses on the device\n",
                MENU_MAIN_RW_ADDR);
            printf("%d. Read/write the device's configuration space\n",
                MENU_MAIN_RW_CFG_SPACE);
            if (PCIE_REGS_NUM)
            {
                printf("%d. Read/write the run-time registers\n",
                    MENU_MAIN_RW_REGS);
            }
            printf("%d. Enable/disable the device's interrupts\n",
                MENU_MAIN_ENABLE_DISABLE_INT);
            printf("%d. Register/unregister plug-and-play and power management "
                "events\n", MENU_MAIN_EVENTS);
            printf("%d. MicroBoone test\n", MENU_MAIN_MB_TEST);
            printf("%d. Test loop for PCIe\n", MENU_MAIN_JSEBII_TEST);
        }
        printf("%d. Exit\n", MENU_MAIN_EXIT);

	/**        
        if (DIAG_INPUT_FAIL == DIAG_GetMenuOption(&option,
            *phDev ? MENU_MAIN_EVENTS : MENU_MAIN_FIND_AND_OPEN))
        {
            continue;
        }
	**/

        if (DIAG_INPUT_FAIL == DIAG_GetMenuOption(&option,
            *phDev ? MENU_MAIN_JSEBII_TEST : MENU_MAIN_FIND_AND_OPEN))
        {
            continue;
        }

        switch (option)
        {
        case MENU_MAIN_EXIT: /* Exit menu */
            break;
        case MENU_MAIN_SCAN_PCI_BUS: /* Scan PCI bus */
            WDC_DIAG_PciDevicesInfoPrintAll(FALSE);
            break;
        case MENU_MAIN_FIND_AND_OPEN: /* Find and open a PCIE device */
            if (*phDev)
                DeviceClose(*phDev);
            *phDev = DeviceFindAndOpen(0, 0);
            break;
        case MENU_MAIN_RW_ADDR: /* Read/write memory and I/O addresses */
            MenuReadWriteAddr(*phDev);
            break;
        case MENU_MAIN_RW_CFG_SPACE: /* Read/Write the PCIE configuration space */
            MenuReadWriteCfgSpace(*phDev);
            break;
        case MENU_MAIN_RW_REGS: /* Read/write the run-time registers */
            if (PCIE_REGS_NUM)
                MenuReadWriteRegs(*phDev);
            else
                printf("Invalid selection\n");
            break;
        case MENU_MAIN_ENABLE_DISABLE_INT: /* Enable/disable interrupts */
            MenuInterrupts(*phDev);
            break;
        case MENU_MAIN_EVENTS: /* Register/unregister plug-and-play and power management events */
            MenuEvents(*phDev);
            break;
        case MENU_MAIN_MB_TEST: /* my test loop DMA */
            MenuMBtest(*phDev, *phDev1, *phDev2, *phDev3, *phDev4, *phDev5);
            break;
        case MENU_MAIN_JSEBII_TEST: /* my test loop DMA */
            Menujsebii_test(*phDev);
            break;
        }
    } while (MENU_MAIN_EXIT != option);
}

/* -----------------------------------------------
    Device find, open and close
   ----------------------------------------------- */
/* Find and open a PCIE device */
static WDC_DEVICE_HANDLE DeviceFindAndOpen(DWORD dwVendorId, DWORD dwDeviceId)
{
    WD_PCI_SLOT slot;
    
    if (!DeviceFind(dwVendorId, dwDeviceId, &slot))
        return NULL;

    return DeviceOpen(&slot);
}

/* Find a PCIE device */
static BOOL DeviceFind(DWORD dwVendorId, DWORD dwDeviceId, WD_PCI_SLOT *pSlot)
{
    DWORD dwStatus;
    DWORD i, dwNumDevices;
    WDC_PCI_SCAN_RESULT scanResult;

    if (dwVendorId == 0)
    {
        if (DIAG_INPUT_SUCCESS != DIAG_InputDWORD((PVOID)&dwVendorId,
            "Enter vendor ID", TRUE, 0, 0))
        {
            return FALSE;
        }

        if (DIAG_INPUT_SUCCESS != DIAG_InputDWORD((PVOID)&dwDeviceId,
            "Enter device ID", TRUE, 0, 0))
        {
            return FALSE;
        }
    }

    BZERO(scanResult);
    dwStatus = WDC_PciScanDevices(dwVendorId, dwDeviceId, &scanResult);
    if (WD_STATUS_SUCCESS != dwStatus)
    {
        PCIE_ERR("DeviceFind: Failed scanning the PCI bus.\n"
            "Error: 0x%lx - %s\n", dwStatus, Stat2Str(dwStatus));
        return FALSE;
    }

    dwNumDevices = scanResult.dwNumDevices;
    if (!dwNumDevices)
    {
        PCIE_ERR("No matching device was found for search criteria "
            "(Vendor ID 0x%lX, Device ID 0x%lX)\n",
            dwVendorId, dwDeviceId);

        return FALSE;
    }

    printf("\n");
    printf("Found %ld matching device%s [ Vendor ID 0x%lX%s, Device ID 0x%lX%s ]:\n",
        dwNumDevices, dwNumDevices > 1 ? "s" : "",
        dwVendorId, dwVendorId ? "" : " (ALL)",
        dwDeviceId, dwDeviceId ? "" : " (ALL)");

    for (i = 0; i < dwNumDevices; i++)
    {
        printf("\n");
        printf("%2ld. Vendor ID: 0x%lX, Device ID: 0x%lX\n",
            i + 1,
            scanResult.deviceId[i].dwVendorId,
            scanResult.deviceId[i].dwDeviceId);

        WDC_DIAG_PciDeviceInfoPrint(&scanResult.deviceSlot[i], FALSE);
    }
    printf("\n");

    if (dwNumDevices > 1)
    {
        sprintf(gsInput, "Select a device (1 - %ld): ", dwNumDevices);
        i = 0;
        if (DIAG_INPUT_SUCCESS != DIAG_InputDWORD((PVOID)&i,
            gsInput, FALSE, 1, dwNumDevices))
        {
            return FALSE;
        }
    }

    *pSlot = scanResult.deviceSlot[i - 1];

    return TRUE;
}

/* Open a handle to a PCIE device */
static WDC_DEVICE_HANDLE DeviceOpen(const WD_PCI_SLOT *pSlot)
{
    WDC_DEVICE_HANDLE hDev;
    DWORD dwStatus;
    WD_PCI_CARD_INFO deviceInfo;
    
    /* Retrieve the device's resources information */
    BZERO(deviceInfo);
    deviceInfo.pciSlot = *pSlot;
    dwStatus = WDC_PciGetDeviceInfo(&deviceInfo);
    if (WD_STATUS_SUCCESS != dwStatus)
    {
        PCIE_ERR("DeviceOpen: Failed retrieving the device's resources information.\n"
            "Error 0x%lx - %s\n", dwStatus, Stat2Str(dwStatus));
        return NULL;
    }

    /* NOTE: You can modify the device's resources information here, if
       necessary (mainly the deviceInfo.Card.Items array or the items number -
       deviceInfo.Card.dwItems) in order to register only some of the resources
       or register only a portion of a specific address space, for example. */

    /* Open a handle to the device */
    hDev = PCIE_DeviceOpen(&deviceInfo);
    if (!hDev)
    {
        PCIE_ERR("DeviceOpen: Failed opening a handle to the device: %s",
            PCIE_GetLastErr());
        return NULL;
    }

    return hDev;
}

/* Close handle to a PCIE device */
static void DeviceClose(WDC_DEVICE_HANDLE hDev)
{
    if (!hDev)
        return;

    if (!PCIE_DeviceClose(hDev))
    {
        PCIE_ERR("DeviceClose: Failed closing PCIE device: %s",
            PCIE_GetLastErr());
    }
}



/* Read/write memory or I/O space address menu */
static void MenuMBtest(WDC_DEVICE_HANDLE hDev, WDC_DEVICE_HANDLE hDev1 ,WDC_DEVICE_HANDLE hDev2, 
WDC_DEVICE_HANDLE hDev3, WDC_DEVICE_HANDLE hDev4, WDC_DEVICE_HANDLE hDev5)
{

#include "wdc_defs.h"
#define poweroff      0x0
#define poweron       0x1
#define configure_s30 0x2
#define configure_s60 0x3
#define configure_cont 0x20
#define rdstatus      0x80
#define loopback        0x04

#define dcm2_run_off  254
#define dcm2_run_on   255

#define dcm2_online   2
#define dcm2_setmask  3
#define dcm2_offline_busy 4
#define dcm2_load_packet_a 10
#define dcm2_load_packet_b 11
#define dcm2_offline_load 9
#define dcm2_status_read 20
#define dcm2_led_sel     29
#define dcm2_buffer_status_read 30
#define dcm2_status_read_inbuf 21
#define dcm2_status_read_evbuf 22
#define dcm2_status_read_noevnt 23
#define dcm2_zero 12
#define dcm2_compressor_hold 31

#define dcm2_5_readdata 4
#define dcm2_5_firstdcm 8
#define dcm2_5_lastdcm  9
#define dcm2_5_status_read 5
#define dcm2_5_source_id 25
#define dcm2_5_lastchnl 24

#define dcm2_packet_id_a 25
#define dcm2_packet_id_b 26
#define dcm2_hitformat_a 27
#define dcm2_hitformat_b 28

#define part_run_off  254
#define part_run_on   255
#define part_online   2
#define part_offline_busy 3
#define part_offline_hold 4
#define part_status_read 20
#define part_source_id 25


#define  t1_tr_bar 0
#define  t2_tr_bar 4
#define  cs_bar 2

/**  command register location **/

#define  tx_mode_reg 0x28
#define  t1_cs_reg 0x18
#define  r1_cs_reg 0x1c
#define  t2_cs_reg 0x20
#define  r2_cs_reg 0x24

#define  tx_md_reg 0x28

#define  cs_dma_add_low_reg 0x0
#define  cs_dma_add_high_reg  0x4
#define  cs_dma_by_cnt 0x8
#define  cs_dma_cntrl 0xc
#define  cs_dma_msi_abort 0x10

/** define status bits **/

#define  cs_init  0x20000000
#define  cs_mode_p 0x8000000
#define  cs_mode_n 0x0
#define  cs_start 0x40000000
#define  cs_done  0x80000000

#define  dma_tr1  0x100000
#define  dma_tr2  0x200000
#define  dma_tr12 0x300000
#define  dma_3dw_trans 0x0
#define  dma_4dw_trans 0x0
#define  dma_3dw_rec   0x40
#define  dma_4dw_rec   0x60
#define  dma_in_progress 0x80000000

#define  dma_abort 0x2

#define  mb_cntrl_add     0x1
#define  mb_cntrl_test_on 0x1
#define  mb_cntrl_test_off 0x0
#define  mb_cntrl_set_run_on 0x2
#define  mb_cntrl_set_run_off 0x3
#define  mb_cntrl_set_trig1 0x4
#define  mb_cntrl_set_trig2 0x5
#define  mb_cntrl_load_frame 0x6
#define  mb_cntrl_load_trig_pos 0x7

#define  mb_feb_power_add 0x1
#define  mb_feb_conf_add 0x2
#define  mb_feb_pass_add 0x3

#define  mb_feb_lst_on          1
#define  mb_feb_lst_off         0
#define  mb_feb_rxreset         2
#define  mb_feb_align           3
#define  mb_feb_pll_reset       5


#define  mb_feb_adc_align       1
#define  mb_feb_a_nocomp        2
#define  mb_feb_b_nocomp        3
#define  mb_feb_blocksize       4
#define  mb_feb_timesize        5
#define  mb_feb_mod_number      6
#define  mb_feb_a_id            7
#define  mb_feb_b_id            8
#define  mb_feb_max             9

#define  mb_feb_test_source    10
#define  mb_feb_test_sample    11
#define  mb_feb_test_frame     12
#define  mb_feb_test_channel   13
#define  mb_feb_test_ph        14
#define  mb_feb_test_base      15
#define  mb_feb_test_ram_data  16

#define  mb_feb_a_test         17
#define  mb_feb_b_test         18

#define  mb_feb_rd_status      20

#define  mb_feb_a_rdhed        21
#define  mb_feb_a_rdbuf        22
#define  mb_feb_b_rdhed        23
#define  mb_feb_b_rdbuf        24

#define  mb_feb_read_probe     30
#define  mb_feb_dram_reset     31
#define  mb_feb_adc_reset      33

#define  mb_a_buf_status       34
#define  mb_b_buf_status       35
#define  mb_a_ham_status       36
#define  mb_b_ham_status       37

#define  mb_feb_a_maxwords     40
#define  mb_feb_b_maxwords     41

#define  mb_feb_hold_enable    42

#define  mb_pmt_adc_reset       1
#define  mb_pmt_spi_add         2
#define  mb_pmt_adc_data_load   3

#define  mb_xmit_conf_add 0x2
#define  mb_xmit_pass_add 0x3

#define  mb_xmit_modcount 0x1
#define  mb_xmit_enable_1 0x2
#define  mb_xmit_enable_2 0x3
#define  mb_xmit_test1 0x4
#define  mb_xmit_test2 0x5

#define   mb_xmit_testdata  10

#define  mb_xmit_rdstatus 20
#define  mb_xmit_rdcounters 21
#define  mb_xmit_link_reset    22
#define  mb_opt_dig_reset   23
#define  mb_xmit_dpa_fifo_reset    24
#define  mb_xmit_dpa_word_align    25
#define  mb_xmit_link_pll_reset    26

#define  mb_trig_run                1
#define  mb_trig_frame_size         2
#define  mb_trig_deadtime_size      3
#define  mb_trig_active_size        4
#define  mb_trig_delay1_size        5
#define  mb_trig_delay2_size        6
#define  mb_trig_enable             7

#define  mb_trig_calib_delay        8

#define  mb_trig_prescale0         10
#define  mb_trig_prescale1         11
#define  mb_trig_prescale2         12
#define  mb_trig_prescale3         13
#define  mb_trig_prescale4         14
#define  mb_trig_prescale5         15
#define  mb_trig_prescale6         16
#define  mb_trig_prescale7         17
#define  mb_trig_prescale8         18

#define  mb_trig_mask0             20
#define  mb_trig_mask1             21
#define  mb_trig_mask2             22
#define  mb_trig_mask3             23
#define  mb_trig_mask4             24
#define  mb_trig_mask5             25
#define  mb_trig_mask6             26
#define  mb_trig_mask7             27
#define  mb_trig_mask8             28

#define  mb_trig_rd_param          30
#define  mb_trig_pctrig            31
#define  mb_trig_rd_status         32
#define  mb_trig_reset             33
#define  mb_trig_calib             34
#define  mb_trig_rd_gps            35

#define  mb_trig_sel1              40
#define  mb_trig_sel2              41
#define  mb_trig_sel3              42
#define  mb_trig_sel4              43

#define  mb_trig_p1_delay          50
#define  mb_trig_p1_width          51
#define  mb_trig_p2_delay          52
#define  mb_trig_p2_width          53
#define  mb_trig_p3_delay          54
#define  mb_trig_p3_width          55
#define  mb_trig_pulse_delay       58
#define  mb_trig_output_select     59

#define  mb_trig_pulse1            60
#define  mb_trig_pulse2            61
#define  mb_trig_pulse3            62

#define  mb_trig_frame_trig        63

#define  mb_shaper_pulsetime        1
#define  mb_shaper_dac              2
#define  mb_shaper_pattern          3
#define  mb_shaper_write            4
#define  mb_shaper_pulse            5
#define  mb_shaper_entrig           6

#define  mb_feb_pmt_gate_size      47
#define  mb_feb_pmt_beam_delay     48
#define  mb_feb_pmt_beam_size      49

#define  mb_feb_pmt_ch_set         50
#define  mb_feb_pmt_delay0         51
#define  mb_feb_pmt_delay1         52
#define  mb_feb_pmt_precount       53
#define  mb_feb_pmt_thresh0        54
#define  mb_feb_pmt_thresh1        55
#define  mb_feb_pmt_thresh2        56
#define  mb_feb_pmt_thresh3        57
#define  mb_feb_pmt_width          58
#define  mb_feb_pmt_deadtime       59
#define  mb_feb_pmt_window         60
#define  mb_feb_pmt_words          61
#define  mb_feb_pmt_cos_mul        62
#define  mb_feb_pmt_cos_thres      63
#define  mb_feb_pmt_mich_mul       64
#define  mb_feb_pmt_mich_thres     65
#define  mb_feb_pmt_beam_mul       66
#define  mb_feb_pmt_beam_thres     67
#define  mb_feb_pmt_en_top         68
#define  mb_feb_pmt_en_upper       69
#define  mb_feb_pmt_en_lower       70
#define  mb_feb_pmt_blocksize      71

#define  mb_feb_pmt_test           80
#define  mb_feb_pmt_clear          81
#define  mb_feb_pmt_test_data      82
#define  mb_feb_pmt_pulse          83

#define  mb_feb_pmt_rxreset        84
#define  mb_feb_pmt_align_pulse    85
#define  mb_feb_pmt_rd_counters    86

#define  dma_buffer_size        40000000

    static DWORD dwAddrSpace;

    static UINT32 u32Data;
    static unsigned short u16Data;
    static unsigned long long u64Data, u64Data1;
    static DWORD dwOffset;
    static long imod,ichip;
    unsigned short *buffp;

/*
    WDC_ADDR_MODE mode;
    WDC_ADDR_RW_OPTIONS options;
*/
    static UINT32 i,j,k,ifr,nread,iprint,iwrite,ik,il,is,checksum;
    static UINT32 istop,newcmd,irand,ioffset,kword,lastchnl,ib;
    static UINT32 send_array[40000],read_array[dma_buffer_size],read_array1[40000];
    static UINT32 read_array_c[40000];
    static UINT32 read_comp[8000];
    static UINT32 nmask,index,itmp,nword_tot,nevent,iv,ijk,islow_read;
    static UINT32 imod_p,imod_trig,imod_shaper;
    unsigned short idcm_read_array[40000],read_array_s[1600000];
    static UINT32 idcm_read_array32[40000];
    static UINT32 idcm_send_array[400000];
    static UINT32 idcm_verify_array[400000];
    static int icomp_l,comp_s,ia,ic,ihuff,sample_b,dis;
    UINT32 *idcm_send_p,*idcm_verify_p,*pbuffp_rec;
//    DWORD dwDMABufSize;
    PVOID pbuf;
    WD_DMA *pDma;
    DWORD dwStatus;
    DWORD dwOptions = DMA_FROM_DEVICE;
    UINT32 iread,icheck,izero;
    UINT32 buf_send[40000];
    static int   count,num,counta,nword,ireadback,nloop,ierror;
    static int   ij,nsend,iloop,inew,idma_readback,iadd,jevent;
    static int   itest,iframe,irun,ichip_c,dummy1,itrig_c;
    static int  idup,ihold,idouble,ihold_set,istatus_read;
    static int  idone,tr_bar,t_cs_reg,r_cs_reg,dma_tr;
    static int   timesize,ipulse,ibase,a_id,itrig_delay;
    static int   iset,ncount,nsend_f,nwrite,itrig_ext;
    static int   imod_xmit,idiv,isample;
    static int   iframe_length, itrig,idrift_time,ijtrig;
    static int   idelay0, idelay1, threshold0, threshold1, pmt_words;
    static int   cos_mult, cos_thres, en_top, en_upper, en_lower;
    static int   irise, ifall, istart_time, use_pmt, pmt_testpulse;
    static int   ich_head, ich_sample, ich_frm,idebug,ntot_rec,nred;
    static int   ineu,ineu_tpc,ibusy_send,ibusy_test,ihold_word,ndma_loop;
    static int   irawprint, nwrite_byte,idis_c,idis_c1;
    static int   icomp_index, nword_comp, nk, ilast_check;
    static int   ic_ev, ic_fr, event_save, frame_save,frame_ev,event_ev;
    static int   imod_fem, imod_st, imod_last, itrig_type, itrig_type_tpc, last_dma_loop_size;
    static int   rc_pt, nword_n;
    static int   icom_factor,ifr_c2;
    static int   itrig_pulse,p1_delay,p1_width,p2_delay,p2_width, pulse_trig_delay;
    static int   isuper, isuper_tpc, ipr_trig, imonitor;
    static int   ipmt_read, itpc_read, itpc_adc, imod_xmit_tpc, imod_st_tpc,imod_last_tpc;
//
  struct timeval start;

//
    size_t stacksize;
//
//
    pthread_t threads[3];
//
    pthread_attr_t attr_pt_trig_dma, attr_pt_sn_dma;
    pthread_attr_t attr_pt_tr, attr_pt_sn;
//
    pthread_attr_t attr_pt_trig_dma_tpc, attr_pt_sn_dma_tpc;
    pthread_attr_t attr_pt_tr_tpc, attr_pt_sn_tpc;
//
    pthread_attr_t attr_pt_tr_m, attr_pt_trig_dma_m;

//
    unsigned char    charchannel;
    unsigned char    carray[4000];
    struct timespec tim, tim2;
    tim.tv_sec = 0;
    tim.tv_nsec =128000;

    //    PVOID pbuf_rec_n;
    //    WD_DMA *pDma_rec_n;
    DWORD dwOptions_rec = DMA_FROM_DEVICE | DMA_ALLOW_64BIT_ADDRESS;
    
    UINT32 *px, *py;
    
    FILE *inpf;
    
    struct thread_data
    {
      int id;
      WDC_DEVICE_HANDLE hdev;
      WDC_DEVICE_HANDLE hdevc;
    };

    struct thread_data thread_data_n;
    struct thread_data thread_data_sn;
//
    struct thread_data thread_data_n_tpc;
    struct thread_data thread_data_sn_tpc;
//
    struct thread_data thread_data_n_m;

    nread = 4096*2+6; /*16384 32768, 65536+4;  number of byte to be readout */
    ifr=0;
    iwrite =0;
    iprint =0;
    icheck =0;
    istop=0;

    dwDMABufSize = 1000000;
    
    printf(" MicroBoone TPC/PMT data taking \n");
    
    struct daq_config_t     daq_config  = get_daq_config();
    struct trigger_config_t trig_config = get_trigger_config(2);
    struct pmt_fem_config_t pmt_config  = get_pmt_fem_config(11);
    struct tpc_fem_config_t tpc_config  = get_tpc_fem_config(9);

    struct xmit_config_t    tpc_xmit_config = get_xmit_config(8);
    struct xmit_config_t    pmt_xmit_config = get_xmit_config(10);

    itrig_pulse = trig_config.param[TRIG_PULSE];
    p1_delay    = trig_config.param[TRIG_PULSE_DELAY1];
    p2_delay    = trig_config.param[TRIG_PULSE_DELAY2];
    p1_width    = trig_config.param[TRIG_PULSE_WIDTH1];
    p2_width    = trig_config.param[TRIG_PULSE_WIDTH2];

    ipmt_read   = (daq_config.param[DAQ_READOUT_PMT_NU] || 
		   daq_config.param[DAQ_READOUT_TPC_NU]   );
    ineu        = daq_config.param[DAQ_READOUT_PMT_NU];
    isuper      = daq_config.param[DAQ_READOUT_PMT_SN];

    itpc_read   = (daq_config.param[DAQ_READOUT_PMT_NU] || 
		   daq_config.param[DAQ_READOUT_TPC_NU]   );
    ineu_tpc    = daq_config.param[DAQ_READOUT_TPC_NU];
    isuper_tpc  = daq_config.param[DAQ_READOUT_TPC_SN];

    itpc_adc    = tpc_config.param[TPC_ADC_READOUT];
    ihuff       = tpc_config.param[TPC_SN_HUFFMAN];
    icom_factor = tpc_config.param[TPC_SN_COMP_FACTOR];
    timesize    = tpc_config.param[TPC_DRIFT_SIZE];

    itrig_m   = daq_config.param[DAQ_READOUT_TRIGGER];
    imonitor  = daq_config.param[DAQ_READOUT_MONITOR];

    itrig_m_d=0;

    printf(" type 1 for filewrite\n");
    scanf("%d", &ith_fr);

    imod_xmit = pmt_xmit_config.slot;
    imod_st   = pmt_config.slot;

    imod_xmit_tpc = tpc_xmit_config.slot;
    imod_st_tpc   = pmt_config.slot;

    imod_trig   = trig_config.slot;

    printf(" PMT ADC module address = %d \n", imod_fem);
    printf(" Trigger module address = %d \n", imod_trig);
    //
    //   PMT readout
    //
    itrig_type =0 ;
    if(ineu == 1) itrig_type = itrig_type + 0x1;
    if(isuper == 1) itrig_type = itrig_type + 0x2;
    //
    //   PMT readout file open
    //
    if((ith_fr ==1) & (ipmt_read ==1)) {//if writing pmt to file
      if(isuper == 1) {
	fd_sn_pt = creat("test123_pt_snova.dat",0755);
	printf("fd_sn_pt = %d\n", fd_sn_pt);
      }
      if(ineu == 1) {
	fd_trig_pt = creat("test123_pt_trig.dat",0755);
	printf("fd_trig_pt = %d\n", fd_trig_pt);
      }
      //      if(itrig_m == 1) {
      //       fd_trig_pt_m = creat("test123_pt_trig_m.dat",0755);
      //       printf("fd_trig_pt_m = %d\n", fd_trig_pt_m);
      //      }
      if(imonitor == 1) {
	fd_monitor_pt = creat("test123_pt_monitor.dat",0755);
	printf("fd_monitor_pt = %d\n", fd_monitor_pt);
      }
    }

    //
    //   TPC readout
    //
    itrig_type_tpc =0 ;
    if(ineu_tpc == 1) itrig_type_tpc = itrig_type_tpc + 0x1;
    if(isuper_tpc == 1) itrig_type_tpc = itrig_type_tpc + 0x2;
    //
    //   TPC readout file open
    //
    if((ith_fr ==1) && (itpc_read ==1)) {//if writing tpc to file
      if(isuper_tpc == 1) {
	fd_sn_pt_tpc = creat("test123_pt_snova_tpc.dat",0755);
	printf("fd_sn_pt_tpc = %d\n", fd_sn_pt_tpc);
      }
      if(ineu_tpc == 1) {
	fd_trig_pt_tpc = creat("test123_pt_trig_tpc.dat",0755);
	printf("fd_trig_pt_tpc = %d\n", fd_trig_pt_tpc);
      }
      if(imonitor == 1) {
	fd_monitor_pt_tpc = creat("test123_pt_monitor_tpc.dat",0755);
	printf("fd_monitor_pt_tpc = %d\n", fd_monitor_pt_tpc);
      }
    }
    //
    //
    //
    if(ith_fr == 1) {//if writing trig to file
      if(itrig_m == 1) {
	fd_trig_pt_m = creat("test123_pt_trig_m.dat",0755);
	printf("fd_trig_pt_m = %d\n", fd_trig_pt_m);
      }
    }
    
    
    //
    /* Initialize and set thread detached attribute */
    //
    //
    //   for PMT superNova
    //
    if((isuper == 1) && (ipmt_read==1)) {
      //
      /* Initialize and set thread detached attribute */
      //
      pthread_attr_init(&attr_pt_sn_dma);
      pthread_attr_setdetachstate(&attr_pt_sn_dma, PTHREAD_CREATE_JOINABLE);
      pthread_attr_getstacksize (&attr_pt_sn_dma, &stacksize);
      printf("SuperNova DMA defualt stack size = %li\n", stacksize);
      stacksize = 4*stacksize;
      //      printf("Amount of stack needed per thread = %li\n",stacksize);
      pthread_attr_setstacksize (&attr_pt_sn_dma, stacksize);
      //      printf("Creating threads with stack size = %li bytes\n",stacksize);
      //
      //      superNova file write thread
      //
      if(ith_fr == 1) {
	pthread_attr_init(&attr_pt_sn);
	pthread_attr_setdetachstate(&attr_pt_sn, PTHREAD_CREATE_JOINABLE);
	pthread_attr_getstacksize (&attr_pt_sn, &stacksize);
	printf("SuperNova filewrite defualt stack size = %li\n", stacksize);
	stacksize = 4*stacksize;
	//      printf("Amount of stack needed per thread = %li\n",stacksize);
	pthread_attr_setstacksize (&attr_pt_sn, stacksize);
	//      printf("Creating threads with stack size = %li bytes\n",stacksize);
	//
      }
    }
    //
    //   for PMT Neutrino
    //
    if((ineu ==1 ) & (ipmt_read==1)) {
      //
      //   neutrino data thread
      //
      pthread_attr_init(&attr_pt_trig_dma);
      pthread_attr_setdetachstate(&attr_pt_trig_dma, PTHREAD_CREATE_JOINABLE);
      //
      pthread_attr_getstacksize (&attr_pt_trig_dma, &stacksize);
      printf("Trigger Default stack size = %li\n", stacksize);
      stacksize = 4*stacksize;
      //      printf("Amount of stack needed per thread = %li\n",stacksize);
      pthread_attr_setstacksize (&attr_pt_trig_dma, stacksize);
      //      printf("Creating threads with stack size = %li bytes\n",stacksize);
      //
      //    neutrino filewrite thread
      //
      if(ith_fr == 1) {
	pthread_attr_init(&attr_pt_tr);
	pthread_attr_setdetachstate(&attr_pt_tr, PTHREAD_CREATE_JOINABLE);
	//
	pthread_attr_getstacksize (&attr_pt_tr, &stacksize);
	printf("Trigger Default stack size = %li\n", stacksize);
	stacksize = 4*stacksize;
	//      printf("Amount of stack needed per thread = %li\n",stacksize);
	pthread_attr_setstacksize (&attr_pt_tr, stacksize);
	//      printf("Creating threads with stack size = %li bytes\n",stacksize);
	//
      }
    }
    //
    //   for TPC superNova
    //
    if((isuper_tpc == 1) & (itpc_read==1)) {
      //
      /* Initialize and set thread detached attribute */
      //
      pthread_attr_init(&attr_pt_sn_dma_tpc);
      pthread_attr_setdetachstate(&attr_pt_sn_dma_tpc, PTHREAD_CREATE_JOINABLE);
      pthread_attr_getstacksize (&attr_pt_sn_dma_tpc, &stacksize);
      printf("TPC SuperNova DMA defualt stack size = %li\n", stacksize);
      stacksize = 4*stacksize;
      //      printf("Amount of stack needed per thread = %li\n",stacksize);
      pthread_attr_setstacksize (&attr_pt_sn_dma_tpc, stacksize);
      //      printf("Creating threads with stack size = %li bytes\n",stacksize);
      //
      //      superNova file write thread
      //
      if(ith_fr == 1) {
	pthread_attr_init(&attr_pt_sn_tpc);
	pthread_attr_setdetachstate(&attr_pt_sn_tpc, PTHREAD_CREATE_JOINABLE);
	pthread_attr_getstacksize (&attr_pt_sn_tpc, &stacksize);
	printf("SuperNova filewrite defualt stack size = %li\n", stacksize);
	stacksize = 4*stacksize;
	//      printf("Amount of stack needed per thread = %li\n",stacksize);
	pthread_attr_setstacksize (&attr_pt_sn_tpc, stacksize);
	//      printf("Creating threads with stack size = %li bytes\n",stacksize);
	//
      }
    }
    //
    //   for TPC Neutrino
    //
    if((ineu_tpc ==1 ) & (itpc_read==1)) {
      //
      //   neutrino data thread
      //
      pthread_attr_init(&attr_pt_trig_dma_tpc);
      pthread_attr_setdetachstate(&attr_pt_trig_dma_tpc, PTHREAD_CREATE_JOINABLE);
      //
      pthread_attr_getstacksize (&attr_pt_trig_dma_tpc, &stacksize);
      printf("Trigger Default stack size = %li\n", stacksize);
      stacksize = 4*stacksize;
      //      printf("Amount of stack needed per thread = %li\n",stacksize);
      pthread_attr_setstacksize (&attr_pt_trig_dma_tpc, stacksize);
      //      printf("Creating threads with stack size = %li bytes\n",stacksize);
      //
      //    neutrino filewrite thread
      //
      if(ith_fr == 1) {
	pthread_attr_init(&attr_pt_tr_tpc);
	pthread_attr_setdetachstate(&attr_pt_tr_tpc, PTHREAD_CREATE_JOINABLE);
	//
	pthread_attr_getstacksize (&attr_pt_tr_tpc, &stacksize);
	printf("Trigger Default stack size = %li\n", stacksize);
	stacksize = 4*stacksize;
	//      printf("Amount of stack needed per thread = %li\n",stacksize);
	pthread_attr_setstacksize (&attr_pt_tr_tpc, stacksize);
	//      printf("Creating threads with stack size = %li bytes\n",stacksize);
	//
      }
    }
    ////
    //
    
    
    

    //
    //   let trigger module read to be in the main program unless explict detach
    //
    if((itrig_m ==1) && (itrig_m_d == 1)) {
      //
      //   neutrino data thread
      //
      pthread_attr_init(&attr_pt_trig_dma_m);
      pthread_attr_setdetachstate(&attr_pt_trig_dma_m, PTHREAD_CREATE_JOINABLE);
      //
      pthread_attr_getstacksize (&attr_pt_trig_dma_m, &stacksize);
      printf("Trigger module Default stack size = %li\n", stacksize);
      stacksize = 4*stacksize;
      //      printf("Amount of stack needed per thread = %li\n",stacksize);
      pthread_attr_setstacksize (&attr_pt_trig_dma_m, stacksize);
      //      printf("Creating threads with stack size = %li bytes\n",stacksize);
      //
      //    neutrino filewrite thread
      //
      if(ith_fr == 1) {
	pthread_attr_init(&attr_pt_tr);
	pthread_attr_setdetachstate(&attr_pt_tr_m, PTHREAD_CREATE_JOINABLE);
	//
	pthread_attr_getstacksize (&attr_pt_tr_m, &stacksize);
	printf("Trigger Default stack size = %li\n", stacksize);
	stacksize = 4*stacksize;
	//      printf("Amount of stack needed per thread = %li\n",stacksize);
	pthread_attr_setstacksize (&attr_pt_tr_m, stacksize);
	//      printf("Creating threads with stack size = %li bytes\n",stacksize);
	//
      }
    }
    //
    //
    //     iframe_length = 2047;
    //     iframe_length = 25599;
    
    iframe_length = 2047;
    
    //     iframe_length = 25599;
    //     timesize = 3100;
    //     itrig_delay = 10;
    
    //     timesize =4;
    dwDMABufSize = 1000000;
    printf(" frame size = %d, timesize = %d\n",iframe_length+1, timesize);
    printf(" buffer size = %d\n", dwDMABufSize);
    iframe = iframe_length;
    
    //     printf(" 1 for checking the event \n");
    //     scanf("%d",&icheck);
    //     printf(" type 1 to use random number \n");
    //     scanf("%d",&irand);
    icheck =0;
    ifr=0;
    iprint = 1;
    //     printf(" number event \n");
    //     scanf("%d",&nevent);
    
    //     printf(" enter number of words per packet \n");
    //     scanf("%d",&nsend);
    nsend=500;
    //     imod_xmit=10;
    
    // once the fpga is booted we should let system receive fill frame before send any data.
    // set system with normal transmitter mode
    
    //
    // STEP ... PCI-E card initialization for PMT
    //
    // PMT section of busy initialization
    //
    printf("Initializing PCIE-card for PMT ... ");
    if(ipmt_read == 1) {
      dwAddrSpace =2;
      u32Data = 0x20000000;    // initial transmitter, no hold
      dwOffset = 0x18;
      WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);
      dwAddrSpace =2;
      u32Data = 0x20000000;    // initial transmitter, no hold
      dwOffset = 0x20;
      WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);
      
      dwAddrSpace =2;
      u32Data = 0x20000000;    // initial receiver
      dwOffset = 0x1c;
      WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);
      dwAddrSpace =2;
      u32Data = 0x20000000;   // initial receiver
      dwOffset = 0x24;
      WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);
      
      
      dwAddrSpace =2;
      u32Data = 0xfff;    // set mode off with 0xfff...
      dwOffset = 0x28;
      WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);
      
      dwAddrSpace =2;
      u32Data = 0x20000000;    // initial transmitter, no hold
      dwOffset = 0x18;
      WDC_WriteAddr32(hDev1, dwAddrSpace, dwOffset, u32Data);
      dwAddrSpace =2;
      u32Data = 0x20000000;    // initial transmitter, no hold
      dwOffset = 0x20;
      WDC_WriteAddr32(hDev1, dwAddrSpace, dwOffset, u32Data);
      
      dwAddrSpace =2;
      u32Data = 0x20000000;    // initial receiver
      dwOffset = 0x1c;
      WDC_WriteAddr32(hDev1, dwAddrSpace, dwOffset, u32Data);
      dwAddrSpace =2;
      u32Data = 0x20000000;   // initial receiver
      dwOffset = 0x24;
      WDC_WriteAddr32(hDev1, dwAddrSpace, dwOffset, u32Data);
      
      
      dwAddrSpace =2;
      u32Data = 0xfff;    // set mode off with 0xfff...
      dwOffset = 0x28;
      WDC_WriteAddr32(hDev1, dwAddrSpace, dwOffset, u32Data);
    }
    printf("done!\n");
    
    //
    // STEP ... PCI-E card initialization for TPC
    // TPC section of busy initialization
    //
    printf("Initializing PCIE-card for TPC ... ");
    if(itpc_read == 1) {
      dwAddrSpace =2;
      u32Data = 0x20000000;    // initial transmitter, no hold
      dwOffset = 0x18;
      WDC_WriteAddr32(hDev5, dwAddrSpace, dwOffset, u32Data);
      dwAddrSpace =2;
      u32Data = 0x20000000;    // initial transmitter, no hold
      dwOffset = 0x20;
      WDC_WriteAddr32(hDev5, dwAddrSpace, dwOffset, u32Data);
      
      dwAddrSpace =2;
      u32Data = 0x20000000;    // initial receiver
      dwOffset = 0x1c;
      WDC_WriteAddr32(hDev5, dwAddrSpace, dwOffset, u32Data);
      dwAddrSpace =2;
      u32Data = 0x20000000;   // initial receiver
      dwOffset = 0x24;
      WDC_WriteAddr32(hDev5, dwAddrSpace, dwOffset, u32Data);
      
      
      dwAddrSpace =2;
      u32Data = 0xfff;    // set mode off with 0xfff...
      dwOffset = 0x28;
      WDC_WriteAddr32(hDev5, dwAddrSpace, dwOffset, u32Data);
      
      dwAddrSpace =2;
      u32Data = 0x20000000;    // initial transmitter, no hold
      dwOffset = 0x18;
      WDC_WriteAddr32(hDev4, dwAddrSpace, dwOffset, u32Data);
      dwAddrSpace =2;
      u32Data = 0x20000000;    // initial transmitter, no hold
      dwOffset = 0x20;
      WDC_WriteAddr32(hDev4, dwAddrSpace, dwOffset, u32Data);
      
      dwAddrSpace =2;
      u32Data = 0x20000000;    // initial receiver
      dwOffset = 0x1c;
      WDC_WriteAddr32(hDev4, dwAddrSpace, dwOffset, u32Data);
      dwAddrSpace =2;
      u32Data = 0x20000000;   // initial receiver
      dwOffset = 0x24;
      WDC_WriteAddr32(hDev4, dwAddrSpace, dwOffset, u32Data);
      
      
      dwAddrSpace =2;
      u32Data = 0xfff;    // set mode off with 0xfff...
      dwOffset = 0x28;
      WDC_WriteAddr32(hDev4, dwAddrSpace, dwOffset, u32Data);
    }
    printf("done!\n");
    
    
    //
    // STEP ... PMT's controller initialization
    //
    printf("Initializing Controller module for PMT crate ... ");
    px = &buf_send;
    py = &read_array;
    
    imod =0;  /* controller module */
    /** initialize **/
    buf_send[0]=0x0;
    buf_send[1]=0x0;
    i=1;
    k=1;
    i = pcie_send(hDev, i, k, px);
    // set offline test
    imod=0;
    ichip=1;
    buf_send[0]=(imod<<11)+(ichip<<8)+(mb_cntrl_test_on)+(0x0<<16); //enable offline run on
    i=1;
    k=1;
    i = pcie_send(hDev, i, k, px);
    //disable the run command
    imod=0;
    ichip=1;
    buf_send[0]=(imod<<11)+(ichip<<8)+(mb_cntrl_set_run_off)+(0x0<<16); //trun off run
    i=1;
    k=1;
    i = pcie_send(hDev, i, k, px);
    // set offline test
    imod=0;
    ichip=1;
    buf_send[0]=(imod<<11)+(ichip<<8)+(mb_cntrl_test_off)+(0x0<<16); //set controller test off
    i=1;
    k=1;
    i = pcie_send(hDev, i, k, px);
    printf("done!\n");     
    
    //
    // STEP ... TPC controller initialization
    //
    if (itpc_read==1){
      printf("Initializing Controller module for TPC crate ... ");
      imod =0;  /* controller module */
      /** initialize **/
      buf_send[0]=0x0;
      buf_send[1]=0x0;
      i=1;
      k=1;
      i = pcie_send(hDev3, i, k, px);
      // set offline test
      imod=0;
      ichip=1;
      buf_send[0]=(imod<<11)+(ichip<<8)+(mb_cntrl_test_on)+(0x0<<16); //enable offline run on
      i=1;
      k=1;
      i = pcie_send(hDev3, i, k, px);
      //disable the run command
      imod=0;
      ichip=1;
      buf_send[0]=(imod<<11)+(ichip<<8)+(mb_cntrl_set_run_off)+(0x0<<16); //trun off run
      i=1;
      k=1;
      i = pcie_send(hDev3, i, k, px);
      // set offline test
      imod=0;
      ichip=1;
      buf_send[0]=(imod<<11)+(ichip<<8)+(mb_cntrl_test_off)+(0x0<<16); //set controller test off
      i=1;
      k=1;
      i = pcie_send(hDev3, i, k, px);
      printf("done!\n");            
    }
    
    //
    // STEP ... Initialize Trigger module & configure
    //
    //
    //  set trigger module run off
    //
    imod=imod_trig;
    buf_send[0]=(imod<<11)+(mb_trig_run)+((0x0)<<16); //set up run off
    i=1;
    k=1;
    i = pcie_send(hDev, i, k, px);
    //
    //  set trigger module dead time size
    //
    imod=imod_trig;
    buf_send[0]=(imod<<11)+(mb_trig_deadtime_size)+(0x1<<16); //set trigger module deadtime size
    i=1;
    k=1;
    i = pcie_send(hDev, i, k, px);
    //
    //  set trigger module to disable triggers
    //
    imod=imod_trig;
    buf_send[0]=(imod<<11)+(mb_trig_enable)+(0x0<<16); //disable all triggers
    i=1;
    k=1;
    i = pcie_send(hDev, i, k, px);
    //
    //
    if(itrig_pulse == 1) {
      imod = imod_trig;
      buf_send[0]=(imod<<11)+(mb_trig_output_select)+((0x1)<<16); // select test pulse output
      i=1;
      k=1;
      i = pcie_send(hDev, i, k, px);
    }
    else {
      imod = imod_trig;
      buf_send[0]=(imod<<11)+(mb_trig_output_select)+((0x2)<<16); // select test pulse output
      i=1;
      k=1;
      i = pcie_send(hDev, i, k, px);
    }
    
    
    printf("about to boot\n");
    
    //
    // STEP ... PMT FEM boot & configuration
    //
    
    //
    //    boot up xmit module 1st
    //
    printf("I made it to before xmit boot\n");
    if(ipmt_read == 1) {
      printf(" boot xmit module \n");
      inpf = fopen("/home/ub/xmit_fpga_link_header","r");
      imod=imod_xmit;
      ichip=mb_xmit_conf_add;
      buf_send[0]=(imod<<11)+(ichip<<8)+0x0+(0x0<<16);  // turn conf to be on
      i=1;
      k=1;
      i = pcie_send(hDev, i, k, px);
      //      for (i=0; i<100000; i++) {
      //          ik= i%2;
      //          dummy1= (ik+i)*(ik+i);
      //      }
      
      
      /* read data as characters (28941) */
      usleep(1000);   // wait fior a while
      count = 0;
      counta= 0;
      ichip_c = 7; // set ichip_c to stay away from any other command in the
      dummy1 =0;
      while (fread(&charchannel,sizeof(char),1,inpf)==1) {
	carray[count] = charchannel;
	count++;
	counta++;
	if((count%(nsend*2)) == 0) {
	  //        printf(" loop = %d\n",dummy1);
	  buf_send[0] = (imod <<11) +(ichip_c <<8)+ (carray[0]<<16);
	  send_array[0] =buf_send[0];
	  if(dummy1 <= 5 ) printf(" counta = %d, first word = %x, %x, %x %x %x \n",counta,buf_send[0], carray[0], carray[1]
				  ,carray[2], carray[3]);
	  for (ij=0; ij< nsend; ij++) {
	    if(ij== (nsend-1)) buf_send[ij+1] = carray[2*ij+1]+(0x0<<16);
	    else buf_send[ij+1] = carray[2*ij+1]+ (carray[2*ij+2]<<16);
	    //         buf_send[ij+1] = carray[2*ij+1]+ (carray[2*ij+2]<<16);
	    send_array[ij+1] = buf_send[ij+1];
	  }
	  nword =nsend+1;
	  i=1;
	  //       if(dummy1 == 0)
	  ij = pcie_send(hDev, i, nword, px);
	  nanosleep(&tim , &tim2);
	  dummy1 = dummy1+1;
	  count =0;
	}
      }
      if(feof(inpf)) {
	printf("You have reached the end-of-file word count= %d %d\n", counta, count);
	buf_send[0] = (imod <<11) +(ichip_c <<8)+ (carray[0]<<16);
	if ( count > 1) {
	  if( ((count-1)%2) ==0) {
	    ik =(count-1)/2;
	  }
	  else {
	    ik =(count-1)/2+1;
	  }
	  ik=ik+2;   // add one more for safety
	  printf("ik= %d\n",ik);
	  for (ij=0; ij<ik; ij++){
	    if(ij == (ik-1)) buf_send[ij+1] = carray[(2*ij)+1]+(((imod<<11)+(ichip<<8)+0x0)<<16);
	    else buf_send[ij+1] = carray[(2*ij)+1]+ (carray[(2*ij)+2]<<16);
	    send_array[ij+1] = buf_send[ij+1];
	  }
	}
	else ik=1;
	for (ij=ik-10; ij< ik+1; ij++) {
	  printf("Last data = %d, %x\n",ij,buf_send[ij]);
	}
	nword =ik+1;
	i=1;
	i = pcie_send(hDev, i, nword, px);
      }
      usleep(2000);    // wait for 2ms to cover the packet time plus fpga init time
      fclose(inpf);
      
      //
      printf(" xmit done, booting FEM \n");
      scanf("%d",&ik);
      //
      //   *********************************************************************************
      //
      
      //
      // CONFIGURATION: PMT FEM configuration called here
      //
      imod_last = imod_xmit+1;
      for (imod_fem = imod_last; imod_fem< (imod_st+1); imod_fem++) {
	printf(" booting FEM module %d \n",imod_fem);
	scanf("%d",&ik);
	ik=pmt_adc_setup(hDev,imod_fem,iframe);
      }
      
      //
      // PMT:   both FEM and XMIT bootted.
      //
      //
      
      //   /* set tx mode register */
      //
      u32Data = 0x00003fff;  // set up number of words hold coming back from the XMIT module
      printf(" number of words for hold be send back = %x\n",u32Data);
      dwOffset = 0x28;
      dwAddrSpace =2;
      WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);
      //
      //   set up hold
      //
      printf(" set up the hold condition \n");
      dwAddrSpace =2;
      u32Data = 0x8000000;    // set up transmitter to return the hold -- upper transciever
      dwOffset = 0x18;
      WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);
      dwAddrSpace =2;
      u32Data = 0x8000000;    // set up transmitter to return the hold -- lower transciever
      dwOffset = 0x20;
      WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);
      
      //
      if((ineu ==1) & (ith_fr ==1)) {
	//
	/* set tx mode register */
	//
	u32Data = 0x00003fff;  // set up number of words hold coming back from the XMIT module
	printf(" number of words for hold be send back -- trigger = %x\n",u32Data);
	dwOffset = 0x28;
	dwAddrSpace =2;
	WDC_WriteAddr32(hDev1, dwAddrSpace, dwOffset, u32Data);
	//
	//   set up hold
	//
	printf(" set up the hold condition \n");
	dwAddrSpace =2;
	u32Data = 0x8000000;    // set up transmitter to return the hold -- upper transciever
	dwOffset = 0x18;
	WDC_WriteAddr32(hDev1, dwAddrSpace, dwOffset, u32Data);
	dwAddrSpace =2;
	u32Data = 0x8000000;    // set up transmitter to return the hold -- lower transciever
	dwOffset = 0x20;
	WDC_WriteAddr32(hDev1, dwAddrSpace, dwOffset, u32Data);
      }
    }
    
    //
    // STEP ... TPC FEM boot & configuration
    //
    
    //
    //  boot up xmit module 1st
    //
    if(itpc_read == 1) {
      printf(" boot xmit module \n");
      inpf = fopen("/home/ub/xmit_fpga_link_header","r");
      imod=imod_xmit_tpc;
      ichip=mb_xmit_conf_add;
      buf_send[0]=(imod<<11)+(ichip<<8)+0x0+(0x0<<16);  // turn conf to be on
      i=1;
      k=1;
      i = pcie_send(hDev3, i, k, px);
      //      for (i=0; i<100000; i++) {
      //          ik= i%2;
      //          dummy1= (ik+i)*(ik+i);
      //      }
      
      
      /* read data as characters (28941) */
      usleep(1000);   // wait fior a while
      count = 0;
      counta= 0;
      ichip_c = 7; // set ichip_c to stay away from any other command in the
      dummy1 =0;
      while (fread(&charchannel,sizeof(char),1,inpf)==1) {
	carray[count] = charchannel;
	count++;
	counta++;
	if((count%(nsend*2)) == 0) {
	  //        printf(" loop = %d\n",dummy1);
	  buf_send[0] = (imod <<11) +(ichip_c <<8)+ (carray[0]<<16);
	  send_array[0] =buf_send[0];
	  if(dummy1 <= 5 ) printf(" counta = %d, first word = %x, %x, %x %x %x \n",counta,buf_send[0], carray[0], carray[1]
				  ,carray[2], carray[3]);
	  for (ij=0; ij< nsend; ij++) {
	    if(ij== (nsend-1)) buf_send[ij+1] = carray[2*ij+1]+(0x0<<16);
	    else buf_send[ij+1] = carray[2*ij+1]+ (carray[2*ij+2]<<16);
	    //         buf_send[ij+1] = carray[2*ij+1]+ (carray[2*ij+2]<<16);
	    send_array[ij+1] = buf_send[ij+1];
	  }
	  nword =nsend+1;
	  i=1;
	  //       if(dummy1 == 0)
	  ij = pcie_send(hDev3, i, nword, px);
	  nanosleep(&tim , &tim2);
	  dummy1 = dummy1+1;
	  count =0;
	}
      }
      if(feof(inpf)) {
	printf("You have reached the end-of-file word count= %d %d\n", counta, count);
	buf_send[0] = (imod <<11) +(ichip_c <<8)+ (carray[0]<<16);
	if ( count > 1) {
	  if( ((count-1)%2) ==0) {
	    ik =(count-1)/2;
	  }
	  else {
	    ik =(count-1)/2+1;
	  }
	  ik=ik+2;   // add one more for safety
	  printf("ik= %d\n",ik);
	  for (ij=0; ij<ik; ij++){
	    if(ij == (ik-1)) buf_send[ij+1] = carray[(2*ij)+1]+(((imod<<11)+(ichip<<8)+0x0)<<16);
	    else buf_send[ij+1] = carray[(2*ij)+1]+ (carray[(2*ij)+2]<<16);
	    send_array[ij+1] = buf_send[ij+1];
	  }
	}
	else ik=1;
	for (ij=ik-10; ij< ik+1; ij++) {
	  printf("Last data = %d, %x\n",ij,buf_send[ij]);
	 }
	nword =ik+1;
	i=1;
	i = pcie_send(hDev3, i, nword, px);
      }
      usleep(2000);    // wait for 2ms to cover the packet time plus fpga init time
      fclose(inpf);
      
      //
      printf(" TPC xmit done, booting TPC FEM \n");
      scanf("%d",&ik);
      //
      //  *********************************************************************************
      //
      
      //
      // CONFIGURATION: TPC FEM configuration done here
      //
      imod_last_tpc = imod_xmit_tpc+1;
      for (imod_fem = imod_last_tpc; imod_fem< (imod_st_tpc+1); imod_fem++) {
	printf(" booting FEM module %d \n",imod_fem);
	scanf("%d",&ik);
	ik=tpc_adc_setup(hDev3, imod_fem, iframe, itpc_adc, ihuff, icom_factor, timesize);
      }
      
      //
      // both FEM and XMIT bootted.
      //
      //
      // /* set tx mode register */
      //
      u32Data = 0x00003fff;  // set up number of words hold coming back from the XMIT module
      printf(" number of words for hold be send back = %x\n",u32Data);
      dwOffset = 0x28;
      dwAddrSpace =2;
      WDC_WriteAddr32(hDev5, dwAddrSpace, dwOffset, u32Data);
      //
      // set up hold
      //
      printf(" set up the hold condition \n");
      dwAddrSpace =2;
      u32Data = 0x8000000;    // set up transmitter to return the hold -- upper transciever
      dwOffset = 0x18;
      WDC_WriteAddr32(hDev5, dwAddrSpace, dwOffset, u32Data);
      dwAddrSpace =2;
      u32Data = 0x8000000;    // set up transmitter to return the hold -- lower transciever
      dwOffset = 0x20;
      WDC_WriteAddr32(hDev5, dwAddrSpace, dwOffset, u32Data);
      
      //
      if((ineu_tpc ==1) & (ith_fr ==1)) {
	//
	/* set tx mode register */
	//
	u32Data = 0x00003fff;  // set up number of words hold coming back from the XMIT module
	printf(" number of words for hold be send back -- trigger = %x\n",u32Data);
	dwOffset = 0x28;
	dwAddrSpace =2;
	WDC_WriteAddr32(hDev4, dwAddrSpace, dwOffset, u32Data);
	//
	//   set up hold
	//
	printf(" set up the hold condition \n");
	dwAddrSpace =2;
	u32Data = 0x8000000;    // set up transmitter to return the hold -- upper transciever
	dwOffset = 0x18;
	WDC_WriteAddr32(hDev4, dwAddrSpace, dwOffset, u32Data);
	dwAddrSpace =2;
	u32Data = 0x8000000;    // set up transmitter to return the hold -- lower transciever
	dwOffset = 0x20;
	WDC_WriteAddr32(hDev4, dwAddrSpace, dwOffset, u32Data);
      }
    }
    
    //
    // STEP ... Trigger module configuration
    //
    
    //
    //
    imod=imod_trig;
    //      iframe= 511;    //1023
    buf_send[0]=(imod<<11)+(mb_trig_frame_size)+((iframe & 0xffff)<<16); //set up frame size.
    i=1;
    k=1;
    i = pcie_send(hDev, i, k, px);
    //
    // set mask1 bit 3 high
    //
     imod=imod_trig;
     buf_send[0]=(imod<<11)+(mb_trig_mask1)+(0x8<<16); //set mask1[3] on.
     i=1;
     k=1;
     i = pcie_send(hDev, i, k, px);
     //
     // set prescale1 to 0
     //
     imod=imod_trig;
     buf_send[0]=(imod<<11)+(mb_trig_prescale1)+(0x0<<16); //set prescale1 0
     i=1;
     k=1;
     i = pcie_send(hDev, i, k, px);
     
     //
     // STEP ... XMIT LINK setup for PMT & TPC
     // PMT link setup
     //
     if(ipmt_read == 1) {
       printf(" call pmt_link \n");
       ik = fem_link_setup(hDev,imod_xmit,imod_st,0);      // no supernova
       //
       // enable Neutrino/superNova Token Passing
       //
       printf(" trigger type = %d \n", itrig_type);
       imod=imod_xmit;
       ichip=3;
       if((itrig_type & 0x1) == 1) buf_send[0]=(imod<<11)+(ichip<<8)+mb_xmit_enable_1+(0x1<<16);  // enable token 1 pass
       else buf_send[0]=(imod<<11)+(ichip<<8)+mb_xmit_enable_1+(0x0<<16);  // disable token 1 pass
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);
       //
       if((itrig_type & 0x2) == 2) buf_send[0]=(imod<<11)+(ichip<<8)+mb_xmit_enable_2+(0x1<<16);  // enable token 2 pass
       else buf_send[0]=(imod<<11)+(ichip<<8)+mb_xmit_enable_2+(0x0<<16);  // enable token 2 pass
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);
     }

     //
     // STEP ... XMIT LINK setup for PMT & TPC
     // TPC link setup
     //
     if(itpc_read == 1) {
       printf(" call tpc_link \n");
       ik = fem_link_setup(hDev3,imod_xmit_tpc,imod_st_tpc,0);      // no supernova
       //
       // enable Neutrino/superNova Token Passing
       //
       printf(" trigger type = %d \n", itrig_type);
       imod=imod_xmit_tpc;
       ichip=3;
       if((itrig_type & 0x1) == 1) buf_send[0]=(imod<<11)+(ichip<<8)+mb_xmit_enable_1+(0x1<<16);  // enable token 1 pass
       else buf_send[0]=(imod<<11)+(ichip<<8)+mb_xmit_enable_1+(0x0<<16);  // disable token 1 pass
       i=1;
       k=1;
       i = pcie_send(hDev3, i, k, px);
       //
       if((itrig_type & 0x2) == 2) buf_send[0]=(imod<<11)+(ichip<<8)+mb_xmit_enable_2+(0x1<<16);  // enable token 2 pass
       else buf_send[0]=(imod<<11)+(ichip<<8)+mb_xmit_enable_2+(0x0<<16);  // enable token 2 pass
       i=1;
       k=1;
       i = pcie_send(hDev3, i, k, px);
     }

     //
     // STEP ... Memory buffer allocation for PMT & TPC
     //
     if(ipmt_read == 1) {
       printf(" buffer allocation --- Neutrino 1\n");
       dwStatus = WDC_DMAContigBufLock(hDev1, &pbuf_rec_n1, dwOptions_rec, dwDMABufSize, &pDma_rec_n1);
       if (WD_STATUS_SUCCESS != dwStatus) {
	 printf("Failed locking a Neutrino Rec Contiguous DMA buffer 1. Error 0x%lx - %s\n", dwStatus, Stat2Str(dwStatus));
	 printf("enter 1 to continue \n");
	 scanf("%d",&is);
       }
       else {
	 u32Data = pDma_rec_n1->Page->pPhysicalAddr & 0xffffffff;
	 printf(" buffer allocation 1 lower address = %x\n", u32Data);
	 u32Data = (pDma_rec_n1->Page->pPhysicalAddr >> 32) & 0xffffffff;
	 printf(" buffer allocation 1 higher address = %x\n", u32Data);
       }
       //
       // allocate Neutrino buffer 2
       //
       printf(" buffer allocation --- Neutrino 2\n");
       dwStatus = WDC_DMAContigBufLock(hDev1, &pbuf_rec_n2, dwOptions_rec, dwDMABufSize, &pDma_rec_n2);
       if (WD_STATUS_SUCCESS != dwStatus) {
	 printf("Failed locking a Neutrino Rec Contiguous DMA buffer 2. Error 0x%lx - %s\n", dwStatus, Stat2Str(dwStatus));
	 printf("enter 1 to continue \n");
	 scanf("%d",&is);
       }
       else {
	 u32Data = pDma_rec_n2->Page->pPhysicalAddr & 0xffffffff;
	 printf(" buffer allocation lower address = %x\n", u32Data);
	 u32Data = (pDma_rec_n2->Page->pPhysicalAddr >> 32) & 0xffffffff;
	 printf(" buffer allocation higher address = %x\n", u32Data);
       }
       //
       // set up the Neutrino data stream PCIe mode and reset DMA
       //
       /* set tx mode register */
       
       u32Data = 0x00002000;
       dwOffset = tx_md_reg;
       dwAddrSpace =cs_bar;
       WDC_WriteAddr32(hDev1, dwAddrSpace, dwOffset, u32Data);
       
       /* write this will abort previous DMA */
       dwAddrSpace =2;
       dwOffset = cs_dma_msi_abort;
       u32Data = dma_abort;
       WDC_WriteAddr32(hDev1, dwAddrSpace, dwOffset, u32Data);
       /* clear DMA register after the abort */
       dwAddrSpace =2;
       dwOffset = cs_dma_msi_abort;
       u32Data = 0;
       WDC_WriteAddr32(hDev1, dwAddrSpace, dwOffset, u32Data);
       printf(" initial abort finished \n");
       //
       // allocate SuperNova buffer 1
       //
       printf(" buffer allocation --- SuperNova 1\n");
       dwStatus = WDC_DMAContigBufLock(hDev2, &pbuf_rec_s1, dwOptions_rec, dwDMABufSize, &pDma_rec_s1);
       if (WD_STATUS_SUCCESS != dwStatus) {
	 printf("Failed locking a SuperNova Receive Contiguous DMA buffer 1. Error 0x%lx - %s\n", dwStatus, Stat2Str(dwStatus));
	 printf("enter 1 to continue \n");
	 scanf("%d",&is);
       }
       else {
	 u32Data = pDma_rec_s1->Page->pPhysicalAddr & 0xffffffff;
	 printf(" buffer allocation s 1 lower address = %x\n", u32Data);
	 u32Data = (pDma_rec_s1->Page->pPhysicalAddr >> 32) & 0xffffffff;
	 printf(" buffer allocation s 1 higher address = %x\n", u32Data);
       }
       //
       // allocate SuperNova buffer 2
       //
       printf(" buffer allocation --- SuperNova 2\n");
       dwStatus = WDC_DMAContigBufLock(hDev2, &pbuf_rec_s2, dwOptions_rec, dwDMABufSize, &pDma_rec_s2);
       if (WD_STATUS_SUCCESS != dwStatus) {
	 printf("Failed locking a SuperNova Receive Contiguous DMA buffer 2. Error 0x%lx - %s\n", dwStatus, Stat2Str(dwStatus));
	 printf("enter 1 to continue \n");
	 scanf("%d",&is);
       }
       else {
	 u32Data = pDma_rec_s2->Page->pPhysicalAddr & 0xffffffff;
	 printf(" buffer allocation s 2 lower address = %x\n", u32Data);
	 u32Data = (pDma_rec_s2->Page->pPhysicalAddr >> 32) & 0xffffffff;
	 printf(" buffer allocation s 2 higher address = %x\n", u32Data);
       }
       //
       // allocate SuperNova buffer 3
       //
       printf(" buffer allocation --- SuperNova 3\n");
       dwStatus = WDC_DMAContigBufLock(hDev2, &pbuf_rec_s3, dwOptions_rec, dwDMABufSize, &pDma_rec_s3);
       if (WD_STATUS_SUCCESS != dwStatus) {
	 printf("Failed locking a SuperNova Receive Contiguous DMA buffer 3. Error 0x%lx - %s\n", dwStatus, Stat2Str(dwStatus));
	 printf("enter 1 to continue \n");
	 scanf("%d",&is);
       }
       else {
	 u32Data = pDma_rec_s3->Page->pPhysicalAddr & 0xffffffff;
	 printf(" buffer allocation s 3 lower address = %x\n", u32Data);
	 u32Data = (pDma_rec_s3->Page->pPhysicalAddr >> 32) & 0xffffffff;
	 printf(" buffer allocation s 3 higher address = %x\n", u32Data);
       }
       //
       // allocate SuperNova buffer 4
       //
       printf(" buffer allocation --- SuperNova 4\n");
       dwStatus = WDC_DMAContigBufLock(hDev2, &pbuf_rec_s4, dwOptions_rec, dwDMABufSize, &pDma_rec_s4);
       if (WD_STATUS_SUCCESS != dwStatus) {
	 printf("Failed locking a SuperNova Receive Contiguous DMA buffer 4. Error 0x%lx - %s\n", dwStatus, Stat2Str(dwStatus));
	 printf("enter 1 to continue \n");
	 scanf("%d",&is);
       }
       else {
	 u32Data = pDma_rec_s4->Page->pPhysicalAddr & 0xffffffff;
	 printf(" buffer allocation s 4 lower address = %x\n", u32Data);
	 u32Data = (pDma_rec_s4->Page->pPhysicalAddr >> 32) & 0xffffffff;
	 printf(" buffer allocation s 4 higher address = %x\n", u32Data);
       }
       //
       // set up the SuperNova data stream PCIe mode and reset DMA
       //
       /* set tx mode register */
       
       u32Data = 0x00002000;
       dwOffset = tx_md_reg;
       dwAddrSpace =cs_bar;
       WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);
       
       /* write this will abort previous DMA */
       dwAddrSpace =2;
       dwOffset = cs_dma_msi_abort;
       u32Data = dma_abort;
       WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);
       /* clear DMA register after the abort */
       dwAddrSpace =2;
       dwOffset = cs_dma_msi_abort;
       u32Data = 0;
       WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);
       printf(" initial abort finished \n");
     }
     //
     // allocate Neutrino Buffer 1 for TPC
     //
     if(itpc_read == 1) {
       printf(" TPC buffer allocation --- Neutrino 1\n");
       dwStatus = WDC_DMAContigBufLock(hDev4, &pbuf_rec_n1_tpc, dwOptions_rec, dwDMABufSize, &pDma_rec_n1_tpc);
       if (WD_STATUS_SUCCESS != dwStatus) {
	 printf("TPC - Failed locking a Neutrino Rec Contiguous DMA buffer 1. Error 0x%lx - %s\n", dwStatus, Stat2Str(dwStatus));
	 printf("enter 1 to continue \n");
	 scanf("%d",&is);
       }
       else {
	 u32Data = pDma_rec_n1_tpc->Page->pPhysicalAddr & 0xffffffff;
	 printf(" buffer allocation 1 lower address = %x\n", u32Data);
	 u32Data = (pDma_rec_n1_tpc->Page->pPhysicalAddr >> 32) & 0xffffffff;
	 printf(" buffer allocation 1 higher address = %x\n", u32Data);
       }
       //
       //  allocate Neutrino buffer 2
       //
       printf(" TPC buffer allocation --- Neutrino 2\n");
       dwStatus = WDC_DMAContigBufLock(hDev4, &pbuf_rec_n2_tpc, dwOptions_rec, dwDMABufSize, &pDma_rec_n2_tpc);
       if (WD_STATUS_SUCCESS != dwStatus) {
	 printf("TPC - Failed locking a Neutrino Rec Contiguous DMA buffer 2. Error 0x%lx - %s\n", dwStatus, Stat2Str(dwStatus));
	 printf("enter 1 to continue \n");
	 scanf("%d",&is);
       }
       else {
	 u32Data = pDma_rec_n2_tpc->Page->pPhysicalAddr & 0xffffffff;
	 printf(" buffer allocation lower address = %x\n", u32Data);
	 u32Data = (pDma_rec_n2_tpc->Page->pPhysicalAddr >> 32) & 0xffffffff;
	 printf(" buffer allocation higher address = %x\n", u32Data);
       }
       //
       // set up the Neutrino data stream PCIe mode and reset DMA
       //
       /* set tx mode register */
       
       u32Data = 0x00002000;
       dwOffset = tx_md_reg;
       dwAddrSpace =cs_bar;
       WDC_WriteAddr32(hDev4, dwAddrSpace, dwOffset, u32Data);
       
       /* write this will abort previous DMA */
       dwAddrSpace =2;
       dwOffset = cs_dma_msi_abort;
       u32Data = dma_abort;
       WDC_WriteAddr32(hDev4, dwAddrSpace, dwOffset, u32Data);
       /* clear DMA register after the abort */
       dwAddrSpace =2;
       dwOffset = cs_dma_msi_abort;
       u32Data = 0;
       WDC_WriteAddr32(hDev4, dwAddrSpace, dwOffset, u32Data);
       printf(" initial abort finished \n");
       //
       // allocate SuperNova buffer 1
       //
       printf(" TPC buffer allocation --- SuperNova 1\n");
       dwStatus = WDC_DMAContigBufLock(hDev5, &pbuf_rec_s1_tpc, dwOptions_rec, dwDMABufSize, &pDma_rec_s1_tpc);
       if (WD_STATUS_SUCCESS != dwStatus) {
	 printf(" TPC Failed locking a SuperNova Receive Contiguous DMA buffer 1. Error 0x%lx - %s\n", dwStatus, Stat2Str(dwStatus));
	 printf("enter 1 to continue \n");
	 scanf("%d",&is);
       }
      else {
	u32Data = pDma_rec_s1_tpc->Page->pPhysicalAddr & 0xffffffff;
	printf(" buffer allocation s 1 lower address = %x\n", u32Data);
	u32Data = (pDma_rec_s1_tpc->Page->pPhysicalAddr >> 32) & 0xffffffff;
	printf(" buffer allocation s 1 higher address = %x\n", u32Data);
      }
       //
       // allocate SuperNova buffer 2
       //
       printf(" TPC buffer allocation --- SuperNova 2\n");
       dwStatus = WDC_DMAContigBufLock(hDev5, &pbuf_rec_s2_tpc, dwOptions_rec, dwDMABufSize, &pDma_rec_s2_tpc);
       if (WD_STATUS_SUCCESS != dwStatus) {
	 printf("Failed locking a SuperNova Receive Contiguous DMA buffer 2. Error 0x%lx - %s\n", dwStatus, Stat2Str(dwStatus));
	 printf("enter 1 to continue \n");
	 scanf("%d",&is);
       }
       else {
	 u32Data = pDma_rec_s2_tpc->Page->pPhysicalAddr & 0xffffffff;
	 printf(" buffer allocation s 2 lower address = %x\n", u32Data);
	 u32Data = (pDma_rec_s2_tpc->Page->pPhysicalAddr >> 32) & 0xffffffff;
	 printf(" buffer allocation 2 higher address = %x\n", u32Data);
       }
       //
       // allocate SuperNova buffer 3
       //
       printf(" TPC buffer allocation --- SuperNova 3\n");
       dwStatus = WDC_DMAContigBufLock(hDev5, &pbuf_rec_s3_tpc, dwOptions_rec, dwDMABufSize, &pDma_rec_s3_tpc);
       if (WD_STATUS_SUCCESS != dwStatus) {
	 printf("Failed locking a SuperNova Receive Contiguous DMA buffer 3. Error 0x%lx - %s\n", dwStatus, Stat2Str(dwStatus));
	 printf("enter 1 to continue \n");
	 scanf("%d",&is);
       }
       else {
	 u32Data = pDma_rec_s3_tpc->Page->pPhysicalAddr & 0xffffffff;
	 printf(" buffer allocation s 3 lower address = %x\n", u32Data);
	 u32Data = (pDma_rec_s3_tpc->Page->pPhysicalAddr >> 32) & 0xffffffff;
	 printf(" buffer allocation s 3 higher address = %x\n", u32Data);
       }
       //
       // allocate SuperNova buffer 4
       //
       printf(" TPC buffer allocation --- SuperNova 4\n");
       dwStatus = WDC_DMAContigBufLock(hDev5, &pbuf_rec_s4_tpc, dwOptions_rec, dwDMABufSize, &pDma_rec_s4_tpc);
       if (WD_STATUS_SUCCESS != dwStatus) {
	 printf("Failed locking a SuperNova Receive Contiguous DMA buffer 4. Error 0x%lx - %s\n", dwStatus, Stat2Str(dwStatus));
	 printf("enter 1 to continue \n");
	 scanf("%d",&is);
       }
       else {
	 u32Data = pDma_rec_s4_tpc->Page->pPhysicalAddr & 0xffffffff;
	 printf(" buffer allocation s 4 lower address = %x\n", u32Data);
	 u32Data = (pDma_rec_s4_tpc->Page->pPhysicalAddr >> 32) & 0xffffffff;
	 printf(" buffer allocation s 4 higher address = %x\n", u32Data);
       }
       //
       // set up the SuperNova data stream PCIe mode and reset DMA
       //
       /* set tx mode register */
       
       u32Data = 0x00002000;
       dwOffset = tx_md_reg;
       dwAddrSpace =cs_bar;
       WDC_WriteAddr32(hDev5, dwAddrSpace, dwOffset, u32Data);
       
       /* write this will abort previous DMA */
       dwAddrSpace =2;
       dwOffset = cs_dma_msi_abort;
       u32Data = dma_abort;
       WDC_WriteAddr32(hDev5, dwAddrSpace, dwOffset, u32Data);
       /* clear DMA register after the abort */
       dwAddrSpace =2;
       dwOffset = cs_dma_msi_abort;
       u32Data = 0;
       WDC_WriteAddr32(hDev5, dwAddrSpace, dwOffset, u32Data);
       printf(" initial abort finished \n");
     }
     
     //
     // STEP ...  Set up the trigger module readback
     //
     if((itrig_m == 1) & (itrig_m_d !=1)) {
       //
       // initalize transmitter mode register...
       dwAddrSpace =2;
       u32Data = 0xf0000008;
       dwOffset = tx_mode_reg;
       WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
       
       
       /*initialize the receiver */
       dwAddrSpace =cs_bar;
       u32Data = cs_init;
       dwOffset = r2_cs_reg;
       WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
       //
       //
       /* write byte count **/
       dwAddrSpace =cs_bar;
       u32Data = cs_start+0xffffff;
       dwOffset = r2_cs_reg;
       WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
       
       //
       
       if(ipr_trig ==1) {
	 dwAddrSpace =cs_bar;
	 u64Data =0;
	 dwOffset = t2_cs_reg;
	 WDC_ReadAddr64(hDev, dwAddrSpace, dwOffset, &u64Data);
	 printf (" status word before read = %x, %x \n",(u64Data>>32), (u64Data &0xffff));
       }
     }

     //
     // STEP ... PMT thread start
     //
     if(ipmt_read == 1) {
       if(ineu == 1) {
	 thread_data_n.id = 0;
	 thread_data_n.hdev = hDev1;
	 thread_data_n.hdevc = hDev;
	 rc_pt = pthread_create(&threads[0], &attr_pt_trig_dma, pt_trig_dma, (void *)&thread_data_n);
	 if(rc_pt) printf("PMT ERROR; return code from pthread_create() for pt_trig_DMA is %d\n", rc_pt);
	 //
	 if(ith_fr == 1) {
	   rc_pt = pthread_create(&threads[0], &attr_pt_tr, pt_trig_filewrite, (void *)nword_n);
	   if(rc_pt) printf("PMT ERROR; return code from pthread_create() for trig_filewrite is %d\n", rc_pt);
	 }
       }
       //
       //
       //
       if(isuper ==1 ) {
	 thread_data_sn.id = 1;
	 thread_data_sn.hdev = hDev2;
	 thread_data_sn.hdevc = hDev;
	 //       printf("\nReceived event notification (device handle 0x%p): ", hDev);
	 rc_pt = pthread_create(&threads[0], &attr_pt_sn_dma, pt_sn_dma, (void *)&thread_data_sn);
	 if(rc_pt) printf("PMT ERROR; return code from pthread_create() for pt_sn_dma is %d\n", rc_pt);
	 //
	 if(ith_fr == 1) {
	   rc_pt = pthread_create(&threads[0], &attr_pt_sn, pt_sn_filewrite, (void *)nword_n);
	   if(rc_pt) printf("PMT ERROR; return code from pthread_create() for sn_filewrite is %d\n", rc_pt);
	 }
       }
     }

     //
     // STEP ... TPC thread setup
     //
     if(itpc_read == 1) {
       if(ineu_tpc == 1) {
	 thread_data_n_tpc.id = 0;
	 thread_data_n_tpc.hdev = hDev4;
	 thread_data_n_tpc.hdevc = hDev;
	 rc_pt = pthread_create(&threads[0], &attr_pt_trig_dma_tpc, pt_trig_dma_tpc, (void *)&thread_data_n_tpc);
	 if(rc_pt) printf("TPC ERROR; return code from pthread_create() for pt_trig_DMA_tpc is %d\n", rc_pt);
	 //
	 if(ith_fr == 1) {
	   rc_pt = pthread_create(&threads[0], &attr_pt_tr_tpc, pt_trig_filewrite_tpc, (void *)nword_n);
	   if(rc_pt) printf("TPC ERROR; return code from pthread_create() for trig_filewrite_tpc is %d\n", rc_pt);
	 }
       }
       //
       //
       //
       if(isuper_tpc ==1 ) {
	 thread_data_sn_tpc.id = 1;
	 thread_data_sn_tpc.hdev = hDev5;
	 thread_data_sn_tpc.hdevc = hDev;
	 //       printf("\nReceived event notification (device handle 0x%p): ", hDev);
	 rc_pt = pthread_create(&threads[0], &attr_pt_sn_dma_tpc, pt_sn_dma_tpc, (void *)&thread_data_sn_tpc);
	 if(rc_pt) printf("TPC ERROR; return code from pthread_create() for pt_sn_dma_tpc is %d\n", rc_pt);
	 //
	 if(ith_fr == 1) {
	   rc_pt = pthread_create(&threads[0], &attr_pt_sn_tpc, pt_sn_filewrite_tpc, (void *)nword_n);
	   if(rc_pt) printf("TPC ERROR; return code from pthread_create() for sn_filewrite_tpc is %d\n", rc_pt);
	 }
       }
     }

     //
     // STEP ... if requested to detach trigger monitor, do so
     //
     if((itrig_m == 1) & (itrig_m_d ==1)) {
       thread_data_n_m.id = 2;
       thread_data_n_m.hdev = hDev3;
       thread_data_n_m.hdevc = hDev;
       printf("\nReceived event notification (device handle 0x%p): ", hDev);
       rc_pt = pthread_create(&threads[0], &attr_pt_trig_dma_m, pt_trig_read, (void *)&thread_data_n_m);
       if(rc_pt) printf("ERROR; return code from pthread_create() for pt_sn_dma is %d\n", rc_pt);
     }
     usleep(1000000);

     ////////////////////////////////////////////////
     //  CONFIGURATION done and ready to start run //
     ////////////////////////////////////////////////

     //
     // STEP ... enable Trigger
     // Enable RUN
     imod=imod_trig;
     buf_send[0]=(imod<<11)+(mb_trig_run)+((0x1)<<16); //set up run
     i=1;
     k=1;
     i = pcie_send(hDev, i, k, px);

     usleep(6400);          // 6.4ms
     //
     // Enable BITS
     //
     imod=imod_trig;
     buf_send[0]=(imod<<11)+(mb_trig_enable)+(0x1<<16); //enable all triggers
     i=1;
     k=1;
     i = pcie_send(hDev, i, k, px);
     
     //
     // STEP ... send a trigger-pulse (if needed) before event loop
     //
     if(itrig_pulse == 1) {
       imod = imod_trig;
       buf_send[0]=(imod<<11)+(mb_trig_p1_delay)+((p1_delay)<<16); // set up p1 delay;
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);
       
       imod = imod_trig;
       buf_send[0]=(imod<<11)+(mb_trig_p1_width)+((p1_width)<<16); // set up p1 width;
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);

       imod = imod_trig;
       buf_send[0]=(imod<<11)+(mb_trig_p2_delay)+((p2_delay)<<16); // set up p1 delay;
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);

       imod = imod_trig;
       buf_send[0]=(imod<<11)+(mb_trig_p2_width)+((p2_width)<<16); // set up p1 width;
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);

       imod = imod_trig;
       buf_send[0]=(imod<<11)+(mb_trig_pulse_delay)+((pulse_trig_delay)<<16); // set up triger delay;
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);



       usleep(10);

       imod = imod_trig;
       buf_send[0]=(imod<<11)+(mb_trig_pulse1)+((0x1)<<16); // fire pulse 1;
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);
       //
       //
       usleep(1000);
       printf(" sent trigger pulse \n");
     }

     //
     //
     //
     while (1) {
       
       //
       // LOOP-STEP ... Send Trigger module pulse
       //
       if(itrig_pulse == 1) {
	 imod = imod_trig;
	 buf_send[0]=(imod<<11)+(mb_trig_p1_delay)+((p1_delay)<<16); // set up p1 delay;
	 i=1;
	 k=1;
	 i = pcie_send(hDev, i, k, px);
	 
	 imod = imod_trig;
	 buf_send[0]=(imod<<11)+(mb_trig_p1_width)+((p1_width)<<16); // set up p1 width;
	 i=1;
	 k=1;
	 i = pcie_send(hDev, i, k, px);
	 
	 imod = imod_trig;
	 buf_send[0]=(imod<<11)+(mb_trig_p2_delay)+((p2_delay)<<16); // set up p1 delay;
	 i=1;
	 k=1;
	 i = pcie_send(hDev, i, k, px);
	 
	 imod = imod_trig;
	 buf_send[0]=(imod<<11)+(mb_trig_p2_width)+((p2_width)<<16); // set up p1 width;
	 i=1;
	 k=1;
	 i = pcie_send(hDev, i, k, px);
	 
	 imod = imod_trig;
	 buf_send[0]=(imod<<11)+(mb_trig_pulse_delay)+((pulse_trig_delay)<<16); // set up triger delay;
	 i=1;
	 k=1;
	 i = pcie_send(hDev, i, k, px);

	 usleep(10);
	 
	 imod = imod_trig;
	 buf_send[0]=(imod<<11)+(mb_trig_pulse1)+((0x1)<<16); // fire pulse 1;
	 i=1;
	 k=1;
	 i = pcie_send(hDev, i, k, px);
	 //
	 //
	 usleep(1000);
	 printf(" sent trigger pulse \n");
       }
       //
       
       iprint =0;
       usleep(100000);

       //
       // LOOP-STEP Readout Frame/Event/Word Count Monitor
       //
       if(imonitor == 1) {
	 nword =5 ;
	 //
	 // PMT Frame/Event/Word Count Monitor
	 //
	 if(ipmt_read == 1) {
	   i = pcie_rec(hDev,0,1,nword,iprint,py);     // init the receiver
	   imod=imod_xmit;
	   ichip=3;
	   buf_send[0]=(imod<<11)+(ichip<<8)+mb_xmit_rdcounters+(0x0<<16);  // read out status
	   i=1;
	   k=1;
	   i = pcie_send(hDev, i, k, px);
	   py = &read_array;
	   usleep(100);
	   i = pcie_rec(hDev,0,2,nword,iprint,py);     // read out 5 32 bits words

	   // print out if file-write is not set
	   if(ith_fr != 1) {
	     printf("PMT &&&&&&&&&&&&&&&&&&  \n");
	     printf("buffer status word = %x, %x, %x, %x, %x\n", read_array[0], read_array[1],
		    read_array[2], read_array[3], read_array[4]);
	     printf(" crate %d, header %x \n",(read_array[0] & 0x1f) ,((read_array[0] >> 8) & 0xff));
	     printf(" frame count %d \n", read_array[1]);
	     printf(" event count %d \n", read_array[2]);
	     printf(" neutrino read count %d \n", read_array[3]);
	     printf(" supernova read count %d \n", read_array[4]);
	   }
	   else {
	     read_array1[0] = 4*9;   // 4 bytes * 9 word;
	     i = write(fd_monitor_pt, read_array1, 4);
	     gettimeofday(&start,NULL);
	     read_array1[0] = start.tv_sec;
	     read_array1[1] = start.tv_usec;
	     read_array1[2] = imod;
	     read_array1[3] = mb_xmit_rdcounters;
	     read_array1[4] = read_array[0];
	     read_array1[5] = read_array[1];
	     read_array1[6] = read_array[2];
	     read_array1[7] = read_array[3];
	     read_array1[8] = read_array[4];
	     i = write(fd_monitor_pt, read_array1, 36);
	   }
	 }
	 //
	 // TPC Frame/Event/Word Count Monitor
	 //
	 if(itpc_read == 1) {
	   i = pcie_rec(hDev3,0,1,nword,iprint,py);     // init the receiver
	   imod=imod_xmit_tpc;
	   ichip=3;
	   buf_send[0]=(imod<<11)+(ichip<<8)+mb_xmit_rdcounters+(0x0<<16);  // read out status
	   i=1;
	   k=1;
	   i = pcie_send(hDev3, i, k, px);
	   py = &read_array;
	   usleep(100);
	   i = pcie_rec(hDev3,0,2,nword,iprint,py);     // read out 2 32 bits words
	   //
	   if(ith_fr != 1) {
	     printf("TPC &&&&&&&&&&&&&&&&&& \n");
	     printf("buffer status word = %x, %x, %x, %x, %x\n", read_array[0], read_array[1],
		    read_array[2], read_array[3], read_array[4]);
	     printf(" crate %d, header %x \n",(read_array[0] & 0x1f) ,((read_array[0] >> 8) & 0xff));
	     printf(" frame count %d \n", read_array[1]);
	     printf(" event count %d \n", read_array[2]);
	     printf(" neutrino read count %d \n", read_array[3]);
	     printf(" supernova read count %d \n", read_array[4]);
	   }
	   else {
	     read_array1[0] = 4*9;   // 4 bytes * 9 word;
	     i = write(fd_monitor_pt_tpc, read_array1, 4);
	     gettimeofday(&start,NULL);
	     read_array1[0] = start.tv_sec;
	     read_array1[1] = start.tv_usec;
	     read_array1[2] = imod;
	     read_array1[3] = mb_xmit_rdcounters;
	     read_array1[4] = read_array[0];
	     read_array1[5] = read_array[1];
	     read_array1[6] = read_array[2];
	     read_array1[7] = read_array[3];
	     read_array1[8] = read_array[4];
	     i = write(fd_monitor_pt_tpc, read_array1, 36);
	   }
	 }
       }
       else usleep(1000);

       //
       // LOOP-STEP ... readout Trigger data (if detached) after COUNTER MONITOR
       //
       if((itrig_m == 1) & (itrig_m_d != 1)) {
	 trig_module_read(hDev);
       }

       //
       // LOOP-STEP ... Readout electronics status monitor
       //
       if(imonitor == 1) {

	 //
	 // PMT electronics status
	 //
	 if(ipmt_read == 1) {
	   nword =1 ;
	   i = pcie_rec(hDev,0,1,nword,iprint,py);     // init the receiver
	   imod=imod_xmit;
	   ichip=3;
	   buf_send[0]=(imod<<11)+(ichip<<8)+mb_xmit_rdstatus+(0x0<<16);  // read out status
	   i=1;
	   k=1;
	   i = pcie_send(hDev, i, k, px);
	   usleep(10);
	   py = &read_array;
	   i = pcie_rec(hDev,0,2,nword,iprint,py);     // read out 2 32 bits words
	   if(ith_fr != 1) {
	     printf("PMT &&&&&&&&&&&&&&&&&&  \n");
	     printf("buffer status word = %x\n", read_array[0]);
	     printf(" crate %d, header %x \n",(read_array[0] & 0x1f) ,((read_array[0] >> 8) & 0xff));
	     i = (read_array[0] >> 16);
	     printf(" alignment 2 error  %d \n", ((i >> 15) &0x1));
	     printf(" alignment 1 error  %d \n", ((i >> 14) &0x1));
	     printf(" time 2 error       %d \n", ((i >> 13) &0x1));
	     printf(" time 1 error       %d \n", ((i >> 12) &0x1));
	     printf(" opt 1 status Neu   %d \n", ((i >> 11) &0x1));
	     printf(" opt 2 status Neu   %d \n", ((i >> 10) &0x1));
	     printf(" opt 1 status Super %d \n", ((i >> 9) &0x1));
	     printf(" opt 2 status Super %d \n", ((i >> 8) &0x1));
	     printf(" busy neutrino      %d \n", ((i >> 7) &0x1));
	     printf(" busy SuperNova     %d \n", ((i >> 6) &0x1));
	     printf(" xmit Super locked  %d \n", ((i >> 4) &0x1));
	     printf(" xmit Neu locked    %d \n", ((i >> 3) &0x1));
	     printf(" DPA locked         %d \n", ((i >> 2) &0x1));
	     printf(" receiver locked    %d \n", ((i >> 1) &0x1));
	     printf(" PLL locked         %d \n", (i &0x1));
	   }
	   else {
	     read_array1[0] = 4*5;   // 4 bytes * 8 word;
	     i = write(fd_monitor_pt, read_array1, 4);
	     gettimeofday(&start,NULL);
	     read_array1[0] = start.tv_sec;
	     read_array1[1] = start.tv_usec;
	     read_array1[2] = imod;
	     read_array1[3] = mb_xmit_rdstatus;
	     read_array1[4] = read_array[0];
	     i = write(fd_monitor_pt, read_array1, 20);
	   }
	 }

	 //
	 // TPC electronics status monitor
	 //
	 if(itpc_read == 1) {
	   nword =1 ;
	   i = pcie_rec(hDev3,0,1,nword,iprint,py);     // init the receiver
	   imod=imod_xmit_tpc;
	   ichip=3;
	   buf_send[0]=(imod<<11)+(ichip<<8)+mb_xmit_rdstatus+(0x0<<16);  // read out status
	   i=1;
	   k=1;
	   i = pcie_send(hDev3, i, k, px);
	   usleep(10);
	   py = &read_array;
	   i = pcie_rec(hDev3,0,2,nword,iprint,py);     // read out 2 32 bits words
	   if(ith_fr != 1) {
	     printf("TPC &&&&&&&&&&&&&&&&&&  \n");
	     printf("buffer status word = %x\n", read_array[0]);
	     printf(" crate %d, header %x \n",(read_array[0] & 0x1f) ,((read_array[0] >> 8) & 0xff));
	     i = (read_array[0] >> 16);
	     printf(" alignment 2 error  %d \n", ((i >> 15) &0x1));
	     printf(" alignment 1 error  %d \n", ((i >> 14) &0x1));
	     printf(" time 2 error       %d \n", ((i >> 13) &0x1));
	     printf(" time 1 error       %d \n", ((i >> 12) &0x1));
	     printf(" opt 1 status Neu   %d \n", ((i >> 11) &0x1));
	     printf(" opt 2 status Neu   %d \n", ((i >> 10) &0x1));
	     printf(" opt 1 status Super %d \n", ((i >> 9) &0x1));
	     printf(" opt 2 status Super %d \n", ((i >> 8) &0x1));
	     printf(" busy neutrino      %d \n", ((i >> 7) &0x1));
	     printf(" busy SuperNova     %d \n", ((i >> 6) &0x1));
	     printf(" xmit Super locked  %d \n", ((i >> 4) &0x1));
	     printf(" xmit Neu locked    %d \n", ((i >> 3) &0x1));
	     printf(" DPA locked         %d \n", ((i >> 2) &0x1));
	     printf(" receiver locked    %d \n", ((i >> 1) &0x1));
	     printf(" PLL locked         %d \n", (i &0x1));
	   }
	   else {
	     read_array1[0] = 4*5;   // 4 bytes * 8 word;
	     i = write(fd_monitor_pt_tpc, read_array1, 4);
	     gettimeofday(&start,NULL);
	     read_array1[0] = start.tv_sec;
	     read_array1[1] = start.tv_usec;
	     read_array1[2] = imod;
	     read_array1[3] = mb_xmit_rdstatus;
	     read_array1[4] = read_array[0];
	     i = write(fd_monitor_pt_tpc, read_array1, 20);
	   }
	 }
       }
       else usleep(1000);

       //
       // LOOP-STEP ... readout Trigger data (if detached) after STATUS MONITOR
       //
       if((itrig_m == 1) & (itrig_m_d != 1)) {
	 trig_module_read(hDev);
       }

       if(ipmt_read == 1) {

	 for (imod_fem = imod_last; imod_fem< (imod_st+1); imod_fem++) {

	   if(imonitor == 1) {
	     nword =2 ;
	     i = pcie_rec(hDev,0,1,nword,iprint,py);     // init the receiver
	     imod=imod_fem;
	     ichip=3;
	     buf_send[0]=(imod<<11)+(ichip<<8)+mb_a_buf_status+(0x0<<16);  // read out status
	     i=1;
	     k=1;
	     i = pcie_send(hDev, i, k, px);
	     py = &read_array;
	     usleep(10);
	     i = pcie_rec(hDev,0,2,nword,iprint,py);     // read out 2 32 bits words
	     if(ith_fr != 1) {
	       printf("PMT ******************** \n");
	       printf(" Neutrino buffer status word = %x, %x \n", read_array[0], read_array[1]);
	       printf("module addres %d, command %d \n",((read_array[0]>>11) & 0x1f) ,(read_array[0] & 0xff));
	       i = (((read_array[1] >> 16) & 0xffff)+ ((read_array[1] & 0xff)<< 16));
	       printf(" Neutrino uword = %x, Neutrino ublock = %x \n", i, ((read_array[1]>>8) &0xff));
	     }
	     else {
	       read_array1[0] = 4*6;   // 4 bytes * 6 word;
	       i = write(fd_monitor_pt, read_array1, 4);
	       gettimeofday(&start,NULL);
	       read_array1[0] = start.tv_sec;
	       read_array1[1] = start.tv_usec;
	       read_array1[2] = imod;
	       read_array1[3] = mb_a_buf_status;
	       read_array1[4] = read_array[0];
	       read_array1[5] = read_array[1];
	       i = write(fd_monitor_pt, read_array1, 24);
	     }
	   }
	   else usleep(1000);

	   //
	   //
	   if((itrig_m == 1) & (itrig_m_d != 1)) {
	     trig_module_read(hDev);
	   }

	   if(imonitor == 1) {
	     //
	     nword = 2;
	     i = pcie_rec(hDev,0,1,nword,iprint,py);     // init the receiver
	     
	     imod=imod_fem;
	     ichip=3;
	     buf_send[0]=(imod<<11)+(ichip<<8)+mb_b_buf_status+(0x0<<16);  // read out status
	     i=1;
	     k=1;
	     i = pcie_send(hDev, i, k, px);
	     usleep(10);
	     py = &read_array;
	     i = pcie_rec(hDev,0,2,nword,iprint,py);     // read out 2 32 bits words
	     if(ith_fr != 1) {
	       printf(" PMT ******************** \n");
	       printf(" SuperNova buffer status word = %x, %x \n", read_array[0], read_array[1]);
	       printf("module addres %d, command %d \n",((read_array[0]>>11) & 0x1f) ,(read_array[0] & 0xff));
	       i = (((read_array[1] >> 16) & 0xffff)+ ((read_array[1] & 0xff)<< 16));
	       printf(" SuperNova uword = %x, SuperNova ublock = %x \n", i, ((read_array[1]>>8) &0xff));
	     }
	     else {
	       read_array1[0] = 4*6;   // 4 bytes * 6 word;
	       i = write(fd_monitor_pt, read_array1, 4);
	       gettimeofday(&start,NULL);
	       read_array1[0] = start.tv_sec;
	       read_array1[1] = start.tv_usec;
	       read_array1[2] = imod;
	       read_array1[3] = mb_b_buf_status;
	       read_array1[4] = read_array[0];
	       read_array1[5] = read_array[1];
	       i = write(fd_monitor_pt, read_array1, 24);
	     }
	   }
	   else usleep(1000);
	   //
	   if((itrig_m == 1) & (itrig_m_d != 1)) {
	     trig_module_read(hDev);
	   }

	 }
       }

       //
       //
       if(itpc_read == 1) {

	 for (imod_fem = (imod_xmit_tpc+1); imod_fem< (imod_st_tpc+1); imod_fem++) {

	   if(imonitor == 1) {
	     nword =2 ;
	     i = pcie_rec(hDev3,0,1,nword,iprint,py);     // init the receiver
	     imod=imod_fem;
	     ichip=3;
	     buf_send[0]=(imod<<11)+(ichip<<8)+mb_a_buf_status+(0x0<<16);  // read out status
	     i=1;
	     k=1;
	     i = pcie_send(hDev3, i, k, px);
	     py = &read_array;
	     usleep(10);
	     i = pcie_rec(hDev3,0,2,nword,iprint,py);     // read out 2 32 bits words
	     if(ith_fr != 1) {
	       printf("TPC ******************** \n");
	       printf(" Neutrino buffer status word = %x, %x \n", read_array[0], read_array[1]);
	       printf("module addres %d, command %d \n",((read_array[0]>>11) & 0x1f) ,(read_array[0] & 0xff));
	       i = (((read_array[1] >> 16) & 0xffff)+ ((read_array[1] & 0xff)<< 16));
	       printf(" Neutrino uword = %x, Neutrino ublock = %x \n", i, ((read_array[1]>>8) &0xff));
	     }
	     else {
	       read_array1[0] = 4*6;   // 4 bytes * 6 word;
	       i = write(fd_monitor_pt_tpc, read_array1, 4);
	       gettimeofday(&start,NULL);
	       read_array1[0] = start.tv_sec;
	       read_array1[1] = start.tv_usec;
	       read_array1[2] = imod;
	       read_array1[3] = mb_a_buf_status;
	       read_array1[4] = read_array[0];
	       read_array1[5] = read_array[1];
	       i = write(fd_monitor_pt_tpc, read_array1, 24);
	     }
	   }
	   else usleep(1000);
	   //
	   //
	   if((itrig_m == 1) & (itrig_m_d != 1)) {
	     trig_module_read(hDev);
	   }
	   if(imonitor == 1) {
	     //
	     nword = 2;
	     i = pcie_rec(hDev3,0,1,nword,iprint,py);     // init the receiver
	     
	     imod=imod_fem;
	     ichip=3;
	     buf_send[0]=(imod<<11)+(ichip<<8)+mb_b_buf_status+(0x0<<16);  // read out status
	     i=1;
	     k=1;
	     i = pcie_send(hDev3, i, k, px);
	     usleep(10);
	     py = &read_array;
	     i = pcie_rec(hDev3,0,2,nword,iprint,py);     // read out 2 32 bits words
	     if(ith_fr != 1) {
	       printf(" TPC ******************** \n");
	       printf(" SuperNova buffer status word = %x, %x \n", read_array[0], read_array[1]);
	       printf("module addres %d, command %d \n",((read_array[0]>>11) & 0x1f) ,(read_array[0] & 0xff));
	       i = (((read_array[1] >> 16) & 0xffff)+ ((read_array[1] & 0xff)<< 16));
	       printf(" SuperNova uword = %x, SuperNova ublock = %x \n", i, ((read_array[1]>>8) &0xff));
	     }
	     else {
	       read_array1[0] = 4*6;   // 4 bytes * 6 word;
	       i = write(fd_monitor_pt_tpc, read_array1, 4);
	       gettimeofday(&start,NULL);
	       read_array1[0] = start.tv_sec;
	       read_array1[1] = start.tv_usec;
	       read_array1[2] = imod;
	       read_array1[3] = mb_b_buf_status;
	       read_array1[4] = read_array[0];
	       read_array1[5] = read_array[1];
	       i = write(fd_monitor_pt_tpc, read_array1, 24);
	     }
	   }
	   else usleep(1000);
	   //
	   if((itrig_m == 1) & (itrig_m_d != 1)) {
	     trig_module_read(hDev);
	   }
	 }
       }

       //
       //
       //
       if(imonitor == 1) {
	 nword = 12;
	 i = pcie_rec(hDev,0,1,nword,iprint,py);     // init the receiver
	 imod=imod_trig;
	 ichip=0;   // don't care about chip number for triggr module
	 buf_send[0]=(imod<<11)+(ichip<<8)+mb_trig_rd_status+(0x0<<16);  // read out status
	 i=1;
	 k=1;
	 i = pcie_send(hDev, i, k, px);
	 usleep(10);
	 py = &read_array;
	 i = pcie_rec(hDev,0,2,nword,iprint,py);     // read out 2 32 bits words
	 //printf(" Trigger module ****************** \n");
	 //for (i=0; i< 12; i++) {
	 // printf(" i= %d, data = %x \n", i, read_array[i]);
	 //}
       }
       if(imonitor == 1) {
	 nword = 41;
	 i = pcie_rec(hDev,0,1,nword,iprint,py);     // init the receiver
	 imod=imod_xmit+1;                            // only read module next to the PMT xmit
	 ichip=3;   // don't care about chip number for triggr module
	 buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_pmt_rd_counters+(0x0<<16);  // read out status
	 i=1;
	 k=1;
	 i = pcie_send(hDev, i, k, px);
	 usleep(10);
	 py = &read_array;
	 i = pcie_rec(hDev,0,2,nword,iprint,py);     // read out 2 32 bits words
	 //printf(" PMT modules counter information ****************** \n");
	 //for (i=0; i< nword; i++) {
	 //printf(" i= %d, data = %x \n", i, read_array[i]);
	 //}
       }
       
       //
       if((imonitor == 1) & (ith_fr !=1)) scanf("%d",&i);
     }
     
} //&&&&&&&&&&&&&&&&&&&


void trig_module_read(WDC_DEVICE_HANDLE hDev)
{
#include "wdc_defs.h"
#define  t1_tr_bar 0
#define  t2_tr_bar 4
#define  cs_bar 2

/**  command register location **/

#define  tx_mode_reg 0x28
#define  t1_cs_reg 0x18
#define  r1_cs_reg 0x1c
#define  t2_cs_reg 0x20
#define  r2_cs_reg 0x24

#define  tx_md_reg 0x28

#define  cs_dma_add_low_reg 0x0
#define  cs_dma_add_high_reg  0x4
#define  cs_dma_by_cnt 0x8
#define  cs_dma_cntrl 0xc
#define  cs_dma_msi_abort 0x10

/** define status bits **/

#define  cs_init  0x20000000
#define  cs_mode_p 0x8000000
#define  cs_mode_n 0x0
#define  cs_start 0x40000000
#define  cs_done  0x80000000

#define  dma_tr1  0x100000
#define  dma_tr2  0x200000
#define  dma_tr12 0x300000
#define  dma_3dw_trans 0x0
#define  dma_4dw_trans 0x0
#define  dma_3dw_rec   0x40
#define  dma_4dw_rec   0x60
#define  dma_in_progress 0x80000000

#define  dma_abort 0x2
  
   static DWORD dwAddrSpace;
   static UINT32 u32Data;
   static unsigned long long u64Data;
   static DWORD dwOffset;
   static UINT32 read_array[100];

   static int is,iused,nwrite,nwrite_byte_n, taskid;
   static int icopy, idebug, read_point_n_tmp;
   static int idone,tr_bar,t_cs_reg,r_cs_reg,dma_tr;
   static int neu_buf_filled[2], dis, ik;
   static UINT32 *buffp_rec32_n;
   static int ifr=0;
   static int ifr1=0;
   static int i,j,iold;
   static int ipr_trig = 1;
   struct timeval start;


   dwDMABufSize = 1000000;
   //
   //
   //
   if(ifr == 0){
     ifr=1;
     iold = 0xffffff;
   }
   dwAddrSpace =cs_bar;
   dwOffset = t2_cs_reg;
   WDC_ReadAddr64(hDev, dwAddrSpace, dwOffset, &u64Data);
   i=(u64Data>>32) & 0xffffff;
   
   //
   //
   while ((iold - i) >= 16) {
     dwAddrSpace =cs_bar;
     dwOffset = t2_cs_reg;
     WDC_ReadAddr64(hDev, dwAddrSpace, dwOffset, &u64Data);
     i=(u64Data>>32) & 0xffffff;
     //    printf (" receiver 2 status = %8X \n",i);
     
     if((iold - i) >= 16) {
       if(ifr1 == 0) {
	 gettimeofday(&start,NULL);
	 read_array[0] = start.tv_sec;
	 read_array[1] = start.tv_usec;
	 ifr1= 1;
	 i= write(fd_trig_pt_m, read_array, 8);
       }
       dwAddrSpace =t2_tr_bar;
       dwOffset = 0x0;
       u64Data =0xbad;
       WDC_ReadAddr64(hDev, dwAddrSpace, dwOffset, &u64Data);
       read_array[0] = u64Data & 0xffffffff;
       read_array[1] = (u64Data>> 32);
       WDC_ReadAddr64(hDev, dwAddrSpace, dwOffset, &u64Data);
       read_array[2] = u64Data & 0xffffffff;
       read_array[3] = (u64Data>> 32);
       
       iold = iold-16;
       //
       //
       if(ith_fr == 1){
	 i= write(fd_trig_pt_m, read_array, 16);
       }
       if(ipr_trig == 1) {
	 printf("optical receive data word = %x, %x, %x, %x\n", read_array[0], read_array[1],read_array[2], read_array[3]);
	 printf("busy   %d \n", (read_array[0] & 0x1));
	 printf("sample number %d \n", ((read_array[0]>>4) & 0xfff));
	 printf("16 MHz clock remine %d\n", ((read_array[0]>>1) & 0x7));
	 ik = ((read_array[1] & 0xff)<<16) + ((read_array[0] >>16));
	 printf("frame number %x \n",ik);
	 ik = (read_array[1] >> 8);
	 printf("trigger number %x\n",ik);
	 printf("PMT trigger data %x\n", (read_array[2] & 0xff));
	 printf("PC trig          %x\n", ((read_array[2]>>8) & 0x1));
	 printf("External Trig    %x\n", ((read_array[2]>>9) & 0x1));
	 printf("Active           %x\n", ((read_array[2]>>10) & 0x1));
	 printf("Gate2 In         %x\n", ((read_array[2]>>11) & 0x1));
	 printf("Gate1 In         %x\n", ((read_array[2]>>12) & 0x1));
	 printf("Veto in          %x\n", ((read_array[2]>>13) & 0x1));
	 printf("Calib trig       %x\n", ((read_array[2]>>14) & 0x1));
	 printf("64MHz remine     %x\n", ((read_array[2]>>15) & 0x3));
       }
     }
     usleep(200);
     if(iold == i) break;
   }
   return;
}


void  *pt_trig_read(void *threadarg)
{
#include "wdc_defs.h"
#define  t1_tr_bar 0
#define  t2_tr_bar 4
#define  cs_bar 2

/**  command register location **/

#define  tx_mode_reg 0x28
#define  t1_cs_reg 0x18
#define  r1_cs_reg 0x1c
#define  t2_cs_reg 0x20
#define  r2_cs_reg 0x24

#define  tx_md_reg 0x28

#define  cs_dma_add_low_reg 0x0
#define  cs_dma_add_high_reg  0x4
#define  cs_dma_by_cnt 0x8
#define  cs_dma_cntrl 0xc
#define  cs_dma_msi_abort 0x10

/** define status bits **/

#define  cs_init  0x20000000
#define  cs_mode_p 0x8000000
#define  cs_mode_n 0x0
#define  cs_start 0x40000000
#define  cs_done  0x80000000

#define  dma_tr1  0x100000
#define  dma_tr2  0x200000
#define  dma_tr12 0x300000
#define  dma_3dw_trans 0x0
#define  dma_4dw_trans 0x0
#define  dma_3dw_rec   0x40
#define  dma_4dw_rec   0x60
#define  dma_in_progress 0x80000000

#define  dma_abort 0x2

  static DWORD dwAddrSpace;
  static UINT32 u32Data;
  static unsigned long long u64Data;
  static DWORD dwOffset;
  static UINT32 read_array[100];
  
  static int is,iused,nwrite,nwrite_byte_n, taskid;
  static int icopy, idebug, read_point_n_tmp;
  static int idone,tr_bar,t_cs_reg,r_cs_reg,dma_tr;
  static int neu_buf_filled[2], dis, ik;
  static UINT32 *buffp_rec32_n;
  static int ifr=0;
  static int ifr1=0;
  static int i,j,iold;
  static int ipr_trig = 0;
  struct timeval start;
  
  WDC_DEVICE_HANDLE hDev,hDev1;
  
  struct thread_data
  {
    int thread_id;
    WDC_DEVICE_HANDLE hDev;
    WDC_DEVICE_HANDLE hDevc;
  };
  
  struct thread_data *my_data;
  
  
  dwDMABufSize = 1000000;
  //
  //
  //
  printf("trigger thread started \n");
  my_data = (struct thread_data *) threadarg;
  taskid = my_data->thread_id;
  hDev = my_data->hDev;
  hDev1 = my_data->hDevc;
  
  
  
  
  if(ifr == 0){
    ifr=1;
    iold = 0xffffff;
  }
  dwAddrSpace =cs_bar;
  dwOffset = t2_cs_reg;
  WDC_ReadAddr64(hDev, dwAddrSpace, dwOffset, &u64Data);
  i=(u64Data>>32) & 0xffffff;
  
  
  //
  //
  while (1) {
    dwAddrSpace =cs_bar;
    dwOffset = t2_cs_reg;
    WDC_ReadAddr64(hDev, dwAddrSpace, dwOffset, &u64Data);
    i=(u64Data>>32) & 0xffffff;
    //    printf (" receiver 2 status = %8X \n",i);
    
    if((iold - i) >= 16) {
      if(ifr1 == 0) {
	gettimeofday(&start,NULL);
	read_array[0] = start.tv_sec;
	read_array[1] = start.tv_usec;
	ifr1= 1;
	i= write(fd_trig_pt_m, read_array, 8);
      }
      dwAddrSpace =t2_tr_bar;
      dwOffset = 0x0;
      u64Data =0xbad;
      WDC_ReadAddr64(hDev, dwAddrSpace, dwOffset, &u64Data);
      read_array[0] = u64Data & 0xffffffff;
      read_array[1] = (u64Data>> 32);
      WDC_ReadAddr64(hDev, dwAddrSpace, dwOffset, &u64Data);
      read_array[2] = u64Data & 0xffffffff;
      read_array[3] = (u64Data>> 32);
      
      
      iold = iold-16;
      //
      //
      if(ith_fr == 1){
	i= write(fd_trig_pt_m, read_array, 16);
      }
      if(ipr_trig == 1) {
	printf("optical receive data word = %x, %x, %x, %x\n", read_array[0], read_array[1],read_array[2], read_array[3]);
	printf("busy   %d \n", (read_array[0] & 0x1));
	printf("sample number %d \n", ((read_array[0]>>4) & 0xfff));
	printf("16 MHz clock remine %d\n", ((read_array[0]>>1) & 0x7));
	ik = ((read_array[1] & 0xff)<<16) + ((read_array[0] >>16));
	printf("frame number %x \n",ik);
	ik = (read_array[1] >> 8);
	printf("trigger number %x\n",ik);
	printf("PMT trigger data %x\n", (read_array[2] & 0xff));
	printf("PC trig          %x\n", ((read_array[2]>>8) & 0x1));
	printf("External Trig    %x\n", ((read_array[2]>>9) & 0x1));
	printf("Active           %x\n", ((read_array[2]>>10) & 0x1));
	printf("Gate2 In         %x\n", ((read_array[2]>>11) & 0x1));
	printf("Gate1 In         %x\n", ((read_array[2]>>12) & 0x1));
	printf("Veto in          %x\n", ((read_array[2]>>13) & 0x1));
	printf("Calib trig       %x\n", ((read_array[2]>>14) & 0x1));
	printf("64MHz remine     %x\n", ((read_array[2]>>15) & 0x3));
      }
    }
    usleep(200);
  }
}



void *pt_sn_dma(void *threadarg)
{

#include "wdc_defs.h"
#define  t1_tr_bar 0
#define  t2_tr_bar 4
#define  cs_bar 2

/**  command register location **/

#define  tx_mode_reg 0x28
#define  t1_cs_reg 0x18
#define  r1_cs_reg 0x1c
#define  t2_cs_reg 0x20
#define  r2_cs_reg 0x24

#define  tx_md_reg 0x28

#define  cs_dma_add_low_reg 0x0
#define  cs_dma_add_high_reg  0x4
#define  cs_dma_by_cnt 0x8
#define  cs_dma_cntrl 0xc
#define  cs_dma_msi_abort 0x10

/** define status bits **/

#define  cs_init  0x20000000
#define  cs_mode_p 0x8000000
#define  cs_mode_n 0x0
#define  cs_start 0x40000000
#define  cs_done  0x80000000

#define  dma_tr1  0x100000
#define  dma_tr2  0x200000
#define  dma_tr12 0x300000
#define  dma_3dw_trans 0x0
#define  dma_4dw_trans 0x0
#define  dma_3dw_rec   0x40
#define  dma_4dw_rec   0x60
#define  dma_in_progress 0x80000000

#define  dma_abort 0x2

#define  mb_cntrl_set_trig1 0x4

  static DWORD dwAddrSpace;
  static UINT32 u32Data, u32Data_h;
  static DWORD dwOffset;
  
  static int ifr,is,iused,nwrite,nwrite_byte_s, taskid;
  static int icopy, idebug, read_point_s_tmp;
  static int idone,tr_bar,t_cs_reg,r_cs_reg,dma_tr;
  static int sn_buf_filled[2], dis, ik;
  static int i,k,imod,ichip;
  static UINT32 *buffp_rec32_s;
  UINT32 *px;
  UINT32 buf_send[40];
  
  WDC_DEVICE_HANDLE hDev,hDev2;
  
  struct thread_data
  {
    int thread_id;
    WDC_DEVICE_HANDLE hDev;
    WDC_DEVICE_HANDLE hDevc;
  };
  
  struct thread_data *my_data;
  
  
  //
  //
  //
  printf("sn thread started \n");
  dwDMABufSize = 1000000;
  px = &buf_send;
  my_data = (struct thread_data *) threadarg;
  taskid = my_data->thread_id;
  hDev2 = my_data->hDev;
  hDev = my_data->hDevc;
  //    printf("\nReceived event notification (device handle 0x%p): ", hDev);
  //    printf("\nReceived event notification (device handle 0x%p): ", hDev2);
  //
  //
  idebug =1;
  ifr = 0;
  for (is=0; is< 2; is++) {
    sn_buf_filled[is] = 0;
  }
  iused =0;
  nwrite_byte_s = dwDMABufSize;
  nwrite = nwrite_byte_s/4;
  write_point_s = 0;
  read_point_s = 0;
  while (1) {
    for (is=1; is<3; is++) {
      tr_bar = t1_tr_bar;
      r_cs_reg = r1_cs_reg;
      dma_tr = dma_tr1;
      if(is == 2) {
        tr_bar = t2_tr_bar;
        r_cs_reg = r2_cs_reg;
        dma_tr = dma_tr2;
      }
      if(idebug ==1) printf(" is = %d\n",is);
      /** initialize the receiver ***/
      u32Data = cs_init;
      dwOffset = r_cs_reg;
      dwAddrSpace =cs_bar;
      //
      // rreceiver only get initialize for the 1st time
      //
      if(ifr ==0) {
        printf(" initialize the input fifo -- SN\n");
        WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);
      }
      //       if(idebug ==1) printf(" SN -- DMA data length %d \n", nwrite_byte_s);
      /** start the receiver **/
      dwAddrSpace = cs_bar;
      u32Data = cs_start+nwrite_byte_s;   /* 32 bits mode == 4 bytes per word *2 fibers **/
      if(idebug ==1) printf(" SN -- DMA data length %d \n", nwrite_byte_s);
      dwOffset = r_cs_reg;
      WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);
    }
    ifr =1;
    //
    //
    /** set up DMA for both transceiver together **/
    
    if(sn_buf_filled[iused] == 0) {
      dwAddrSpace =cs_bar;
      dwOffset = cs_dma_add_low_reg;
      if(iused ==0)  u32Data = pDma_rec_s1->Page->pPhysicalAddr & 0xffffffff;
      else u32Data = pDma_rec_s2->Page->pPhysicalAddr & 0xffffffff;
      WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);
      
      dwAddrSpace =cs_bar;
      dwOffset = cs_dma_add_high_reg;
      if(iused ==0)  u32Data_h = (pDma_rec_s1->Page->pPhysicalAddr >>32) & 0xffffffff;
      else u32Data_h = (pDma_rec_s2->Page->pPhysicalAddr >> 32) & 0xffffffff;
      WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data_h);
      
      
      /* byte count */
      dwAddrSpace =cs_bar;
      dwOffset = cs_dma_by_cnt;
      //       u32Data = (nwrite)*4*2;      /** twice more data - from fiber 1& 2**/
      u32Data = nwrite_byte_s;
      WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);
      
      
      /* write this will start DMA */
      dwAddrSpace =2;
      dwOffset = cs_dma_cntrl;
      //        is = (pDma_rec_n->Page->pPhysicalAddr >> 32) & 0xffffffff;
      if(u32Data_h == 0) {
	//        if(idebug ==1) printf(" use 3dw \n");
        u32Data = dma_tr12+dma_3dw_rec;
      }
      else {
        u32Data = dma_tr12+dma_4dw_rec;
	//        if(idebug ==1) printf(" use 4dw \n");
      }
      WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);
      //       if(idebug ==1) printf(" trigger ---> DMA set up done, byte count = %d\n", nwrite_byte_s);
      //
      //
      //
      if(ith_fr == 1) {
        if (iused == 0) {
	  icopy = 1;
	  buffp_rec32_s = pbuf_rec_s2;
        }
        else {
	  buffp_rec32_s = pbuf_rec_s1;
	  icopy = 0;
        }
        if (sn_buf_filled[icopy] == 1) {
	  //         printf("start array copy --- SN %d, %d\n",icopy,sn_buf_filled[icopy]);
	  pthread_mutex_lock (&mutexlock);
	  if(write_point_s >= read_point_s) dis =  jbuf_ev_size - (write_point_s - read_point_s);
	  else dis = read_point_s - write_point_s;
	  pthread_mutex_unlock (&mutexlock);
	  //
	  //       wait for the space to open
	  //
	  while (dis < nwrite) {
	    usleep(300);
	    pthread_mutex_lock (&mutexlock);
	    if(write_point_s >= read_point_s) dis =  jbuf_ev_size - (write_point_s - read_point_s);
	    else dis = read_point_s - write_point_s;
	    pthread_mutex_unlock (&mutexlock);
	  }
	  //
	  //
	  //
	  //         printf("enter array copy --SN %d %d %d %d\n", iused, icopy, write_point_s, read_point_s);
	  read_point_s_tmp =  read_point_s;
	  if(write_point_s >= read_point_s_tmp) {
	    if((jbuf_ev_size - write_point_s) >= nwrite) {
	      for (ik=0; ik< nwrite; ik++) {
		buffer_ev_s[write_point_s+ik] = *buffp_rec32_s++;
	      }
	      write_point_s = write_point_s+ nwrite;
	    }
	    else {
	      for (ik=0; ik< (jbuf_ev_size-write_point_s); ik++) {
		buffer_ev_s[write_point_s+ik] = *buffp_rec32_s++;
	      }
	      for (ik=0; ik< (nwrite-(jbuf_ev_size-write_point_s)); ik++) {
		buffer_ev_s[ik] = *buffp_rec32_s++;
	      }
	      write_point_s = write_point_s+ nwrite- jbuf_ev_size;
	    }
	  }
	  else {
	    for (ik=0; ik< nwrite; ik++) {
	      buffer_ev_s[write_point_s+ik] = *buffp_rec32_s++;
	    }
	    write_point_s = write_point_s+ nwrite;
	  }
	  sn_buf_filled[icopy] = 0;
        }
      }
    }
    //
    //
    //
    idone =0;
    while (idone == 0) {
      dwAddrSpace =cs_bar;
      dwOffset = cs_dma_cntrl;
      WDC_ReadAddr32(hDev2, dwAddrSpace, dwOffset, &u32Data);
      if((u32Data & dma_in_progress) == 0) {
        idone =1;
        if(ith_fr == 1) {
	  sn_buf_filled[iused] = 1;
	  if(iused == 1) iused =0;
	  else iused=1;
        }
      }
    }
    printf(" DMA done --SN\n");
    imod=0;
    ichip=1;
    buf_send[0]=(imod<<11)+(ichip<<8)+mb_cntrl_set_trig1+(0x0<<16);  // send trigger
    i=1;
    k=1;
    i = pcie_send(hDev, i, k, px);
  }
  
}

void *pt_trig_dma(void *threadarg)
{
  
#include "wdc_defs.h"
#define  t1_tr_bar 0
#define  t2_tr_bar 4
#define  cs_bar 2

/**  command register location **/

#define  tx_mode_reg 0x28
#define  t1_cs_reg 0x18
#define  r1_cs_reg 0x1c
#define  t2_cs_reg 0x20
#define  r2_cs_reg 0x24

#define  tx_md_reg 0x28

#define  cs_dma_add_low_reg 0x0
#define  cs_dma_add_high_reg  0x4
#define  cs_dma_by_cnt 0x8
#define  cs_dma_cntrl 0xc
#define  cs_dma_msi_abort 0x10

/** define status bits **/

#define  cs_init  0x20000000
#define  cs_mode_p 0x8000000
#define  cs_mode_n 0x0
#define  cs_start 0x40000000
#define  cs_done  0x80000000

#define  dma_tr1  0x100000
#define  dma_tr2  0x200000
#define  dma_tr12 0x300000
#define  dma_3dw_trans 0x0
#define  dma_4dw_trans 0x0
#define  dma_3dw_rec   0x40
#define  dma_4dw_rec   0x60
#define  dma_in_progress 0x80000000

#define  dma_abort 0x2

  static DWORD dwAddrSpace;
  static UINT32 u32Data, u32Data_h;
  static DWORD dwOffset;
  
  static int ifr,is,iused,nwrite,nwrite_byte_n, taskid;
  static int icopy, idebug, read_point_n_tmp;
  static int idone,tr_bar,t_cs_reg,r_cs_reg,dma_tr;
  static int neu_buf_filled[2], dis, ik;
  static UINT32 *buffp_rec32_n;
  
  WDC_DEVICE_HANDLE hDev,hDev1;
  
  struct thread_data
  {
    int thread_id;
    WDC_DEVICE_HANDLE hDev;
    WDC_DEVICE_HANDLE hDevc;
  };
  
  struct thread_data *my_data;
  
  
  dwDMABufSize = 1000000;
  //
  //
  //
  printf("trigger thread started \n");
  my_data = (struct thread_data *) threadarg;
  taskid = my_data->thread_id;
  hDev1 = my_data->hDev;
  hDev = my_data->hDevc;
  //
  //
  //
  idebug =0;
  ifr = 0;
  for (is=0; is< 2; is++) {
    neu_buf_filled[is] = 0;
  }
  iused =0;
  nwrite_byte_n = dwDMABufSize;
  nwrite = nwrite_byte_n/4;
  write_point_n = 0;
  read_point_n = 0;
  
  while (1) {
    for (is=1; is<3; is++) {
      tr_bar = t1_tr_bar;
      r_cs_reg = r1_cs_reg;
      dma_tr = dma_tr1;
      if(is == 2) {
        tr_bar = t2_tr_bar;
        r_cs_reg = r2_cs_reg;
        dma_tr = dma_tr2;
      }
      if(idebug ==1) printf(" is = %d\n",is);
      /** initialize the receiver ***/
      u32Data = cs_init;
      dwOffset = r_cs_reg;
      dwAddrSpace =cs_bar;
      //
      // rreceiver only get initialize for the 1st time
      //
      if(ifr ==0) {
        printf(" initialize the input fifo -- Tr\n");
        WDC_WriteAddr32(hDev1, dwAddrSpace, dwOffset, u32Data);
      }
      /** start the receiver **/
      dwAddrSpace = cs_bar;
      u32Data = cs_start+nwrite_byte_n;   /* 32 bits mode == 4 bytes per word *2 fibers **/
      if(idebug == 1) printf(" trigger -- DMA loop with DMA data length %d \n", nwrite_byte_n);
      dwOffset = r_cs_reg;
      WDC_WriteAddr32(hDev1, dwAddrSpace, dwOffset, u32Data);
      
    }
    ifr =1;
    //
    //
    /** set up DMA for both transceiver together **/
    
    if(neu_buf_filled[iused] == 0) {
      dwAddrSpace =cs_bar;
      dwOffset = cs_dma_add_low_reg;
      if(iused ==0)  u32Data = pDma_rec_n1->Page->pPhysicalAddr & 0xffffffff;
      else u32Data = pDma_rec_n2->Page->pPhysicalAddr & 0xffffffff;
      WDC_WriteAddr32(hDev1, dwAddrSpace, dwOffset, u32Data);
      
      dwAddrSpace =cs_bar;
      dwOffset = cs_dma_add_high_reg;
      if(iused ==0)  u32Data_h = (pDma_rec_n1->Page->pPhysicalAddr >>32) & 0xffffffff;
      else u32Data_h = (pDma_rec_n2->Page->pPhysicalAddr >> 32) & 0xffffffff;
      WDC_WriteAddr32(hDev1, dwAddrSpace, dwOffset, u32Data_h);
      
      
      /* byte count */
      dwAddrSpace =cs_bar;
      dwOffset = cs_dma_by_cnt;
      //       u32Data = (nwrite)*4*2;      /** twice more data - from fiber 1& 2**/
      u32Data = nwrite_byte_n;
      WDC_WriteAddr32(hDev1, dwAddrSpace, dwOffset, u32Data);
      
      
      /* write this will start DMA */
      dwAddrSpace =2;
      dwOffset = cs_dma_cntrl;
      //        is = (pDma_rec_n->Page->pPhysicalAddr >> 32) & 0xffffffff;
      if(u32Data_h == 0) {
        if(idebug ==1) printf(" use 3dw \n");
        u32Data = dma_tr12+dma_3dw_rec;
      }
      else {
        u32Data = dma_tr12+dma_4dw_rec;
        if(idebug ==1) printf(" use 4dw \n");
      }
      WDC_WriteAddr32(hDev1, dwAddrSpace, dwOffset, u32Data);
      if(idebug ==1) printf(" trigger ---> DMA set up done, byte count = %d\n", nwrite_byte_n);
      //
      //
      //
      if(ith_fr == 1) {
        if (iused == 0) {
	  icopy = 1;
	  buffp_rec32_n = pbuf_rec_n2;
        }
        else {
	  buffp_rec32_n = pbuf_rec_n1;
	  icopy = 0;
        }
        if (neu_buf_filled[icopy] == 1) {
	  pthread_mutex_lock (&mutexlock);
	  if(write_point_n >= read_point_n) dis =  jbuf_ev_size - (write_point_n - read_point_n);
	  else dis = read_point_n - write_point_n;
	  pthread_mutex_unlock (&mutexlock);
	  //
	  //       wait for the space to open
	  //
	  while (dis < nwrite) {
	    usleep(300);
	    pthread_mutex_lock (&mutexlock);
	    if(write_point_n >= read_point_n) dis =  jbuf_ev_size - (write_point_n - read_point_n);
	    else dis = read_point_n - write_point_n;
	    pthread_mutex_unlock (&mutexlock);
	  }
	  //
	  //
	  //
	  read_point_n_tmp =  read_point_n;
	  if(write_point_n >= read_point_n_tmp) {
	    if((jbuf_ev_size - write_point_n) >= nwrite) {
	      for (ik=0; ik< nwrite; ik++) {
		buffer_ev_n[write_point_n+ik] = *buffp_rec32_n++;
	      }
	      write_point_n = write_point_n+ nwrite;
	    }
	    else {
	      for (ik=0; ik< (jbuf_ev_size-write_point_n); ik++) {
		buffer_ev_n[write_point_n+ik] = *buffp_rec32_n++;
	      }
	      for (ik=0; ik< (nwrite-(jbuf_ev_size-write_point_n)); ik++) {
		buffer_ev_n[ik] = *buffp_rec32_n++;
	      }
	      write_point_n = write_point_n+ nwrite- jbuf_ev_size;
	    }
	  }
	  else {
	    for (ik=0; ik< nwrite; ik++) {
	      buffer_ev_n[write_point_n+ik] = *buffp_rec32_n++;
	    }
	    write_point_n = write_point_n+ nwrite;
	  }
	  neu_buf_filled[icopy] = 0;
        }
      }
    }
    //
    //
    //
    idone =0;
    while (idone == 0) {
      dwAddrSpace =cs_bar;
      dwOffset = cs_dma_cntrl;
      WDC_ReadAddr32(hDev1, dwAddrSpace, dwOffset, &u32Data);
      //       printf(" u32Data = %x \n",u32Data);
      if((u32Data & dma_in_progress) == 0) {
        idone =1;
        if(ith_fr == 1) {
	  neu_buf_filled[iused] = 1;
	  if(iused == 0) iused =1;
	  else iused = 0;
        }
      }
    }
    printf(" DMA done --TR\n");
  }
  
}


void *pt_trig_filewrite(void *nword_write)
{
   static int file_buf[250000];
   static int w_t1,r_t1,nwrite,dis,is, index, n_write;
   static int read_point_tmp;
   static UINT32 send_array[2];

   dwDMABufSize = 1000000;
   printf("trigger file write thread started \n");
   while (1) {
     w_t1 = write_point_n;
     r_t1 = read_point_n;
     nwrite = dwDMABufSize/4;
     dis =w_t1 - r_t1;
     while (dis< nwrite) {
       w_t1 = write_point_n;
       r_t1 = read_point_n;
       dis =w_t1 - r_t1;
       if (dis < 0) dis = jbuf_ev_size + dis;
       usleep(300);
     }
     
     if((w_t1 > r_t1) | ((jbuf_ev_size -r_t1)>nwrite)) {
       for (is=0; is<nwrite; is++) {
	 file_buf[is] = buffer_ev_n[is+r_t1];
       }
       //     read_point_n = read_point_n+nwrite;
       read_point_tmp = read_point_n+nwrite;
     }
     else {
       for (is=0; is<(jbuf_ev_size-r_t1); is++) {
	 file_buf[is] = buffer_ev_n[is+r_t1];
       }
       index =0;
       for (is=(jbuf_ev_size-r_t1); is< (nwrite- (jbuf_ev_size-r_t1)); is++) {
	 file_buf[is] = buffer_ev_n[index];
	 index = index+1;
       }
       //     read_point_n = index;
       read_point_tmp = index;
     }
     send_array[0] = nwrite;
     n_write = write(fd_trig_pt,send_array,4);
     n_write = write(fd_trig_pt,file_buf,(nwrite*4));
     read_point_n = read_point_tmp;
     printf(" Neutrino write point = %d, read point %d\n", write_point_n, read_point_n);
   }
}


void *pt_sn_filewrite(void *nword_write)
{
  static int file_buf[250000];
  static int w_t1,r_t1,nwrite,dis,is, index, n_write;
  static int read_point_tmp;
  static UINT32 send_array[2];
  
  dwDMABufSize = 1000000;
  printf("sn file write thread started \n");
  while (1) {
    w_t1 = write_point_s;
    r_t1 = read_point_s;
    nwrite = dwDMABufSize/4;
    dis =w_t1 - r_t1;
    while (dis< nwrite) {
      w_t1 = write_point_s;
      r_t1 = read_point_s;
      dis =w_t1 - r_t1;
      if (dis < 0) dis = jbuf_ev_size + dis;
      usleep(300);
    }
    //    printf("wp, rp %d, %d \n",write_point_s, read_point_s);
    if((w_t1 > r_t1) | ((jbuf_ev_size -r_t1)>nwrite)) {
      for (is=0; is<nwrite; is++) {
	file_buf[is] = buffer_ev_s[is+r_t1];
      }
      //     read_point_s = read_point_s+nwrite;
      read_point_tmp = read_point_s+nwrite;
    }
    else {
      for (is=0; is<(jbuf_ev_size-r_t1); is++) {
	file_buf[is] = buffer_ev_s[is+r_t1];
      }
      index =0;
      for (is=(jbuf_ev_size-r_t1); is< (nwrite- (jbuf_ev_size-r_t1)); is++) {
	file_buf[is] = buffer_ev_s[index];
	index = index+1;
      }
      //     read_point_s = index;
      read_point_tmp = index;
    }
    send_array[0] = nwrite;
    n_write = write(fd_sn_pt,send_array,4);
    n_write = write(fd_sn_pt,file_buf,(nwrite*4));
    read_point_s = read_point_tmp;
    printf(" SuperNova write point = %d, read point %d\n", write_point_s, read_point_s);
  }
}

//
//
//
void *pt_sn_dma_tpc(void *threadarg)
{

#include "wdc_defs.h"
#define  t1_tr_bar 0
#define  t2_tr_bar 4
#define  cs_bar 2

/**  command register location **/

#define  tx_mode_reg 0x28
#define  t1_cs_reg 0x18
#define  r1_cs_reg 0x1c
#define  t2_cs_reg 0x20
#define  r2_cs_reg 0x24

#define  tx_md_reg 0x28

#define  cs_dma_add_low_reg 0x0
#define  cs_dma_add_high_reg  0x4
#define  cs_dma_by_cnt 0x8
#define  cs_dma_cntrl 0xc
#define  cs_dma_msi_abort 0x10

/** define status bits **/

#define  cs_init  0x20000000
#define  cs_mode_p 0x8000000
#define  cs_mode_n 0x0
#define  cs_start 0x40000000
#define  cs_done  0x80000000

#define  dma_tr1  0x100000
#define  dma_tr2  0x200000
#define  dma_tr12 0x300000
#define  dma_3dw_trans 0x0
#define  dma_4dw_trans 0x0
#define  dma_3dw_rec   0x40
#define  dma_4dw_rec   0x60
#define  dma_in_progress 0x80000000

#define  dma_abort 0x2

#define  mb_cntrl_set_trig1 0x4

  static DWORD dwAddrSpace;
  static UINT32 u32Data, u32Data_h;
  static DWORD dwOffset;
  
  static int ifr,is,iused,nwrite,nwrite_byte_s, taskid;
  static int icopy, idebug, read_point_s_tmp;
  static int idone,tr_bar,t_cs_reg,r_cs_reg,dma_tr;
  static int sn_buf_filled[2], dis, ik;
  static int i,k,imod,ichip;
  static UINT32 *buffp_rec32_s;
  UINT32 *px;
  UINT32 buf_send[40];
  
  WDC_DEVICE_HANDLE hDev,hDev2;
  
  struct thread_data
  {
    int thread_id;
    WDC_DEVICE_HANDLE hDev;
    WDC_DEVICE_HANDLE hDevc;
  };
  
  struct thread_data *my_data;
  
  
  //
  //
  //
  printf("sn thread started \n");
  dwDMABufSize = 1000000;
  px = &buf_send;
  my_data = (struct thread_data *) threadarg;
  taskid = my_data->thread_id;
  hDev2 = my_data->hDev;
  hDev = my_data->hDevc;
  //    printf("\nReceived event notification (device handle 0x%p): ", hDev);
  //    printf("\nReceived event notification (device handle 0x%p): ", hDev2);
  //
  //
  idebug =1;
  ifr = 0;
  for (is=0; is< 2; is++) {
    sn_buf_filled[is] = 0;
  }
  iused =0;
  nwrite_byte_s = dwDMABufSize;
  nwrite = nwrite_byte_s/4;
  write_point_s_tpc = 0;
  read_point_s_tpc = 0;
  while (1) {
    for (is=1; is<3; is++) {
      tr_bar = t1_tr_bar;
      r_cs_reg = r1_cs_reg;
      dma_tr = dma_tr1;
      if(is == 2) {
        tr_bar = t2_tr_bar;
        r_cs_reg = r2_cs_reg;
        dma_tr = dma_tr2;
      }
      if(idebug ==1) printf(" is = %d\n",is);
      /** initialize the receiver ***/
      u32Data = cs_init;
      dwOffset = r_cs_reg;
      dwAddrSpace =cs_bar;
      //
      // rreceiver only get initialize for the 1st time
      //
      if(ifr ==0) {
        printf(" initialize the input fifo -- SN\n");
        WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);
      }
      //       if(idebug ==1) printf(" SN -- DMA data length %d \n", nwrite_byte_s);
      /** start the receiver **/
      dwAddrSpace = cs_bar;
      u32Data = cs_start+nwrite_byte_s;   /* 32 bits mode == 4 bytes per word *2 fibers **/
      if(idebug ==1) printf(" SN -- DMA data length %d \n", nwrite_byte_s);
      dwOffset = r_cs_reg;
      WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);
    }
    ifr =1;
    //
    //
    /** set up DMA for both transceiver together **/
    
    if(sn_buf_filled[iused] == 0) {
      dwAddrSpace =cs_bar;
      dwOffset = cs_dma_add_low_reg;
      if(iused ==0)  u32Data = pDma_rec_s1_tpc->Page->pPhysicalAddr & 0xffffffff;
      else u32Data = pDma_rec_s2_tpc->Page->pPhysicalAddr & 0xffffffff;
      WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);
      
      dwAddrSpace =cs_bar;
      dwOffset = cs_dma_add_high_reg;
      if(iused ==0)  u32Data_h = (pDma_rec_s1_tpc->Page->pPhysicalAddr >>32) & 0xffffffff;
      else u32Data_h = (pDma_rec_s2_tpc->Page->pPhysicalAddr >> 32) & 0xffffffff;
      WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data_h);
      
      
      /* byte count */
      dwAddrSpace =cs_bar;
      dwOffset = cs_dma_by_cnt;
      //       u32Data = (nwrite)*4*2;      /** twice more data - from fiber 1& 2**/
      u32Data = nwrite_byte_s;
      WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);
      
      
      /* write this will start DMA */
      dwAddrSpace =2;
      dwOffset = cs_dma_cntrl;
      //        is = (pDma_rec_n->Page->pPhysicalAddr >> 32) & 0xffffffff;
      if(u32Data_h == 0) {
	//        if(idebug ==1) printf(" use 3dw \n");
        u32Data = dma_tr12+dma_3dw_rec;
      }
      else {
        u32Data = dma_tr12+dma_4dw_rec;
	//        if(idebug ==1) printf(" use 4dw \n");
      }
      WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);
      //       if(idebug ==1) printf(" trigger ---> DMA set up done, byte count = %d\n", nwrite_byte_s);
      //
      //
      //
      if(ith_fr == 1) {
        if (iused == 0) {
	  icopy = 1;
	  buffp_rec32_s = pbuf_rec_s2_tpc;
        }
        else {
	  buffp_rec32_s = pbuf_rec_s1_tpc;
	  icopy = 0;
        }
        if (sn_buf_filled[icopy] == 1) {
	  //         printf("start array copy --- SN %d, %d\n",icopy,sn_buf_filled[icopy]);
	  pthread_mutex_lock (&mutexlock);
	  if(write_point_s_tpc >= read_point_s_tpc) dis =  jbuf_ev_size - (write_point_s_tpc - read_point_s_tpc);
	  else dis = read_point_s_tpc - write_point_s_tpc;
	  pthread_mutex_unlock (&mutexlock);
	  //
	  //       wait for the space to open
	  //
	  while (dis < nwrite) {
	    usleep(300);
	    pthread_mutex_lock (&mutexlock);
	    if(write_point_s_tpc >= read_point_s_tpc) dis =  jbuf_ev_size - (write_point_s_tpc - read_point_s_tpc);
	    else dis = read_point_s_tpc - write_point_s_tpc;
	    pthread_mutex_unlock (&mutexlock);
	  }
	  //
	  //
	  //
	  //         printf("enter array copy --SN %d %d %d %d\n", iused, icopy, write_point_s, read_point_s);
	  read_point_s_tmp =  read_point_s_tpc;
	  if(write_point_s_tpc >= read_point_s_tmp) {
	    if((jbuf_ev_size - write_point_s_tpc) >= nwrite) {
	      for (ik=0; ik< nwrite; ik++) {
		buffer_ev_s_tpc[write_point_s_tpc+ik] = *buffp_rec32_s++;
	      }
	      write_point_s_tpc = write_point_s_tpc+ nwrite;
	    }
	    else {
	      for (ik=0; ik< (jbuf_ev_size-write_point_s_tpc); ik++) {
		buffer_ev_s_tpc[write_point_s_tpc+ik] = *buffp_rec32_s++;
	      }
	      for (ik=0; ik< (nwrite-(jbuf_ev_size-write_point_s_tpc)); ik++) {
		buffer_ev_s_tpc[ik] = *buffp_rec32_s++;
	      }
	      write_point_s_tpc = write_point_s_tpc+ nwrite- jbuf_ev_size;
	    }
	  }
	  else {
	    for (ik=0; ik< nwrite; ik++) {
	      buffer_ev_s_tpc[write_point_s_tpc+ik] = *buffp_rec32_s++;
	    }
	    write_point_s_tpc = write_point_s_tpc+ nwrite;
	  }
	  sn_buf_filled[icopy] = 0;
        }
      }
    }
    //
    //
    //
    idone =0;
    while (idone == 0) {
      dwAddrSpace =cs_bar;
      dwOffset = cs_dma_cntrl;
      WDC_ReadAddr32(hDev2, dwAddrSpace, dwOffset, &u32Data);
      if((u32Data & dma_in_progress) == 0) {
        idone =1;
        if(ith_fr == 1) {
	  sn_buf_filled[iused] = 1;
	  if(iused == 1) iused =0;
	  else iused=1;
        }
      }
    }
    printf(" DMA done --SN\n");
    imod=0;
    ichip=1;
    buf_send[0]=(imod<<11)+(ichip<<8)+mb_cntrl_set_trig1+(0x0<<16);  // send trigger
    i=1;
    k=1;
    i = pcie_send(hDev, i, k, px);
  }

}


void *pt_trig_dma_tpc(void *threadarg)
{

#include "wdc_defs.h"
#define  t1_tr_bar 0
#define  t2_tr_bar 4
#define  cs_bar 2

/**  command register location **/

#define  tx_mode_reg 0x28
#define  t1_cs_reg 0x18
#define  r1_cs_reg 0x1c
#define  t2_cs_reg 0x20
#define  r2_cs_reg 0x24

#define  tx_md_reg 0x28

#define  cs_dma_add_low_reg 0x0
#define  cs_dma_add_high_reg  0x4
#define  cs_dma_by_cnt 0x8
#define  cs_dma_cntrl 0xc
#define  cs_dma_msi_abort 0x10

/** define status bits **/

#define  cs_init  0x20000000
#define  cs_mode_p 0x8000000
#define  cs_mode_n 0x0
#define  cs_start 0x40000000
#define  cs_done  0x80000000

#define  dma_tr1  0x100000
#define  dma_tr2  0x200000
#define  dma_tr12 0x300000
#define  dma_3dw_trans 0x0
#define  dma_4dw_trans 0x0
#define  dma_3dw_rec   0x40
#define  dma_4dw_rec   0x60
#define  dma_in_progress 0x80000000

#define  dma_abort 0x2

  static DWORD dwAddrSpace;
  static UINT32 u32Data, u32Data_h;
  static DWORD dwOffset;
  
  static int ifr,is,iused,nwrite,nwrite_byte_n, taskid;
  static int icopy, idebug, read_point_n_tmp;
  static int idone,tr_bar,t_cs_reg,r_cs_reg,dma_tr;
  static int neu_buf_filled[2], dis, ik;
  static UINT32 *buffp_rec32_n;
  
  WDC_DEVICE_HANDLE hDev,hDev1;
  
  struct thread_data
  {
    int thread_id;
    WDC_DEVICE_HANDLE hDev;
    WDC_DEVICE_HANDLE hDevc;
  };
  
  struct thread_data *my_data;
  
  
  dwDMABufSize = 1000000;
  //
  //
  //
  printf("TPC trigger thread started \n");
  my_data = (struct thread_data *) threadarg;
  taskid = my_data->thread_id;
  hDev1 = my_data->hDev;
  hDev = my_data->hDevc;
  //
  //
  //
  idebug =0;
  ifr = 0;
  for (is=0; is< 2; is++) {
    neu_buf_filled[is] = 0;
  }
  iused =0;
  nwrite_byte_n = dwDMABufSize;
  nwrite = nwrite_byte_n/4;
  write_point_n_tpc = 0;
  read_point_n_tpc = 0;
  
  while (1) {
    for (is=1; is<3; is++) {
      tr_bar = t1_tr_bar;
      r_cs_reg = r1_cs_reg;
      dma_tr = dma_tr1;
      if(is == 2) {
        tr_bar = t2_tr_bar;
        r_cs_reg = r2_cs_reg;
        dma_tr = dma_tr2;
      }
      if(idebug ==1) printf(" is = %d\n",is);
      /** initialize the receiver ***/
      u32Data = cs_init;
      dwOffset = r_cs_reg;
      dwAddrSpace =cs_bar;
      //
      // rreceiver only get initialize for the 1st time
      //
      if(ifr ==0) {
        printf(" initialize the input fifo -- Tr\n");
        WDC_WriteAddr32(hDev1, dwAddrSpace, dwOffset, u32Data);
      }
      /** start the receiver **/
      dwAddrSpace = cs_bar;
      u32Data = cs_start+nwrite_byte_n;   /* 32 bits mode == 4 bytes per word *2 fibers **/
      if(idebug == 1) printf(" trigger -- DMA loop with DMA data length %d \n", nwrite_byte_n);
      dwOffset = r_cs_reg;
      WDC_WriteAddr32(hDev1, dwAddrSpace, dwOffset, u32Data);
      
    }
    ifr =1;
    //
    //
    /** set up DMA for both transceiver together **/
    
    if(neu_buf_filled[iused] == 0) {
      dwAddrSpace =cs_bar;
      dwOffset = cs_dma_add_low_reg;
      if(iused ==0)  u32Data = pDma_rec_n1_tpc->Page->pPhysicalAddr & 0xffffffff;
      else u32Data = pDma_rec_n2_tpc->Page->pPhysicalAddr & 0xffffffff;
      WDC_WriteAddr32(hDev1, dwAddrSpace, dwOffset, u32Data);
      
      dwAddrSpace =cs_bar;
      dwOffset = cs_dma_add_high_reg;
      if(iused ==0)  u32Data_h = (pDma_rec_n1_tpc->Page->pPhysicalAddr >>32) & 0xffffffff;
      else u32Data_h = (pDma_rec_n2_tpc->Page->pPhysicalAddr >> 32) & 0xffffffff;
      WDC_WriteAddr32(hDev1, dwAddrSpace, dwOffset, u32Data_h);
      
      
      /* byte count */
      dwAddrSpace =cs_bar;
      dwOffset = cs_dma_by_cnt;
      //       u32Data = (nwrite)*4*2;      /** twice more data - from fiber 1& 2**/
      u32Data = nwrite_byte_n;
      WDC_WriteAddr32(hDev1, dwAddrSpace, dwOffset, u32Data);
      
      
      /* write this will start DMA */
      dwAddrSpace =2;
      dwOffset = cs_dma_cntrl;
      //        is = (pDma_rec_n->Page->pPhysicalAddr >> 32) & 0xffffffff;
      if(u32Data_h == 0) {
        if(idebug ==1) printf(" use 3dw \n");
        u32Data = dma_tr12+dma_3dw_rec;
      }
      else {
        u32Data = dma_tr12+dma_4dw_rec;
        if(idebug ==1) printf(" use 4dw \n");
      }
      WDC_WriteAddr32(hDev1, dwAddrSpace, dwOffset, u32Data);
      if(idebug ==1) printf(" trigger ---> DMA set up done, byte count = %d\n", nwrite_byte_n);
      //
      //
      //
      if(ith_fr == 1) {
        if (iused == 0) {
	  icopy = 1;
	  buffp_rec32_n = pbuf_rec_n2_tpc;
        }
        else {
	  buffp_rec32_n = pbuf_rec_n1_tpc;
	  icopy = 0;
        }
        if (neu_buf_filled[icopy] == 1) {
	  pthread_mutex_lock (&mutexlock);
	  if(write_point_n_tpc >= read_point_n_tpc) dis =  jbuf_ev_size - (write_point_n_tpc - read_point_n_tpc);
	  else dis = read_point_n_tpc - write_point_n_tpc;
	  pthread_mutex_unlock (&mutexlock);
	  //
	  //       wait for the space to open
	  //
	  while (dis < nwrite) {
	    usleep(300);
	    pthread_mutex_lock (&mutexlock);
	    if(write_point_n_tpc >= read_point_n_tpc) dis =  jbuf_ev_size - (write_point_n_tpc - read_point_n_tpc);
	    else dis = read_point_n_tpc - write_point_n_tpc;
	    pthread_mutex_unlock (&mutexlock);
	  }
	  //
	  //
	  //
	  read_point_n_tmp =  read_point_n_tpc;
	  //         printf(" icopy = %d, neu_buf_filled[icopy] = %d, write_point_n_tpc \n", icopy, neu_buf_filled[icopy], write_point_n_tpc );
	  //         printf(" %x, %x, %x, %x \n", buffp_rec32_n[0], buffp_rec32_n[1],  buffp_rec32_n[2],  buffp_rec32_n[3]);
	  if(write_point_n_tpc >= read_point_n_tmp) {
	    if((jbuf_ev_size - write_point_n_tpc) >= nwrite) {
	      for (ik=0; ik< nwrite; ik++) {
		buffer_ev_n_tpc[write_point_n_tpc+ik] = *buffp_rec32_n++;
	      }
	      write_point_n_tpc = write_point_n_tpc+ nwrite;
	    }
	    else {
	      for (ik=0; ik< (jbuf_ev_size-write_point_n_tpc); ik++) {
		buffer_ev_n_tpc[write_point_n_tpc+ik] = *buffp_rec32_n++;
	      }
	      for (ik=0; ik< (nwrite-(jbuf_ev_size-write_point_n_tpc)); ik++) {
		buffer_ev_n_tpc[ik] = *buffp_rec32_n++;
	      }
	      write_point_n_tpc = write_point_n_tpc+ nwrite- jbuf_ev_size;
	    }
	  }
	  else {
	    for (ik=0; ik< nwrite; ik++) {
	      buffer_ev_n_tpc[write_point_n_tpc+ik] = *buffp_rec32_n++;
	    }
	    write_point_n_tpc = write_point_n_tpc+ nwrite;
	  }
	  neu_buf_filled[icopy] = 0;
	  //         printf(" %x, %x, %x, %x \n", buffer_ev_n_tpc[0], buffer_ev_n_tpc[1],  buffer_ev_n_tpc[2],  buffer_ev_n_tpc[3]);
        }
      }
    }
    //
    //
    //
    idone =0;
    while (idone == 0) {
      dwAddrSpace =cs_bar;
      dwOffset = cs_dma_cntrl;
      WDC_ReadAddr32(hDev1, dwAddrSpace, dwOffset, &u32Data);
      //       printf(" u32Data = %x \n",u32Data);
      if((u32Data & dma_in_progress) == 0) {
        buffp_rec32_n = pbuf_rec_n1_tpc;
	//        printf(" %x, %x, %x, %x \n", buffp_rec32_n[0], buffp_rec32_n[1],  buffp_rec32_n[2],  buffp_rec32_n[3]);
	//        printf(" %x, %x, %x, %x \n", buffer_ev_n_tpc[0], buffer_ev_n_tpc[1],  buffer_ev_n_tpc[2],  buffer_ev_n_tpc[3]);
        idone =1;
        if(ith_fr == 1) {
	  neu_buf_filled[iused] = 1;
	  if(iused == 0) iused =1;
	  else iused = 0;
	  //         printf(" iused = %d, neu_buf_filled[iused] = %d, icopy = %d\n", iused, neu_buf_filled[iused], icopy);
	  //         printf(" write_point_n_tpc = %d , read_point_n_tpc = %d \n", write_point_n_tpc, read_point_n_tpc);
        }
      }
    }
    printf(" DMA done --TR-- TPC\n");
  }
  
}


void *pt_trig_filewrite_tpc(void *nword_write)
{
  static int file_buf[250000];
  static int w_t1,r_t1,nwrite,dis,is, index, n_write;
  static int read_point_tmp;
  static UINT32 send_array[2];
  
  dwDMABufSize = 1000000;
  printf("trigger file write thread started \n");
  while (1) {
    w_t1 = write_point_n_tpc;
    r_t1 = read_point_n_tpc;
    nwrite = dwDMABufSize/4;
    dis =w_t1 - r_t1;
    while (dis< nwrite) {
      w_t1 = write_point_n_tpc;
      r_t1 = read_point_n_tpc;
      dis =w_t1 - r_t1;
      if (dis < 0) dis = jbuf_ev_size + dis;
      usleep(300);
    }
    
    if((w_t1 > r_t1) | ((jbuf_ev_size -r_t1)>nwrite)) {
      for (is=0; is<nwrite; is++) {
	file_buf[is] = buffer_ev_n_tpc[is+r_t1];
      }
      //     read_point_n = read_point_n+nwrite;
      read_point_tmp = read_point_n_tpc+nwrite;
    }
    else {
      for (is=0; is<(jbuf_ev_size-r_t1); is++) {
	file_buf[is] = buffer_ev_n_tpc[is+r_t1];
      }
      index =0;
      for (is=(jbuf_ev_size-r_t1); is< (nwrite- (jbuf_ev_size-r_t1)); is++) {
	file_buf[is] = buffer_ev_n_tpc[index];
	index = index+1;
      }
      //     read_point_n = index;
      read_point_tmp = index;
    }
    send_array[0] = nwrite;
    n_write = write(fd_trig_pt_tpc,send_array,4);
    n_write = write(fd_trig_pt_tpc,file_buf,(nwrite*4));
    read_point_n_tpc = read_point_tmp;
    printf(" Neutrino write point TPC = %d, read point %d\n", write_point_n_tpc, read_point_n_tpc);
    //    printf(" file_write_tpc %x, %x, %x, %x \n", file_buf[0], file_buf[1], file_buf[2], file_buf[3]);
    //    printf(" file_write_tpc %x, %x, %x, %x \n", buffer_ev_n_tpc[0], buffer_ev_n_tpc[1], buffer_ev_n_tpc[2], buffer_ev_n_tpc[3]);
  }
}


void *pt_sn_filewrite_tpc(void *nword_write)
{
  static int file_buf[250000];
  static int w_t1,r_t1,nwrite,dis,is, index, n_write;
  static int read_point_tmp;
  static UINT32 send_array[2];
  
  dwDMABufSize = 1000000;
  printf("sn file write thread started \n");
  while (1) {
    w_t1 = write_point_s_tpc;
    r_t1 = read_point_s_tpc;
    nwrite = dwDMABufSize/4;
    dis =w_t1 - r_t1;
    while (dis< nwrite) {
      w_t1 = write_point_s_tpc;
      r_t1 = read_point_s_tpc;
      dis =w_t1 - r_t1;
      if (dis < 0) dis = jbuf_ev_size + dis;
      usleep(300);
    }
    //    printf("wp, rp %d, %d \n",write_point_s, read_point_s);
    if((w_t1 > r_t1) | ((jbuf_ev_size -r_t1)>nwrite)) {
      for (is=0; is<nwrite; is++) {
	file_buf[is] = buffer_ev_s_tpc[is+r_t1];
      }
      //     read_point_s = read_point_s+nwrite;
      read_point_tmp = read_point_s_tpc+nwrite;
    }
    else {
      for (is=0; is<(jbuf_ev_size-r_t1); is++) {
	file_buf[is] = buffer_ev_s_tpc[is+r_t1];
      }
      index =0;
      for (is=(jbuf_ev_size-r_t1); is< (nwrite- (jbuf_ev_size-r_t1)); is++) {
	file_buf[is] = buffer_ev_s_tpc[index];
	index = index+1;
      }
      //     read_point_s = index;
      read_point_tmp = index;
    }
    send_array[0] = nwrite;
    n_write = write(fd_sn_pt_tpc,send_array,4);
    n_write = write(fd_sn_pt_tpc,file_buf,(nwrite*4));
    read_point_s_tpc = read_point_tmp;
    printf(" SuperNova write point = %d, read point %d\n", write_point_s_tpc, read_point_s_tpc);
   }
}


//
//
//

int tpc_adc_setup(WDC_DEVICE_HANDLE hDev, int imod_fem, int iframe, int itpc_adc, int ihuff, int icom_factor, int timesize)
{
  
#include "wdc_defs.h"
#define poweroff      0x0
#define poweron       0x1
#define configure_s30 0x2
#define configure_s60 0x3
#define configure_cont 0x20
#define rdstatus      0x80
#define loopback        0x04

#define dcm2_run_off  254
#define dcm2_run_on   255

#define dcm2_online   2
#define dcm2_setmask  3
#define dcm2_offline_busy 4
#define dcm2_load_packet_a 10
#define dcm2_load_packet_b 11
#define dcm2_offline_load 9
#define dcm2_status_read 20
#define dcm2_led_sel     29
#define dcm2_buffer_status_read 30
#define dcm2_status_read_inbuf 21
#define dcm2_status_read_evbuf 22
#define dcm2_status_read_noevnt 23
#define dcm2_zero 12
#define dcm2_compressor_hold 31

#define dcm2_5_readdata 4
#define dcm2_5_firstdcm 8
#define dcm2_5_lastdcm  9
#define dcm2_5_status_read 5
#define dcm2_5_source_id 25
#define dcm2_5_lastchnl 24

#define dcm2_packet_id_a 25
#define dcm2_packet_id_b 26
#define dcm2_hitformat_a 27
#define dcm2_hitformat_b 28

#define part_run_off  254
#define part_run_on   255
#define part_online   2
#define part_offline_busy 3
#define part_offline_hold 4
#define part_status_read 20
#define part_source_id 25


#define  t1_tr_bar 0
#define  t2_tr_bar 4
#define  cs_bar 2

/**  command register location **/

#define  tx_mode_reg 0x28
#define  t1_cs_reg 0x18
#define  r1_cs_reg 0x1c
#define  t2_cs_reg 0x20
#define  r2_cs_reg 0x24

#define  tx_md_reg 0x28

#define  cs_dma_add_low_reg 0x0
#define  cs_dma_add_high_reg  0x4
#define  cs_dma_by_cnt 0x8
#define  cs_dma_cntrl 0xc
#define  cs_dma_msi_abort 0x10

/** define status bits **/

#define  cs_init  0x20000000
#define  cs_mode_p 0x8000000
#define  cs_mode_n 0x0
#define  cs_start 0x40000000
#define  cs_done  0x80000000

#define  dma_tr1  0x100000
#define  dma_tr2  0x200000
#define  dma_tr12 0x300000
#define  dma_3dw_trans 0x0
#define  dma_4dw_trans 0x0
#define  dma_3dw_rec   0x40
#define  dma_4dw_rec   0x60
#define  dma_in_progress 0x80000000

#define  dma_abort 0x2

#define  mb_cntrl_add     0x1
#define  mb_cntrl_test_on 0x1
#define  mb_cntrl_test_off 0x0
#define  mb_cntrl_set_run_on 0x2
#define  mb_cntrl_set_run_off 0x3
#define  mb_cntrl_set_trig1 0x4
#define  mb_cntrl_set_trig2 0x5
#define  mb_cntrl_load_frame 0x6
#define  mb_cntrl_load_trig_pos 0x7

#define  mb_feb_power_add 0x1
#define  mb_feb_conf_add 0x2
#define  mb_feb_pass_add 0x3

#define  mb_feb_lst_on          1
#define  mb_feb_lst_off         0
#define  mb_feb_rxreset         2
#define  mb_feb_align           3
#define  mb_feb_pll_reset       5

#define  mb_feb_adc_align       1
#define  mb_feb_a_nocomp        2
#define  mb_feb_b_nocomp        3
#define  mb_feb_blocksize       4
#define  mb_feb_timesize        5
#define  mb_feb_mod_number      6
#define  mb_feb_a_id            7
#define  mb_feb_b_id            8
#define  mb_feb_max             9

#define  mb_feb_test_source    10
#define  mb_feb_test_sample    11
#define  mb_feb_test_frame     12
#define  mb_feb_test_channel   13
#define  mb_feb_test_ph        14
#define  mb_feb_test_base      15
#define  mb_feb_test_ram_data  16

#define  mb_feb_a_test         17
#define  mb_feb_b_test         18

#define  mb_feb_rd_status      20

#define  mb_feb_a_rdhed        21
#define  mb_feb_a_rdbuf        22
#define  mb_feb_b_rdhed        23
#define  mb_feb_b_rdbuf        24

#define  mb_feb_read_probe     30
#define  mb_feb_dram_reset     31
#define  mb_feb_adc_reset      33

#define  mb_a_buf_status       34
#define  mb_b_buf_status       35
#define  mb_a_ham_status       36
#define  mb_b_ham_status       37

#define  mb_feb_a_maxwords     40
#define  mb_feb_b_maxwords     41

#define  mb_feb_hold_enable    42

#define  mb_pmt_adc_reset       1
#define  mb_pmt_spi_add         2
#define  mb_pmt_adc_data_load   3

#define  mb_xmit_conf_add 0x2
#define  mb_xmit_pass_add 0x3

#define  mb_xmit_modcount 0x1
#define  mb_xmit_enable_1 0x2
#define  mb_xmit_enable_2 0x3
#define  mb_xmit_test1 0x4
#define  mb_xmit_test2 0x5

#define   mb_xmit_testdata  10

#define  mb_xmit_rdstatus 20
#define  mb_xmit_rdcounters 21
#define  mb_xmit_link_reset    22
#define  mb_opt_dig_reset   23
#define  mb_xmit_dpa_fifo_reset    24
#define  mb_xmit_dpa_word_align    25

#define  mb_trig_run                1
#define  mb_trig_frame_size         2
#define  mb_trig_deadtime_size      3
#define  mb_trig_active_size        4
#define  mb_trig_delay1_size        5
#define  mb_trig_delay2_size        6

#define  mb_trig_calib_delay        8

#define  mb_trig_prescale0         10
#define  mb_trig_prescale1         11
#define  mb_trig_prescale2         12
#define  mb_trig_prescale3         13
#define  mb_trig_prescale4         14
#define  mb_trig_prescale5         15
#define  mb_trig_prescale6         16
#define  mb_trig_prescale7         17
#define  mb_trig_prescale8         18

#define  mb_trig_mask0             20
#define  mb_trig_mask1             21
#define  mb_trig_mask2             22
#define  mb_trig_mask3             23
#define  mb_trig_mask4             24
#define  mb_trig_mask5             25
#define  mb_trig_mask6             26
#define  mb_trig_mask7             27
#define  mb_trig_mask8             28

#define  mb_trig_rd_param          30
#define  mb_trig_pctrig            31
#define  mb_trig_rd_status         32
#define  mb_trig_reset             33
#define  mb_trig_calib             34
#define  mb_trig_rd_gps            35

#define  mb_trig_sel1              40
#define  mb_trig_sel2              41
#define  mb_trig_sel3              42
#define  mb_trig_sel4              43

#define  mb_trig_p1_delay          50
#define  mb_trig_p1_width          51
#define  mb_trig_p2_delay          52
#define  mb_trig_p2_width          53
#define  mb_trig_p3_delay          54
#define  mb_trig_p3_width          55
#define  mb_trig_pulse_delay       58

#define  mb_trig_pulse1            60
#define  mb_trig_pulse2            61
#define  mb_trig_pulse3            62

#define  mb_shaper_pulsetime        1
#define  mb_shaper_dac              2
#define  mb_shaper_pattern          3
#define  mb_shaper_write            4
#define  mb_shaper_pulse            5
#define  mb_shaper_entrig           6

#define  mb_feb_pmt_gate_size      47
#define  mb_feb_pmt_beam_delay     48
#define  mb_feb_pmt_beam_size      49

#define  mb_feb_pmt_ch_set         50
#define  mb_feb_pmt_delay0         51
#define  mb_feb_pmt_delay1         52
#define  mb_feb_pmt_precount       53
#define  mb_feb_pmt_thresh0        54
#define  mb_feb_pmt_thresh1        55
#define  mb_feb_pmt_thresh2        56
#define  mb_feb_pmt_thresh3        57
#define  mb_feb_pmt_width          58
#define  mb_feb_pmt_deadtime       59
#define  mb_feb_pmt_window         60
#define  mb_feb_pmt_words          61
#define  mb_feb_pmt_cos_mul        62
#define  mb_feb_pmt_cos_thres      63
#define  mb_feb_pmt_mich_mul       64
#define  mb_feb_pmt_mich_thres     65
#define  mb_feb_pmt_beam_mul       66
#define  mb_feb_pmt_beam_thres     67
#define  mb_feb_pmt_en_top         68
#define  mb_feb_pmt_en_upper       69
#define  mb_feb_pmt_en_lower       70
#define  mb_feb_pmt_blocksize      71

#define  mb_feb_pmt_test           80
#define  mb_feb_pmt_clear          81
#define  mb_feb_pmt_test_data      82
#define  mb_feb_pmt_pulse          83

#define  mb_feb_pmt_rxreset        84
#define  mb_feb_pmt_align_pulse    85
#define  mb_feb_pmt_rd_counters    86

#define  dma_buffer_size        10000000


  static UINT32 u32Data;
  static unsigned short u16Data;
  
  static long imod,ichip;
  unsigned short *buffp;
  
  
  static UINT32 i,j,k,ifr,nread,iprint,iwrite,ik,il,is,checksum;
  
  static UINT32 send_array[40000],read_array[1000];
  
  static UINT32 nmask,index,itmp,nword_tot,nevent,iv,ijk,islow_read;
  static UINT32 imod_p,imod_trig,imod_shaper;
  
  static int icomp_l,comp_s,ia,ic;
  
  DWORD dwStatus;
  DWORD dwOptions = DMA_FROM_DEVICE;
  UINT32 iread,icheck,izero;
  UINT32 buf_send[40000];
  static int   count,num,counta,nword,ireadback,nloop,ierror;
  static int   ij,nsend,iloop,inew,idma_readback,iadd,jevent;
  static int   itest,irun,ichip_c,dummy1,itrig_c;
  static int   idup,ihold,idouble,ihold_set,istatus_read;
  static int   idone,tr_bar,t_cs_reg,r_cs_reg,dma_tr;
  static int   ipulse,ibase,a_id,itrig_delay;
  static int   iset,ncount,nsend_f,nwrite,itrig_ext;
  static int   imod_xmit,idiv,isample,irand;
  static int   iframe_length, itrig,idrift_time,ijtrig;
  static int   idelay0, idelay1, threshold0, threshold1, pmt_words;
  static int   cos_mult, cos_thres, en_top, en_upper, en_lower;
  static int   irise, ifall, istart_time, use_pmt, pmt_testpulse;
  static int   ich_head, ich_sample, ich_frm,idebug,ntot_rec,nred;
  static int   ineu,ibusy_send,ibusy_test,ihold_word,ndma_loop;
  static int   irawprint,ifem_fst,ifem_lst,ifem_loop;
  static int   pmt_deadtime,pmt_mich_window;
  static int   oframe,osample,odiv,cframe,csample,cdiv;
  static int   idac_shaper, pmt_dac_scan, pmt_precount;
  unsigned char    charchannel;
  unsigned char    carray[4000];
  struct timespec tim, tim2;
  tim.tv_sec = 0;
  tim.tv_nsec =128000;
  
  
  PVOID pbuf_rec;
  WD_DMA *pDma_rec;
  DWORD dwOptions_send = DMA_TO_DEVICE | DMA_ALLOW_CACHE;
  //    DWORD dwOptions_rec = DMA_FROM_DEVICE | DMA_ALLOW_CACHE | DMA_ALLOW_64BIT_ADDRESS;
  DWORD dwOptions_rec = DMA_FROM_DEVICE | DMA_ALLOW_64BIT_ADDRESS;
  
  
  UINT32 *px, *py, *py1;
  
  FILE *outf,*inpf;
  //
  //
  //
  px = &buf_send;
  py = &read_array;
  
  irand =0;
  imod = imod_fem;
  ichip =1;
  buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_power_add+(0x0<<16); //turn module 11 power on
  i=1;
  k=1;
  i = pcie_send(hDev, i, k, px);
  
  usleep(200000);  // wait for 200 ms
  //
  usleep(10000);   // wait for 10ms
  inpf = fopen("/home/ub/feb_fpga_test_new_head","r");
  printf(" start booting FEM %d\n", imod);
  ichip=mb_feb_conf_add;
  buf_send[0]=(imod<<11)+(ichip<<8)+0x0+(0x0<<16);  // turn conf to be on
  i=1;
  k=1;
  i = pcie_send(hDev, i, k, px);
  //      for (i=0; i<100000; i++) {
  //          ik= i%2;
  //          dummy1= (ik+i)*(ik+i);
  //      }
  
  
  /* read data as characters (28941) */
  usleep(1000);   // wait fior a while
  nsend = 500;
  count = 0;
  counta= 0;
  ichip_c = 7; // set ichip_c to stay away from any other command in the
  dummy1 =0;
  while (fread(&charchannel,sizeof(char),1,inpf)==1) {
    carray[count] = charchannel;
    count++;
    counta++;
    if((count%(nsend*2)) == 0) {
      buf_send[0] = (imod <<11) +(ichip_c <<8)+ (carray[0]<<16);
      send_array[0] =buf_send[0];
      if(dummy1 <= 5 ) printf(" counta = %d, first word = %x, %x, %x %x %x \n",counta,buf_send[0], carray[0], carray[1]
			      ,carray[2], carray[3]);
      for (ij=0; ij< nsend; ij++) {
	if(ij== (nsend-1)) buf_send[ij+1] = carray[2*ij+1]+(0x0<<16);
	else buf_send[ij+1] = carray[2*ij+1]+ (carray[2*ij+2]<<16);
	//      buf_send[ij+1] = carray[2*ij+1]+ (carray[2*ij+2]<<16);
	send_array[ij+1] = buf_send[ij+1];
      }
      nword =nsend+1;
      i=1;
      //       if(dummy1 == 0)
      ij = pcie_send(hDev, i, nword, px);
      nanosleep(&tim , &tim2);
      dummy1 = dummy1+1;
      count =0;
    }
  }
  if(feof(inpf)) {
    printf("You have reached the end-of-file word count= %d %d\n", counta, count);
    buf_send[0] = (imod <<11) +(ichip_c <<8)+ (carray[0]<<16);
    if ( count > 1) {
      if( ((count-1)%2) ==0) {
	ik =(count-1)/2;
      }
      else {
	ik =(count-1)/2+1;
      }
      ik=ik+2;   // add one more for safety
      printf("ik= %d\n",ik);
      for (ij=0; ij<ik; ij++){
	if(ij == (ik-1)) buf_send[ij+1] = carray[(2*ij)+1]+(((imod<<11)+(ichip<<8)+0x0)<<16);
	else buf_send[ij+1] = carray[(2*ij)+1]+ (carray[(2*ij)+2]<<16);
	send_array[ij+1] = buf_send[ij+1];
      }
    }
    else ik=1;
    
    for (ij=ik-10; ij< ik+1; ij++) {
      printf("Last data = %d, %x\n",ij,buf_send[ij]);
    }
    nword =ik+1;
    i=1;
    i = pcie_send(hDev, i, nword, px);
  }
  usleep(2000);    // wait for 2ms to cover the packet time plus fpga init time
  fclose(inpf);
  //
  //
  //
  printf(" enter 1 to continue \n");
  scanf("%d",&ik);
  //
  //
  //
  ichip=3;
  buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_dram_reset+(0x1<<16);  // turm the DRAM reset on
  i=1;
  k=1;
  i = pcie_send(hDev, i, k, px);
  //        imod=11;
  ichip=3;
  buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_dram_reset+(0x0<<16);  // turm the DRAM reset off
  i=1;
  k=1;
  i = pcie_send(hDev, i, k, px);
  
  usleep(5000);    // wait for 5 ms for DRAM to be initialized
  
  //         imod=11;
  ichip=3;
  buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_mod_number+(imod<<16);  // set module number
  i=1;
  k=1;
  i = pcie_send(hDev, i, k, px);
  //
  //
  nword =1;
  
  i = pcie_rec(hDev,0,1,nword,iprint,py);     // init the receiver
  
  //         imod=11;
  ichip=3;
  buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_rd_status+(0x0<<16);  // read out status
  i=1;
  k=1;
  i = pcie_send(hDev, i, k, px);
  py = &read_array;
  i = pcie_rec(hDev,0,2,nword,iprint,py);     // read out 2 32 bits words
  printf("receive data word = %x, %x \n", read_array[0], read_array[1]);
  
  if(itpc_adc == 1) {
    //
    //      readback status
    //
    i = pcie_rec(hDev,0,1,nword,iprint,py);     // init the receiver
    
    imod=imod_fem;
    ichip=3;
    buf_send[0]=(imod<<11)+(ichip<<8)+20+(0x0<<16);  // read out status
    i=1;
    k=1;
    i = pcie_send(hDev, i, k, px);
    py = &read_array;
    i = pcie_rec(hDev,0,2,nword,iprint,py);     // read out 2 32 bits words
    //
    //
    printf("receiv e data word -- after reset = %x, %x \n", read_array[0], read_array[1]);
    printf(" module = %d, command = %d \n", ((read_array[0]>>11) & 0x1f), (read_array[0] &0xff));
    printf(" ADC right dpa lock     %d \n", ((read_array[0]>>17) & 0x1));
    printf(" ADC left  dpa lock     %d \n", ((read_array[0]>>18) & 0x1));
    printf(" block error 2          %d \n", ((read_array[0]>>19) & 0x1));
    printf(" block error 1          %d \n", ((read_array[0]>>20) & 0x1));
    printf(" pll lcoked             %d \n", ((read_array[0]>>21) & 0x1));
    printf(" superNova mem ready    %d \n", ((read_array[0]>>22) & 0x1));
    printf(" beam      mem ready    %d \n", ((read_array[0]>>23) & 0x1));
    printf(" ADC right PLL locked   %d \n", ((read_array[0]>>24) & 0x1));
    printf(" ADC left PLL locked    %d \n", ((read_array[0]>>25) & 0x1));
    printf(" ADC align cmd right    %d \n", ((read_array[0]>>26) & 0x1));
    printf(" ADC align cmd left     %d \n", ((read_array[0]>>27) & 0x1));
    printf(" ADC align done right   %d \n", ((read_array[0]>>28) & 0x1));
    printf(" ADC align done left    %d \n", ((read_array[0]>>29) & 0x1));
    printf(" Neutrino data empty    %d \n", ((read_array[0]>>30) & 0x1));
    printf(" Neutrino Header empty  %d \n", ((read_array[0]>>31) & 0x1));
    
    //
    //    the ADC spi stream.. The 16 bits data before the last word is r/w, w1, w2 and 13 bits address
    //                         the last 16 bits.upper byte = 8 bits data and lower 8 bits ignored.
    //
    for (is=0; is<8; is++) {
      //      imod=11;
      ichip=5;
      buf_send[0]=(imod<<11)+(ichip<<8)+(mb_pmt_spi_add)+((is & 0xf)<<16); //set spi address
      i=1;
      k=1;
      i = pcie_send(hDev, i, k, px);
      usleep(2000);   // sleep for 2ms
      printf(" spi port %d \n",is);
      //       scanf("%d",&ik);
      
      //      imod=11;
      ichip=5;
      buf_send[0]=(imod<<11)+(ichip<<8)+(mb_pmt_adc_data_load)+(0x0300<<16); //1st next word will be overwrite by the next next word
      buf_send[1]=(((0x0)<<13)+(0xd))+((0xc)<<24)+((0x0)<<16);
      //        buf_send[1]=(((0x0)<<13)+(0xd))+((0x0)<<24)+((0x0)<<16);
      //
      //  set /w =0, w1,w2 =0, a12-a0 = 0xd, data =0xb;
      //
      
      i=1;
      k=2;
      i = pcie_send(hDev, i, k, px);
      usleep(2000);   // sleep for 2ms
      printf(" spi port 2nd command %d \n",is);
      //       scanf("%d",&ik);
      
      //      imod=11;
      ichip=5;
      buf_send[0]=(imod<<11)+(ichip<<8)+(mb_pmt_adc_data_load)+(0x0300<<16); //1st next word will be overwrite by the next next word
      buf_send[1]=(((0x0)<<13)+(0xff))+((0x1)<<24)+((0x0)<<16);
      //
      //  set /w =0, w1,w2 =0, a12-a0 = 0xff, data =0x1;
      //  write to transfer register
      //
      
      i=1;
      k=2;
      i = pcie_send(hDev, i, k, px);
      usleep(2000);   // sleep for 2ms
      
    }
    
    //       printf(" enter 1 to continue FPGA ADC receiver reset\n");
    //       scanf("%d",&ik);
    //
    //    send FPGA ADC receiver reset
    //
    //      imod=11;
    ichip=3;
    buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_adc_reset+(0x1<<16);  // FPGA ADC receiver reset on
    i=1;
    k=1;
    i = pcie_send(hDev, i, k, px);
    
    
    //       printf(" enter 1 to continue FPGA ADC receiver align\n");
    //       scanf("%d",&ik);
    //
    //    send FPGA ADC align
    //
    //      imod=11;
    ichip=3;
    buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_adc_align+(0x0<<16);  // FPGA ADC receiver reset off
    i=1;
    k=1;
    i = pcie_send(hDev, i, k, px);
    usleep(1000);
    //
    //
    //
    //
    //     scanf("%d", &i);
    //
    nword = 2;
    i = pcie_rec(hDev,0,1,nword,iprint,py);     // init the receiver
    //
    imod=imod_fem;
    ichip=3;
    buf_send[0]=(imod<<11)+(ichip<<8)+20+(0x0<<16);  // read out status
    i=1;
    k=1;
    i = pcie_send(hDev, i, k, px);
    //     scanf("%d", &i);
    usleep(10);
    py = &read_array;
    read_array[0] =0;
    i = pcie_rec(hDev,0,2,nword,iprint,py);     // read out 2 32 bits words
    usleep(10);
    //
    printf("receiv e data word -- after reset = %x, %x \n", read_array[0], read_array[1]);
    printf(" module = %d, command = %d \n", ((read_array[0]>>11) & 0x1f), (read_array[0] &0xff));
    printf(" ADC right dpa lock     %d \n", ((read_array[0]>>17) & 0x1));
    printf(" ADC left  dpa lock     %d \n", ((read_array[0]>>18) & 0x1));
    printf(" block error 2          %d \n", ((read_array[0]>>19) & 0x1));
    printf(" block error 1          %d \n", ((read_array[0]>>20) & 0x1));
    printf(" pll lcoked             %d \n", ((read_array[0]>>21) & 0x1));
    printf(" superNova mem ready    %d \n", ((read_array[0]>>22) & 0x1));
    printf(" beam      mem ready    %d \n", ((read_array[0]>>23) & 0x1));
    printf(" ADC right PLL locked   %d \n", ((read_array[0]>>24) & 0x1));
    printf(" ADC left PLL locked    %d \n", ((read_array[0]>>25) & 0x1));
    printf(" ADC align cmd right    %d \n", ((read_array[0]>>26) & 0x1));
    printf(" ADC align cmd left     %d \n", ((read_array[0]>>27) & 0x1));
    printf(" ADC align done right   %d \n", ((read_array[0]>>28) & 0x1));
    printf(" ADC align done left    %d \n", ((read_array[0]>>29) & 0x1));
    printf(" Neutrino data empty    %d \n", ((read_array[0]>>30) & 0x1));
    printf(" Neutrino Header empty  %d \n", ((read_array[0]>>31) & 0x1));
    
    //       printf(" finish align \n");
    //       scanf("%d",&ik);
    //
    //    the ADC spi stream.. The 16 bits data before the last word is r/w, w1, w2 and 13 bits address
    //                         the last 16 bits.upper byte = 8 bits data and lower 8 bits ignored.
    //
    for (is=0; is<8; is++) {
      //        imod=11;
      ichip=5;
      buf_send[0]=(imod<<11)+(ichip<<8)+(mb_pmt_spi_add)+((is & 0xf)<<16); //set spi address
      i=1;
      k=1;
      i = pcie_send(hDev, i, k, px);
      usleep(2000);   // sleep for 2ms
      printf(" spi port %d \n",is);
      //       scanf("%d",&ik);
      
      //        imod=11;
      ichip=5;
      buf_send[0]=(imod<<11)+(ichip<<8)+(mb_pmt_adc_data_load)+(0x0300<<16); //1st next word will be overwrite by the next next word
      //        buf_send[1]=(((0x0)<<13)+(0xd))+((0x9)<<24)+((0x0)<<16);
      buf_send[1]=(((0x0)<<13)+(0xd))+((0x0)<<24)+((0x0)<<16);
      //
      //  set /w =0, w1,w2 =0, a12-a0 = 0xd, data =0xb;
      //
      
      i=1;
      k=2;
      i = pcie_send(hDev, i, k, px);
      usleep(2000);   // sleep for 2ms
      printf(" spi port 2nd command %d \n",is);
      //       scanf("%d",&ik);
      
      //       imod=11;
      ichip=5;
      buf_send[0]=(imod<<11)+(ichip<<8)+(mb_pmt_adc_data_load)+(0x0300<<16); //1st next word will be overwrite by the next next word
      buf_send[1]=(((0x0)<<13)+(0xff))+((0x1)<<24)+((0x0)<<16);
      //
      //  set /w =0, w1,w2 =0, a12-a0 = 0xff, data =0x1;
      //  write to transfer register
      //
      
      i=1;
      k=2;
      i = pcie_send(hDev, i, k, px);
      usleep(2000);   // sleep for 2ms
      
    }
  }
  else {
    nword =1;
    //
    // set to use test generator 2, set test =2
    //
    //       imod=11;
    ichip=mb_feb_pass_add;
    buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_test_source+(0x2<<16);  // set test source to 2
    i=1;
    k=1;
    i = pcie_send(hDev, i, k, px);
    
    
    //
    //    start loading the test 2 data memory
    //
    //       imod =11;
    ichip=3;
    for (is=0; is<64; is++) {
      ik = 0x4000+is;                        // load channel address
      buf_send[0]=(imod<<11)+(ichip<<8)+(mb_feb_test_ram_data)+((ik & 0xffff)<<16); // load channe address
      i = pcie_send(hDev, 1, 1, px);
      ibase = 32*is;
      il = is%8;
      if(il == 0) printf(" loading channel %d\n",is);
      for (ik=0; ik< 256; ik++) {                 // loop over all possible address
	if(irand ==1) ijk = rand() & 0xfff ;        // use random number
	else ijk= (ibase+ik*8) & 0xfff;
	//          else {
	//            if(ik ==0) ijk =0x111;
	//            else ijk= (ibase+ik*8) & 0xfff;
	//           }
	if(ihuff == 1) {
	  if((ik%icom_factor) ==0) ic =ijk;        // set data to repeat for 4 samples....
	  ijk=ic;
	}
	k = 0x8000+ ijk;        // make sure bit 15-12 is clear for the data
	buf_send[0]=(imod<<11)+(ichip<<8)+(mb_feb_test_ram_data)+((k & 0xffff)<<16); // load test data
	i = pcie_send(hDev, 1, 1, px);
	send_array[is*256+ik]=ijk;           //load up data map
      }
    }
    ichip=3;
    if(ihuff == 1) buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_b_nocomp+(0x0<<16);  // turn the compression
    else buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_b_nocomp+(0x1<<16);  // set b channel no compression
    i=1;
    k=1;
    i = pcie_send(hDev, i, k, px);
  }
  //
  //
  //    set compression or not
  //
  ichip =3;
  if(ihuff == 1)buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_a_nocomp+(0x0<<16);  // turn the compression
  else buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_a_nocomp+(0x1<<16);  // set b channel no compression
  i=1;
  k=1;
  i = pcie_send(hDev, i, k, px);
  //    printf(" type 1 to continue, ihuff = %d\n", ihuff);
  //    scanf("%d", &i);
  //    if(ihuff == 1) buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_b_nocomp+(0x0<<16);  // turn the compression
  //    else buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_b_nocomp+(0x1<<16);  // set b channel no compression
  
  buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_b_nocomp+(0x0<<16); // always turn on supernova compression
  i=1;
  k=1;
  i = pcie_send(hDev, i, k, px);
  
  //         timesize =4;
  //         imod=11;
  ichip=3;
  buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_timesize+(timesize<<16);  // set drift time size
  i=1;
  k=1;
  i = pcie_send(hDev, i, k, px);
  
  a_id =0xf;
  //         imod=11;
  ichip=3;
  buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_b_id+(a_id<<16);  // set a_id
  i=1;
  k=1;
  i = pcie_send(hDev, i, k, px);
  
  //       imod=11;
  ichip=4;
  buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_b_id+(a_id<<16);  // set b_id
  i=1;
  k=1;
  i = pcie_send(hDev, i, k, px);
  //
  //     set max word in the pre-buffer memory
  //
  ik=8000;
  //         imod=11;
  ichip=3;
  buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_max+(ik<<16);  // set pre-buffer max word
  i=1;
  k=1;
  i = pcie_send(hDev, i, k, px);
  //
  //
  //
  //     enable hold
  //
  //         imod=11;
  imod = imod_fem;
  ichip=3;
  buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_hold_enable+(0x1<<16);  // enable the hold
  i=1;
  k=1;
  i = pcie_send(hDev, i, k, px);
  return i;
}

static int pmt_adc_setup(WDC_DEVICE_HANDLE hDev, int imod_fem, int iframe)
{

#include "wdc_defs.h"
#define poweroff      0x0
#define poweron       0x1
#define configure_s30 0x2
#define configure_s60 0x3
#define configure_cont 0x20
#define rdstatus      0x80
#define loopback        0x04

#define dcm2_run_off  254
#define dcm2_run_on   255

#define dcm2_online   2
#define dcm2_setmask  3
#define dcm2_offline_busy 4
#define dcm2_load_packet_a 10
#define dcm2_load_packet_b 11
#define dcm2_offline_load 9
#define dcm2_status_read 20
#define dcm2_led_sel     29
#define dcm2_buffer_status_read 30
#define dcm2_status_read_inbuf 21
#define dcm2_status_read_evbuf 22
#define dcm2_status_read_noevnt 23
#define dcm2_zero 12
#define dcm2_compressor_hold 31

#define dcm2_5_readdata 4
#define dcm2_5_firstdcm 8
#define dcm2_5_lastdcm  9
#define dcm2_5_status_read 5
#define dcm2_5_source_id 25
#define dcm2_5_lastchnl 24

#define dcm2_packet_id_a 25
#define dcm2_packet_id_b 26
#define dcm2_hitformat_a 27
#define dcm2_hitformat_b 28

#define part_run_off  254
#define part_run_on   255
#define part_online   2
#define part_offline_busy 3
#define part_offline_hold 4
#define part_status_read 20
#define part_source_id 25


#define  t1_tr_bar 0
#define  t2_tr_bar 4
#define  cs_bar 2

/**  command register location **/

#define  tx_mode_reg 0x28
#define  t1_cs_reg 0x18
#define  r1_cs_reg 0x1c
#define  t2_cs_reg 0x20
#define  r2_cs_reg 0x24

#define  tx_md_reg 0x28

#define  cs_dma_add_low_reg 0x0
#define  cs_dma_add_high_reg  0x4
#define  cs_dma_by_cnt 0x8
#define  cs_dma_cntrl 0xc
#define  cs_dma_msi_abort 0x10

/** define status bits **/

#define  cs_init  0x20000000
#define  cs_mode_p 0x8000000
#define  cs_mode_n 0x0
#define  cs_start 0x40000000
#define  cs_done  0x80000000

#define  dma_tr1  0x100000
#define  dma_tr2  0x200000
#define  dma_tr12 0x300000
#define  dma_3dw_trans 0x0
#define  dma_4dw_trans 0x0
#define  dma_3dw_rec   0x40
#define  dma_4dw_rec   0x60
#define  dma_in_progress 0x80000000

#define  dma_abort 0x2

#define  mb_cntrl_add     0x1
#define  mb_cntrl_test_on 0x1
#define  mb_cntrl_test_off 0x0
#define  mb_cntrl_set_run_on 0x2
#define  mb_cntrl_set_run_off 0x3
#define  mb_cntrl_set_trig1 0x4
#define  mb_cntrl_set_trig2 0x5
#define  mb_cntrl_load_frame 0x6
#define  mb_cntrl_load_trig_pos 0x7

#define  mb_feb_power_add 0x1
#define  mb_feb_conf_add 0x2
#define  mb_feb_pass_add 0x3

#define  mb_feb_lst_on          1
#define  mb_feb_lst_off         0
#define  mb_feb_rxreset         2
#define  mb_feb_align           3
#define  mb_feb_pll_reset       5


#define  mb_feb_adc_align       1
#define  mb_feb_a_nocomp        2
#define  mb_feb_b_nocomp        3
#define  mb_feb_blocksize       4
#define  mb_feb_timesize        5
#define  mb_feb_mod_number      6
#define  mb_feb_a_id            7
#define  mb_feb_b_id            8
#define  mb_feb_max             9

#define  mb_feb_test_source    10
#define  mb_feb_test_sample    11
#define  mb_feb_test_frame     12
#define  mb_feb_test_channel   13
#define  mb_feb_test_ph        14
#define  mb_feb_test_base      15
#define  mb_feb_test_ram_data  16

#define  mb_feb_a_test         17
#define  mb_feb_b_test         18

#define  mb_feb_rd_status      20

#define  mb_feb_a_rdhed        21
#define  mb_feb_a_rdbuf        22
#define  mb_feb_b_rdhed        23
#define  mb_feb_b_rdbuf        24

#define  mb_feb_read_probe     30
#define  mb_feb_dram_reset     31
#define  mb_feb_adc_reset      33

#define  mb_a_buf_status       34
#define  mb_b_buf_status       35
#define  mb_a_ham_status       36
#define  mb_b_ham_status       37

#define  mb_feb_a_maxwords     40
#define  mb_feb_b_maxwords     41

#define  mb_feb_hold_enable    42

#define  mb_pmt_adc_reset       1
#define  mb_pmt_spi_add         2
#define  mb_pmt_adc_data_load   3

#define  mb_xmit_conf_add 0x2
#define  mb_xmit_pass_add 0x3

#define  mb_xmit_modcount 0x1
#define  mb_xmit_enable_1 0x2
#define  mb_xmit_enable_2 0x3
#define  mb_xmit_test1 0x4
#define  mb_xmit_test2 0x5

#define   mb_xmit_testdata  10

#define  mb_xmit_rdstatus 20
#define  mb_xmit_rdcounters 21
#define  mb_xmit_link_reset    22
#define  mb_opt_dig_reset   23
#define  mb_xmit_dpa_fifo_reset    24
#define  mb_xmit_dpa_word_align    25

#define  mb_trig_run                1
#define  mb_trig_frame_size         2
#define  mb_trig_deadtime_size      3
#define  mb_trig_active_size        4
#define  mb_trig_delay1_size        5
#define  mb_trig_delay2_size        6

#define  mb_trig_calib_delay        8

#define  mb_trig_prescale0         10
#define  mb_trig_prescale1         11
#define  mb_trig_prescale2         12
#define  mb_trig_prescale3         13
#define  mb_trig_prescale4         14
#define  mb_trig_prescale5         15
#define  mb_trig_prescale6         16
#define  mb_trig_prescale7         17
#define  mb_trig_prescale8         18

#define  mb_trig_mask0             20
#define  mb_trig_mask1             21
#define  mb_trig_mask2             22
#define  mb_trig_mask3             23
#define  mb_trig_mask4             24
#define  mb_trig_mask5             25
#define  mb_trig_mask6             26
#define  mb_trig_mask7             27
#define  mb_trig_mask8             28

#define  mb_trig_rd_param          30
#define  mb_trig_pctrig            31
#define  mb_trig_rd_status         32
#define  mb_trig_reset             33
#define  mb_trig_calib             34
#define  mb_trig_rd_gps            35

#define  mb_trig_sel1              40
#define  mb_trig_sel2              41
#define  mb_trig_sel3              42
#define  mb_trig_sel4              43

#define  mb_trig_p1_delay          50
#define  mb_trig_p1_width          51
#define  mb_trig_p2_delay          52
#define  mb_trig_p2_width          53
#define  mb_trig_p3_delay          54
#define  mb_trig_p3_width          55
#define  mb_trig_pulse_delay       58

#define  mb_trig_pulse1            60
#define  mb_trig_pulse2            61
#define  mb_trig_pulse3            62

#define  mb_shaper_pulsetime        1
#define  mb_shaper_dac              2
#define  mb_shaper_pattern          3
#define  mb_shaper_write            4
#define  mb_shaper_pulse            5
#define  mb_shaper_entrig           6

#define  mb_feb_pmt_gate_size      47
#define  mb_feb_pmt_beam_delay     48
#define  mb_feb_pmt_beam_size      49

#define  mb_feb_pmt_ch_set         50
#define  mb_feb_pmt_delay0         51
#define  mb_feb_pmt_delay1         52
#define  mb_feb_pmt_precount       53
#define  mb_feb_pmt_thresh0        54
#define  mb_feb_pmt_thresh1        55
#define  mb_feb_pmt_thresh2        56
#define  mb_feb_pmt_thresh3        57
#define  mb_feb_pmt_width          58
#define  mb_feb_pmt_deadtime       59
#define  mb_feb_pmt_window         60
#define  mb_feb_pmt_words          61
#define  mb_feb_pmt_cos_mul        62
#define  mb_feb_pmt_cos_thres      63
#define  mb_feb_pmt_mich_mul       64
#define  mb_feb_pmt_mich_thres     65
#define  mb_feb_pmt_beam_mul       66
#define  mb_feb_pmt_beam_thres     67
#define  mb_feb_pmt_en_top         68
#define  mb_feb_pmt_en_upper       69
#define  mb_feb_pmt_en_lower       70
#define  mb_feb_pmt_blocksize      71

#define  mb_feb_pmt_test           80
#define  mb_feb_pmt_clear          81
#define  mb_feb_pmt_test_data      82
#define  mb_feb_pmt_pulse          83

#define  mb_feb_pmt_rxreset        84
#define  mb_feb_pmt_align_pulse    85
#define  mb_feb_pmt_rd_counters    86

#define  dma_buffer_size        10000000

//    static DWORD dwAddrSpace;

    static UINT32 u32Data;
    static unsigned short u16Data;
//    static unsigned long long u64Data, u64Data1;
//    static DWORD dwOffset;
    static long imod,ichip;
    unsigned short *buffp;

/*
    WDC_ADDR_MODE mode;
    WDC_ADDR_RW_OPTIONS options;
*/
    static UINT32 i,j,k,ifr,nread,iprint,iwrite,ik,il,is,checksum;
//    static UINT32 istop,newcmd,irand,ioffset,kword,lastchnl,ib;
    static UINT32 send_array[40000],read_array[1000];
//    ,read_array1[40000];
//    static UINT32 read_array_c[40000];
//    static UINT32 read_comp[8000];
    static UINT32 nmask,index,itmp,nword_tot,nevent,iv,ijk,islow_read;
    static UINT32 imod_p,imod_trig,imod_shaper;
//    unsigned short idcm_read_array[40000],read_array_s[1600000];
//    static UINT32 idcm_read_array32[40000];
//    static UINT32 idcm_send_array[400000];
//    static UINT32 idcm_verify_array[400000];
    static int icomp_l,comp_s,ia,ic,ihuff;
//    UINT32 *idcm_send_p,*idcm_verify_p,*pbuffp_rec;
//    DWORD dwDMABufSize;
//    PVOID pbuf;
//    WD_DMA *pDma;
    DWORD dwStatus;
    DWORD dwOptions = DMA_FROM_DEVICE;
    UINT32 iread,icheck,izero;
    UINT32 buf_send[40000];
    static int   count,num,counta,nword,ireadback,nloop,ierror;
    static int   ij,nsend,iloop,inew,idma_readback,iadd,jevent;
    static int   itest,irun,ichip_c,dummy1,itrig_c;
    static int  idup,ihold,idouble,ihold_set,istatus_read;
    static int  idone,tr_bar,t_cs_reg,r_cs_reg,dma_tr;
    static int   timesize,ipulse,ibase,a_id,itrig_delay;
    static int   iset,ncount,nsend_f,nwrite,itrig_ext;
    static int   imod_xmit,idiv,isample;
    static int   iframe_length, itrig,idrift_time,ijtrig;
    static int   idelay0, idelay1, threshold0, threshold1, pmt_words;
    static int   cos_mult, cos_thres, en_top, en_upper, en_lower;
    static int   irise, ifall, istart_time, use_pmt, pmt_testpulse;
    static int   ich_head, ich_sample, ich_frm,idebug,ntot_rec,nred;
    static int   ineu,ibusy_send,ibusy_test,ihold_word,ndma_loop;
    static int   irawprint,ifem_fst,ifem_lst,ifem_loop;
    static int   pmt_deadtime,pmt_mich_window;
    static int   oframe,osample,odiv,cframe,csample,cdiv;
    static int   idac_shaper, pmt_dac_scan, pmt_precount;
    unsigned char    charchannel;
    unsigned char    carray[4000];
    struct timespec tim, tim2;
    tim.tv_sec = 0;
    tim.tv_nsec =128000;


    PVOID pbuf_rec;
    WD_DMA *pDma_rec;
    DWORD dwOptions_send = DMA_TO_DEVICE | DMA_ALLOW_CACHE;
//    DWORD dwOptions_rec = DMA_FROM_DEVICE | DMA_ALLOW_CACHE | DMA_ALLOW_64BIT_ADDRESS;
    DWORD dwOptions_rec = DMA_FROM_DEVICE | DMA_ALLOW_64BIT_ADDRESS;


    UINT32 *px, *py, *py1;

    FILE *outf,*inpf;

//
//
//
    pmt_deadtime = 41; ///set deadtime long so it will not double fired on trailling edge
    pmt_mich_window = 2;
//
//
    threshold0 = 10;   // 100 discriminator threshold 0
    threshold1 = 15;   // 150 discriminator threshold 1
    cos_mult = 1;       // cosmic ray multiplicity threshold
    cos_thres = 20;    // cosmic ray sum ph threshold
    pmt_precount = 1; // set PMT precount
    pmt_words=40;      // number of word to read

//
//
//
 // turn on the Stratix III power supply

    px = &buf_send;
    py = &read_array;

    imod=imod_fem;
    ichip =1;
    buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_power_add+(0x0<<16); //turn module 11 power on
    i=1;
    k=1;
    i = pcie_send(hDev, i, k, px);
//
    usleep(200000);  // wait for 200 ms
//     printf(" enable number of loop\n");
//     scanf("%d",&nloop);

    usleep(10000); // wait for 10ms
    inpf = fopen("/home/ub/feb_pmt_fpga_test_new_head","r");
    imod=imod_fem;
    ichip=mb_feb_conf_add;
    buf_send[0]=(imod<<11)+(ichip<<8)+0x0+(0x0<<16);  // turn conf to be on
    i=1;
    k=1;
    i = pcie_send(hDev, i, k, px);
//      for (i=0; i<100000; i++) {
//          ik= i%2;
//          dummy1= (ik+i)*(ik+i);
//      }

             /* read data as characters (28941) */
    usleep(1000);   // wait fior a while
    nsend = 500;
    count = 0;
    counta= 0;
    ichip_c = 7; // set ichip_c to stay away from any other command in the
    dummy1 =0;
    while (fread(&charchannel,sizeof(char),1,inpf)==1) {
     carray[count] = charchannel;
     count++;
     counta++;
     if((count%(nsend*2)) == 0) {
//        printf(" loop = %d\n",dummy1);
      buf_send[0] = (imod <<11) +(ichip_c <<8)+ (carray[0]<<16);
      send_array[0] =buf_send[0];
      if(dummy1 <= 5 ) printf(" counta = %d, first word = %x, %x, %x %x %x \n",counta,buf_send[0], carray[0], carray[1]
      ,carray[2], carray[3]);
      for (ij=0; ij< nsend; ij++) {
       if(ij== (nsend-1)) buf_send[ij+1] = carray[2*ij+1]+(0x0<<16);
       else buf_send[ij+1] = carray[2*ij+1]+ (carray[2*ij+2]<<16);
//         buf_send[ij+1] = carray[2*ij+1]+ (carray[2*ij+2]<<16);
       send_array[ij+1] = buf_send[ij+1];
      }
      nword =nsend+1;
      i=1;
//       if(dummy1 == 0)
      ij = pcie_send(hDev, i, nword, px);
      nanosleep(&tim , &tim2);
      dummy1 = dummy1+1;
      count =0;
     }
    }
    if(feof(inpf)) {
     printf("You have reached the end-of-file word count= %d %d\n", counta, count);
     buf_send[0] = (imod <<11) +(ichip_c <<8)+ (carray[0]<<16);
     if ( count > 1) {
      if( ((count-1)%2) ==0) {
       ik =(count-1)/2;
      }
      else {
       ik =(count-1)/2+1;
      }
      ik=ik+2;   // add one more for safety
      printf("ik= %d\n",ik);
      for (ij=0; ij<ik; ij++){
       if(ij == (ik-1)) buf_send[ij+1] = carray[(2*ij)+1]+(((imod<<11)+(ichip<<8)+0x0)<<16);
       else buf_send[ij+1] = carray[(2*ij)+1]+ (carray[(2*ij)+2]<<16);
       send_array[ij+1] = buf_send[ij+1];
      }
     }
     else ik=1;

     for (ij=ik-10; ij< ik+1; ij++) {
       printf("Last data = %d, %x\n",ij,buf_send[ij]);
     }

     nword =ik+1;
     i=1;
     i = pcie_send(hDev, i, nword, px);
    }
    usleep(2000);    // wait for 2ms to cover the packet time plus fpga init time
    fclose(inpf);
//
//
//
    printf(" enter 1 to reset the dram in module %d \n", imod);
    scanf("%d",&ik);
 //      ik =1;
    if(ik ==1) {
     imod=imod_fem;
     ichip=3;
     buf_send[0]=(imod<<11)+(ichip<<8)+31+(0x1<<16);  // turm the DRAM reset on
     i=1;
     k=1;
     i = pcie_send(hDev, i, k, px);
     imod=imod_fem;
     ichip=3;
     buf_send[0]=(imod<<11)+(ichip<<8)+31+(0x0<<16);  // turm the DRAM reset off
     i=1;
     k=1;
     i = pcie_send(hDev, i, k, px);

     usleep(5000);    // wait for 5 ms for DRAM to be initialized
     imod=imod_fem;
     ichip=3;
     buf_send[0]=(imod<<11)+(ichip<<8)+6+(imod<<16);  // set module number
     i=1;
     k=1;
     i = pcie_send(hDev, i, k, px);


    }
//       printf(" enter 1 to read system status \n");
//       scanf("%d",&ik);

    nword =1;
    i = pcie_rec(hDev,0,1,nword,iprint,py);     // init the receiver

    imod=imod_fem;
    ichip=3;
    buf_send[0]=(imod<<11)+(ichip<<8)+20+(0x0<<16);  // read out status
    i=1;
    k=1;
    i = pcie_send(hDev, i, k, px);
    py = &read_array;
    i = pcie_rec(hDev,0,2,nword,iprint,py);     // read out 2 32 bits words
    printf("receive data word = %x, %x \n", read_array[0], read_array[1]);

//
//     set PMT inhibit size to 625
//
//    imod=imod_fem;
//    ichip=3;
//    buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_pmt_inhib_size+(625<<16);  // set module number
//    i=1;
//    k=1;
//    i = pcie_send(hDev, i, k, px);
//
//     set PMT delay 0 to 4
//
    for (ik=0; ik<40; ik++) {

     imod=imod_fem;
     ichip=3;
     buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_pmt_ch_set+(ik<<16);  // set channel number to be download
     i=1;
     k=1;
     i = pcie_send(hDev, i, k, px);

      usleep(100);

     imod=imod_fem;
     ichip=3;
     idelay0=4;
     buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_pmt_delay0+(idelay0<<16);  // set delay0
     i=1;
     k=1;
     i = pcie_send(hDev, i, k, px);
//
//     set PMT delay1 to 12
//
     imod=imod_fem;
     ichip=3;
     idelay1=12;
     buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_pmt_delay1+(idelay1<<16);  // set delay 1
     i=1;
     k=1;
     i = pcie_send(hDev, i, k, px);
//
//     set PMT precount
//
     imod=imod_fem;
     ichip=3;
     buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_pmt_precount+(pmt_precount<<16);  // set pmt precount
     i=1;
     k=1;
     i = pcie_send(hDev, i, k, px);
//
//     set PMT threshold 0 to 10
//
     imod=imod_fem;
     ichip=3;
//      threshold0=100;
     buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_pmt_thresh0+(threshold0<<16);  // set threshold 0
     i=1;
     k=1;
     i = pcie_send(hDev, i, k, px);
//
//     set PMT threshold 1 to 20
//
     imod=imod_fem;
     ichip=3;
//      threshold1=150;
     buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_pmt_thresh1+(threshold1<<16);  // set threshold 1
     i=1;
     k=1;
     i = pcie_send(hDev, i, k, px);
//
//     set PMT data words to 40
//
     imod=imod_fem;
     ichip=3;
//    pmt_words=40;
     buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_pmt_words+(pmt_words<<16);  // set pmt_words
     i=1;
     k=1;
     i = pcie_send(hDev, i, k, px);

//
//     set PMT deadtime
//
     imod=imod_fem;
     ichip=3;
     buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_pmt_deadtime+(pmt_deadtime<<16);  // set pmt dead timr
     i=1;
     k=1;
     i = pcie_send(hDev, i, k, px);
//
//     set PMT Michael window
//
     imod=imod_fem;
     ichip=3;
     buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_pmt_window+(pmt_mich_window<<16);  // set pmt Michael window
     i=1;
     k=1;
     i = pcie_send(hDev, i, k, px);
    }
//
//     set PMT cosmic ray trigger multiplicity to 2
//
    imod=imod_fem;
    ichip=3;
//      cos_mult=2;
    buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_pmt_cos_mul+(cos_mult<<16);  // set cosmic ray trigger mul
    i=1;
    k=1;
    i = pcie_send(hDev, i, k, px);
//
//     set PMT cosmic ray trigger pulse height
//
    imod=imod_fem;
    ichip=3;
//      cos_thres=20;
    buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_pmt_cos_thres+(cos_mult<<16);  // set cosmic ray trigger peak
    i=1;
    k=1;
    i = pcie_send(hDev, i, k, px);
//
//     disable the top chanell
//
    imod=imod_fem;
    ichip=3;
    en_top=0xff;
    buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_pmt_en_top+(en_top<<16);  // enable/disable channel
    i=1;
    k=1;
    i = pcie_send(hDev, i, k, px);
//
//     disable the upper chanell
//
    imod=imod_fem;
    ichip=3;
    en_upper=0xffff;
    buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_pmt_en_upper+(en_upper<<16);  // enable/disable channel
    i=1;
    k=1;
    i = pcie_send(hDev, i, k, px);
//
//     enable all lower channel
//
    imod=imod_fem;
    ichip=3;
    en_lower=0xffff;
    buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_pmt_en_lower+(en_lower<<16);  // enable/disable channel
    i=1;
    k=1;
    i = pcie_send(hDev, i, k, px);
//
//     set maximum block size
//
    imod=imod_fem;
    ichip=3;
    buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_pmt_blocksize+(0xffff<<16);  // set max block size
    i=1;
    k=1;
    i = pcie_send(hDev, i, k, px);
//
//
    imod=imod_fem;
    ichip=3;
    buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_pmt_gate_size+(0x50<<16);  // set gate size
    i=1;
    k=1;
    i = pcie_send(hDev, i, k, px);
//
//    set beam delay
//
    imod=imod_fem;
    ichip=3;
    buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_pmt_beam_delay+(0x5<<16);  // set gate size
    i=1;
    k=1;
    i = pcie_send(hDev, i, k, px);
//
//    set beam size window
//
    imod=imod_fem;
    ichip=3;
    buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_pmt_beam_size+(0x40<<16);  // set gate size
    i=1;
    k=1;
    i = pcie_send(hDev, i, k, px);


//
//
//     &&&&&&&&&&&&&&&
//
//     set a_id
//
    a_id =0x20;
    imod=imod_fem;
    ichip=3;
    buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_a_id+(a_id<<16);  // set a_id
    i=1;
    k=1;
    i = pcie_send(hDev, i, k, px);
//
//     enable hold
//
//         imod=11;
    imod = imod_fem;
    ichip=3;
    buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_hold_enable+(0x1<<16);  // enable the hold
    i=1;
    k=1;
    i = pcie_send(hDev, i, k, px);


//
//     work on the ADC -- set reset pulse
//
    imod=imod_fem;
    ichip=5;
    buf_send[0]=(imod<<11)+(ichip<<8)+(mb_pmt_adc_reset)+(0x0<<16); // reset goes high
    i=1;
    k=1;
    i = pcie_send(hDev, i, k, px);
    imod=imod_fem;
    ichip=5;
    buf_send[0]=(imod<<11)+(ichip<<8)+(mb_pmt_adc_reset)+(0x1<<16); // reset goes low
    i=1;
    k=1;
    i = pcie_send(hDev, i, k, px);
    imod=imod_fem;
    ichip=5;
    buf_send[0]=(imod<<11)+(ichip<<8)+(mb_pmt_adc_reset)+(0x0<<16); // reset goes high
    i=1;
    k=1;
    i = pcie_send(hDev, i, k, px);
//
//      enable ADC clock,
//
    imod=imod_fem;
    ichip=5;
    buf_send[0]=(imod<<11)+(ichip<<8)+(mb_pmt_spi_add)+(0x7<<16); //set spi address
    i=1;
    k=1;
    i = pcie_send(hDev, i, k, px);
    imod=imod_fem;
    ichip=5;
    buf_send[0]=(imod<<11)+(ichip<<8)+(mb_pmt_adc_data_load)+(0xffff<<16); //load spi data, clock gate enable
    i=1;
    k=1;
    i = pcie_send(hDev, i, k, px);
//
//        load ADC sync data pattern  + set MSB 1st
//
    for (is=1; is<7; is++) {
     imod=imod_fem;
     ichip=5;
     buf_send[0]=(imod<<11)+(ichip<<8)+(mb_pmt_spi_add)+((is & 0xf)<<16); //set spi address
     i=1;
     k=1;
     i = pcie_send(hDev, i, k, px);
     imod=imod_fem;
     ichip=5;
     buf_send[0]=(imod<<11)+(ichip<<8)+(mb_pmt_adc_data_load)+(0x0b00<<16); //sync pattern, b for sync, 7 for skew, 3 for normal
     i=1;
     k=1;
     i = pcie_send(hDev, i, k, px);
     imod=imod_fem;
     ichip=5;
     buf_send[0]=(imod<<11)+(ichip<<8)+(mb_pmt_adc_data_load)+(0x1400<<16); //msb 1st
     i=1;
     k=1;
     i = pcie_send(hDev, i, k, px);
    }
    printf(" enter 1 to continue FPGA ADC receiver reset\n");
//    scanf("%d",&ik);
//
//    send FPGA ADC receiver reset
//
    imod=imod_fem;
    ichip=3;
    buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_pmt_rxreset+(0x1<<16);  // FPGA ADC receiver reset on
    i=1;
    k=1;
    i = pcie_send(hDev, i, k, px);
//
//      readback status
//
    i = pcie_rec(hDev,0,1,nword,iprint,py);     // init the receiver

    imod=imod_fem;
    ichip=3;
    buf_send[0]=(imod<<11)+(ichip<<8)+20+(0x0<<16);  // read out status
    i=1;
    k=1;
    i = pcie_send(hDev, i, k, px);
    py = &read_array;
    i = pcie_rec(hDev,0,2,nword,iprint,py);     // read out 2 32 bits words
    printf("receiv e data word -- after reset = %x, %x \n", read_array[0], read_array[1]);
    printf(" module = %d, command = %d \n", ((read_array[0]>>11) & 0x1f), (read_array[0] &0xff));
    printf(" ADC right dpa lock     %d \n", ((read_array[0]>>17) & 0x1));
    printf(" ADC left  dpa lock     %d \n", ((read_array[0]>>18) & 0x1));
    printf(" block error 2          %d \n", ((read_array[0]>>19) & 0x1));
    printf(" block error 1          %d \n", ((read_array[0]>>20) & 0x1));
    printf(" pll lcoked             %d \n", ((read_array[0]>>21) & 0x1));
    printf(" superNova mem ready    %d \n", ((read_array[0]>>22) & 0x1));
    printf(" beam      mem ready    %d \n", ((read_array[0]>>23) & 0x1));
    printf(" ADC right PLL locked   %d \n", ((read_array[0]>>24) & 0x1));
    printf(" ADC left PLL locked    %d \n", ((read_array[0]>>25) & 0x1));
    printf(" ADC align cmd right    %d \n", ((read_array[0]>>26) & 0x1));
    printf(" ADC align cmd left     %d \n", ((read_array[0]>>27) & 0x1));
    printf(" ADC align done right   %d \n", ((read_array[0]>>28) & 0x1));
    printf(" ADC align done left    %d \n", ((read_array[0]>>29) & 0x1));
    printf(" Neutrino data empty    %d \n", ((read_array[0]>>30) & 0x1));
    printf(" Neutrino Header empty  %d \n", ((read_array[0]>>31) & 0x1));
//
//
//
    printf(" enter 1 to continue FPGA ADC receiver align\n");
//    scanf("%d",&ik);
//
//    send FPGA ADC align
//
    imod=imod_fem;
    ichip=3;
    buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_pmt_align_pulse+(0x0<<16);  // FPGA ADC receiver reset off
    i=1;
    k=1;
    i = pcie_send(hDev, i, k, px);

    usleep(5000); // wait for 5ms

//
//      readback status
//
    i = pcie_rec(hDev,0,1,nword,iprint,py);     // init the receiver

    imod=imod_fem;
    ichip=3;
    buf_send[0]=(imod<<11)+(ichip<<8)+20+(0x0<<16);  // read out status
    i=1;
    k=1;
    i = pcie_send(hDev, i, k, px);
    py = &read_array;
    i = pcie_rec(hDev,0,2,nword,iprint,py);     // read out 2 32 bits words
    printf("receive data word -- after align = %x, %x \n", read_array[0], read_array[1]);
    printf(" module = %d, command = %d \n", ((read_array[0]>>11) & 0x1f), (read_array[0] &0xff));
    printf(" ADC right dpa lock     %d \n", ((read_array[0]>>17) & 0x1));
    printf(" ADC left  dpa lock     %d \n", ((read_array[0]>>18) & 0x1));
    printf(" block error 2          %d \n", ((read_array[0]>>19) & 0x1));
    printf(" block error 1          %d \n", ((read_array[0]>>20) & 0x1));
    printf(" pll lcoked             %d \n", ((read_array[0]>>21) & 0x1));
    printf(" superNova mem ready    %d \n", ((read_array[0]>>22) & 0x1));
    printf(" beam      mem ready    %d \n", ((read_array[0]>>23) & 0x1));
    printf(" ADC right PLL locked   %d \n", ((read_array[0]>>24) & 0x1));
    printf(" ADC left PLL locked    %d \n", ((read_array[0]>>25) & 0x1));
    printf(" ADC align cmd right    %d \n", ((read_array[0]>>26) & 0x1));
    printf(" ADC align cmd left     %d \n", ((read_array[0]>>27) & 0x1));
    printf(" ADC align done right   %d \n", ((read_array[0]>>28) & 0x1));
    printf(" ADC align done left    %d \n", ((read_array[0]>>29) & 0x1));
    printf(" ADC align done left    %d \n", ((read_array[0]>>29) & 0x1));
    printf(" Neutrino data empty    %d \n", ((read_array[0]>>30) & 0x1));
    printf(" Neutrino Header empty  %d \n", ((read_array[0]>>31) & 0x1));
//
//
//
//
    printf(" enter 1 to continue after ADC alignment \n");
//    scanf("%d",&ik);
//
//
//
    for (is=1; is<7; is++) {
     imod=imod_fem;
     ichip=5;
     buf_send[0]=(imod<<11)+(ichip<<8)+(mb_pmt_spi_add)+((is & 0xf)<<16); //set spi address
     i=1;
     k=1;
     i = pcie_send(hDev, i, k, px);
     imod=imod_fem;
     ichip=5;
     buf_send[0]=(imod<<11)+(ichip<<8)+(mb_pmt_adc_data_load)+(0x0300<<16); //sync pattern, b for sync, 7 for skew, 3 for normal
     i=1;
     k=1;
     i = pcie_send(hDev, i, k, px);
    }
    return i;





}

static fem_link_setup(WDC_DEVICE_HANDLE hDev, int imod_xmit, int imod_st, int supernova)
{
#include "wdc_defs.h"
#include "wdc_defs.h"
#define poweroff      0x0
#define poweron       0x1
#define configure_s30 0x2
#define configure_s60 0x3
#define configure_cont 0x20
#define rdstatus      0x80
#define loopback        0x04

#define dcm2_run_off  254
#define dcm2_run_on   255

#define dcm2_online   2
#define dcm2_setmask  3
#define dcm2_offline_busy 4
#define dcm2_load_packet_a 10
#define dcm2_load_packet_b 11
#define dcm2_offline_load 9
#define dcm2_status_read 20
#define dcm2_led_sel     29
#define dcm2_buffer_status_read 30
#define dcm2_status_read_inbuf 21
#define dcm2_status_read_evbuf 22
#define dcm2_status_read_noevnt 23
#define dcm2_zero 12
#define dcm2_compressor_hold 31

#define dcm2_5_readdata 4
#define dcm2_5_firstdcm 8
#define dcm2_5_lastdcm  9
#define dcm2_5_status_read 5
#define dcm2_5_source_id 25
#define dcm2_5_lastchnl 24

#define dcm2_packet_id_a 25
#define dcm2_packet_id_b 26
#define dcm2_hitformat_a 27
#define dcm2_hitformat_b 28

#define part_run_off  254
#define part_run_on   255
#define part_online   2
#define part_offline_busy 3
#define part_offline_hold 4
#define part_status_read 20
#define part_source_id 25


#define  t1_tr_bar 0
#define  t2_tr_bar 4
#define  cs_bar 2

/**  command register location **/

#define  tx_mode_reg 0x28
#define  t1_cs_reg 0x18
#define  r1_cs_reg 0x1c
#define  t2_cs_reg 0x20
#define  r2_cs_reg 0x24

#define  tx_md_reg 0x28

#define  cs_dma_add_low_reg 0x0
#define  cs_dma_add_high_reg  0x4
#define  cs_dma_by_cnt 0x8
#define  cs_dma_cntrl 0xc
#define  cs_dma_msi_abort 0x10

/** define status bits **/

#define  cs_init  0x20000000
#define  cs_mode_p 0x8000000
#define  cs_mode_n 0x0
#define  cs_start 0x40000000
#define  cs_done  0x80000000

#define  dma_tr1  0x100000
#define  dma_tr2  0x200000
#define  dma_tr12 0x300000
#define  dma_3dw_trans 0x0
#define  dma_4dw_trans 0x0
#define  dma_3dw_rec   0x40
#define  dma_4dw_rec   0x60
#define  dma_in_progress 0x80000000

#define  dma_abort 0x2

#define  mb_cntrl_add     0x1
#define  mb_cntrl_test_on 0x1
#define  mb_cntrl_test_off 0x0
#define  mb_cntrl_set_run_on 0x2
#define  mb_cntrl_set_run_off 0x3
#define  mb_cntrl_set_trig1 0x4
#define  mb_cntrl_set_trig2 0x5
#define  mb_cntrl_load_frame 0x6
#define  mb_cntrl_load_trig_pos 0x7

#define  mb_feb_power_add 0x1
#define  mb_feb_conf_add 0x2
#define  mb_feb_pass_add 0x3

#define  mb_feb_lst_on          1
#define  mb_feb_lst_off         0
#define  mb_feb_rxreset         2
#define  mb_feb_align           3
#define  mb_feb_pll_reset       5


#define  mb_feb_adc_align       1
#define  mb_feb_a_nocomp        2
#define  mb_feb_b_nocomp        3
#define  mb_feb_blocksize       4
#define  mb_feb_timesize        5
#define  mb_feb_mod_number      6
#define  mb_feb_a_id            7
#define  mb_feb_b_id            8
#define  mb_feb_max             9

#define  mb_feb_test_source    10
#define  mb_feb_test_sample    11
#define  mb_feb_test_frame     12
#define  mb_feb_test_channel   13
#define  mb_feb_test_ph        14
#define  mb_feb_test_base      15
#define  mb_feb_test_ram_data  16

#define  mb_feb_a_test         17
#define  mb_feb_b_test         18

#define  mb_feb_rd_status      20

#define  mb_feb_a_rdhed        21
#define  mb_feb_a_rdbuf        22
#define  mb_feb_b_rdhed        23
#define  mb_feb_b_rdbuf        24

#define  mb_feb_read_probe     30
#define  mb_feb_adc_reset      33

#define  mb_a_buf_status       34
#define  mb_b_buf_status       35
#define  mb_a_ham_status       36
#define  mb_b_ham_status       37

#define  mb_feb_a_maxwords     40
#define  mb_feb_b_maxwords     41

#define  mb_feb_hold_enable    42

#define  mb_pmt_adc_reset       1
#define  mb_pmt_spi_add         2
#define  mb_pmt_adc_data_load   3

#define  mb_xmit_conf_add 0x2
#define  mb_xmit_pass_add 0x3

#define  mb_xmit_modcount 0x1
#define  mb_xmit_enable_1 0x2
#define  mb_xmit_enable_2 0x3
#define  mb_xmit_test1 0x4
#define  mb_xmit_test2 0x5

#define   mb_xmit_testdata  10

#define  mb_xmit_rdstatus 20
#define  mb_xmit_rdcounters 21
#define  mb_xmit_link_reset    22
#define  mb_opt_dig_reset   23
#define  mb_xmit_dpa_fifo_reset    24
#define  mb_xmit_dpa_word_align    25
#define  mb_xmit_link_pll_reset    26

#define  mb_trig_run                1
#define  mb_trig_frame_size         2
#define  mb_trig_deadtime_size      3
#define  mb_trig_active_size        4
#define  mb_trig_delay1_size        5
#define  mb_trig_delay2_size        6

#define  mb_trig_calib_delay        8

#define  mb_trig_prescale0         10
#define  mb_trig_prescale1         11
#define  mb_trig_prescale2         12
#define  mb_trig_prescale3         13
#define  mb_trig_prescale4         14
#define  mb_trig_prescale5         15
#define  mb_trig_prescale6         16
#define  mb_trig_prescale7         17
#define  mb_trig_prescale8         18

#define  mb_trig_mask0             20
#define  mb_trig_mask1             21
#define  mb_trig_mask2             22
#define  mb_trig_mask3             23
#define  mb_trig_mask4             24
#define  mb_trig_mask5             25
#define  mb_trig_mask6             26
#define  mb_trig_mask7             27
#define  mb_trig_mask8             28

#define  mb_trig_rd_param          30
#define  mb_trig_pctrig            31
#define  mb_trig_rd_status         32
#define  mb_trig_reset             33
#define  mb_trig_calib             34
#define  mb_trig_rd_gps            35

#define  mb_trig_sel1              40
#define  mb_trig_sel2              41
#define  mb_trig_sel3              42
#define  mb_trig_sel4              43

#define  mb_trig_p1_delay          50
#define  mb_trig_p1_width          51
#define  mb_trig_p2_delay          52
#define  mb_trig_p2_width          53
#define  mb_trig_p3_delay          54
#define  mb_trig_p3_width          55
#define  mb_trig_pulse_delay       58

#define  mb_trig_pulse1            60
#define  mb_trig_pulse2            61
#define  mb_trig_pulse3            62

#define  mb_shaper_pulsetime        1
#define  mb_shaper_dac              2
#define  mb_shaper_pattern          3
#define  mb_shaper_write            4
#define  mb_shaper_pulse            5
#define  mb_shaper_entrig           6

#define  mb_feb_pmt_gate_size      47
#define  mb_feb_pmt_beam_delay     48
#define  mb_feb_pmt_beam_size      49

#define  mb_feb_pmt_ch_set         50
#define  mb_feb_pmt_delay0         51
#define  mb_feb_pmt_delay1         52
#define  mb_feb_pmt_precount       53
#define  mb_feb_pmt_thresh0        54
#define  mb_feb_pmt_thresh1        55
#define  mb_feb_pmt_thresh2        56
#define  mb_feb_pmt_thresh3        57
#define  mb_feb_pmt_width          58
#define  mb_feb_pmt_deadtime       59
#define  mb_feb_pmt_window         60
#define  mb_feb_pmt_words          61
#define  mb_feb_pmt_cos_mul        62
#define  mb_feb_pmt_cos_thres      63
#define  mb_feb_pmt_mich_mul       64
#define  mb_feb_pmt_mich_thres     65
#define  mb_feb_pmt_beam_mul       66
#define  mb_feb_pmt_beam_thres     67
#define  mb_feb_pmt_en_top         68
#define  mb_feb_pmt_en_upper       69
#define  mb_feb_pmt_en_lower       70
#define  mb_feb_pmt_blocksize      71

#define  mb_feb_pmt_test           80
#define  mb_feb_pmt_clear          81
#define  mb_feb_pmt_test_data      82
#define  mb_feb_pmt_pulse          83

#define  mb_feb_pmt_rxreset        84
#define  mb_feb_pmt_align_pulse    85
#define  mb_feb_pmt_rd_counters    86

#define  dma_buffer_size        10000000

  //    static DWORD dwAddrSpace;
  
  static UINT32 u32Data;
  static unsigned short u16Data;
  //    static unsigned long long u64Data, u64Data1;
  //    static DWORD dwOffset;
  static long imod,ichip;
  unsigned short *buffp;
  
  /*
    WDC_ADDR_MODE mode;
    WDC_ADDR_RW_OPTIONS options;
*/
  static UINT32 i,j,k,ifr,nread,iprint,iwrite,ik,il,is,checksum;
  //    static UINT32 istop,newcmd,irand,ioffset,kword,lastchnl,ib;
  static UINT32 send_array[40000],read_array[1000];
  //    ,read_array1[40000];
  //    static UINT32 read_array_c[40000];
  //    static UINT32 read_comp[8000];
  static UINT32 nmask,index,itmp,nword_tot,nevent,iv,ijk,islow_read;
  static UINT32 imod_p,imod_trig,imod_shaper;
  //    unsigned short idcm_read_array[40000],read_array_s[1600000];
  //    static UINT32 idcm_read_array32[40000];
  //    static UINT32 idcm_send_array[400000];
  //    static UINT32 idcm_verify_array[400000];
  static int icomp_l,comp_s,ia,ic,ihuff;
  //    UINT32 *idcm_send_p,*idcm_verify_p,*pbuffp_rec;
  //    DWORD dwDMABufSize;
  //    PVOID pbuf;
  //    WD_DMA *pDma;
  DWORD dwStatus;
  DWORD dwOptions = DMA_FROM_DEVICE;
  UINT32 iread,icheck,izero;
  UINT32 buf_send[40000];
  static int   count,num,counta,nword,ireadback,nloop,ierror;
  static int   ij,nsend,iloop,inew,idma_readback,iadd,jevent;
  static int   itest,irun,ichip_c,dummy1,itrig_c;
  static int  idup,ihold,idouble,ihold_set,istatus_read;
  static int  idone,tr_bar,t_cs_reg,r_cs_reg,dma_tr;
  static int   timesize,ipulse,ibase,a_id,itrig_delay;
  static int   iset,ncount,nsend_f,nwrite,itrig_ext;
  static int   imod_fem,idiv,isample;
  static int   iframe_length, itrig,idrift_time,ijtrig;
  static int   idelay0, idelay1, threshold0, threshold1, pmt_words;
  static int   cos_mult, cos_thres, en_top, en_upper, en_lower;
  static int   irise, ifall, istart_time, use_pmt, pmt_testpulse;
  static int   ich_head, ich_sample, ich_frm,idebug,ntot_rec,nred;
  static int   ineu,ibusy_send,ibusy_test,ihold_word,ndma_loop;
  static int   irawprint,ifem_fst,ifem_lst,ifem_loop;
  static int   pmt_deadtime,pmt_mich_window;
  static int   oframe,osample,odiv,cframe,csample,cdiv;
  static int   idac_shaper, pmt_dac_scan;
  unsigned char    charchannel;
  unsigned char    carray[4000];
  struct timespec tim, tim2;
  tim.tv_sec = 0;
  tim.tv_nsec =128000;
  
  
  PVOID pbuf_rec;
  WD_DMA *pDma_rec;
  DWORD dwOptions_send = DMA_TO_DEVICE | DMA_ALLOW_CACHE;
  //    DWORD dwOptions_rec = DMA_FROM_DEVICE | DMA_ALLOW_CACHE | DMA_ALLOW_64BIT_ADDRESS;
  DWORD dwOptions_rec = DMA_FROM_DEVICE | DMA_ALLOW_64BIT_ADDRESS;
  
  
  UINT32 *px, *py, *py1;
  //
  //
  px = &buf_send;
  py = &read_array;
  iprint == 1;
  printf(" link setup imod_st =%d, imod_xmit %d \n", imod_st, imod_xmit);
  //
  //     now reset all the link port receiver PLL
  //
  for (imod_fem = (imod_st-1); imod_fem > imod_xmit; imod_fem--) {
    imod=imod_fem;
    printf(" reset the link PLL for module %x \n", imod);
    ichip=4;
    buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_pll_reset+(0x0<<16);    // reset LINKIN PLL
    i=1;
    k=1;
    i = pcie_send(hDev, i, k, px);
    usleep(1000);   // give PLL time to reset
  }
  //
  //
  //
  
  for (imod_fem = (imod_xmit+1); imod_fem< (imod_st+1); imod_fem++) {
    i = pcie_rec(hDev,0,1,nword,iprint,py);     // init the receiver
    imod=imod_fem;
    ichip=3;
    buf_send[0]=(imod<<11)+(ichip<<8)+20+(0x0<<16);  // read out status
    i=1;
    k=1;
    i = pcie_send(hDev, i, k, px);
    py = &read_array;
    i = pcie_rec(hDev,0,2,nword,iprint,py);     // read out 2 32 bits words
    if(iprint == 1) printf("FEM module %d status word after PLL reset = %x, %x \n", imod, read_array[0], read_array[1]);
  }
  
  
  //
  //     now reset all the link port receiver
  //
  //-     for (imod_fem = (imod_st-1); imod_fem > imod_xmit; imod_fem--) {
  //-       imod=imod_fem;
  //-       printf(" reset the link for module %d \n", imod);
  //-       ichip=4;
  //-       buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_rxreset+(0x0<<16);    // reset LINKIN DPA
  //-       i=1;
  //-       k=1;
  //-       i = pcie_send(hDev, i, k, px);
  //
  //
  //-       ichip=4;
  //-       buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_align+(0x0<<16);    // send alignment command
  //-       i=1;
  //-       k=1;
  //-       i = pcie_send(hDev, i, k, px);
  //-      }
  
  //
  //
  //
  //
  //     set up xmit module  -- module count
  //
  imod=imod_xmit;
  ichip=3;
  //                  -- number of FEM module -1, counting start at 0
  buf_send[0]=(imod<<11)+(ichip<<8)+mb_xmit_modcount+((imod_st-imod_xmit-1)<<16);
  i=1;
  k=1;
  i = pcie_send(hDev, i, k, px);
  //
  //     rest optical
  //
  imod=imod_xmit;
  ichip=3;
  buf_send[0]=(imod<<11)+(ichip<<8)+mb_opt_dig_reset+(0x1<<16);  // set optical reset on
  i=1;
  k=1;
  i = pcie_send(hDev, i, k, px);
  //
  //     enable Neutrino/superNova Token Passing
  //
  imod=imod_xmit;
  ichip=3;
  buf_send[0]=(imod<<11)+(ichip<<8)+mb_xmit_enable_1+(0x1<<16);  // enable token 1 pass
  //      if(supernova == 0) buf_send[0]=(imod<<11)+(ichip<<8)+mb_xmit_enable_1+(0x1<<16);  // enable token 1 pass
  //      else buf_send[0]=(imod<<11)+(ichip<<8)+mb_xmit_enable_1+(0x0<<16);  // edisable token 1 pass
  i=1;
  k=1;
  i = pcie_send(hDev, i, k, px);
  //
  if(supernova == 0) buf_send[0]=(imod<<11)+(ichip<<8)+mb_xmit_enable_2+(0x0<<16);  // disable token 2 pass
  else buf_send[0]=(imod<<11)+(ichip<<8)+mb_xmit_enable_2+(0x1<<16);  // enable token 2 pass
  i=1;
  k=1;
  i = pcie_send(hDev, i, k, px);
  //
  //
  //       printf(" enter 1 to reset the DPA \n");
  //       scanf("%d",&ik);
  
  //
  //
  //       reset XMIT LINK IN DPA
  //
  imod=imod_xmit;
  ichip=3;
  buf_send[0]=(imod<<11)+(ichip<<8)+mb_xmit_link_pll_reset+(0x1<<16);  //  reset XMIT LINK IN DPA
  i=1;
  k=1;
  i = pcie_send(hDev, i, k, px);
  usleep(1000);
  //
  //     reset XMIT LINK IN DPA
  //
  imod=imod_xmit;
  ichip=3;
  buf_send[0]=(imod<<11)+(ichip<<8)+mb_xmit_link_reset+(0x1<<16);  //  reset XMIT LINK IN DPA
  i=1;
  k=1;
  i = pcie_send(hDev, i, k, px);
  //
  //     wait for 10ms just in case
  //
  usleep(10000);
  printf(" XMIT FIFO reset \n");
  //
  //     reset XMIT FIFO reset
  //
  imod=imod_xmit;
  ichip=3;
  buf_send[0]=(imod<<11)+(ichip<<8)+mb_xmit_dpa_fifo_reset+(0x1<<16);  //  reset XMIT LINK IN DPA
  i=1;
  k=1;
  i = pcie_send(hDev, i, k, px);
  
  //
  //    set up last module to the module next to XMIT
  //
  imod=imod_xmit+1;
  printf(" set last module on, module address %d\n", imod);
  ichip=4;
  buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_lst_on+(0x0<<16);    // set last module on
  i=1;
  k=1;
  i = pcie_send(hDev, i, k, px);
  
  for (is=0; is<1; is++) {
    //
    //      test re-align circuit
    //
    imod=imod_xmit;
    ichip=3;
    buf_send[0]=(imod<<11)+(ichip<<8)+mb_xmit_dpa_word_align+(0x1<<16);  //  send alignment pulse
    i=1;
    k=1;
    i = pcie_send(hDev, i, k, px);
    
    //        printf(" enter 1 to set continue on re-align circuit \n");
    //        scanf("%d",&ik);
  }
  usleep(5000); //wait for 5 ms
  //      printf(" XMIT re-align done \n");
  //      scanf("%d",&ik);
  
  nword =1;
  
  i = pcie_rec(hDev,0,1,nword,iprint,py);     // init the receiver
  imod=imod_xmit;
  ichip=3;
  buf_send[0]=(imod_xmit<<11)+(ichip<<8)+mb_xmit_rdstatus+(0x0<<16);  // read out status
  
  i=1;
  k=1;
  i = pcie_send(hDev, i, k, px);
  py = &read_array;
  i = pcie_rec(hDev,0,2,nword,iprint,py);     // read out 2 32 bits words
  printf("xmit status word = %x, %x \n", read_array[0], read_array[1]);
  
  
  //
  //    set up last module to the module next to XMIT
  //
  imod=imod_xmit+1;
  printf(" set last module off, module address %d\n", imod);
  ichip=4;
  buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_lst_off+(0x0<<16);    // set last module off
  i=1;
  k=1;
  i = pcie_send(hDev, i, k, px);
  //
  //
  printf(" finish XMIT alignment \n");
  scanf("%d",&ik);
  //
  //
  //
  //
  
  //
  //
  //     now reset all the link port receiver
  //
  imod_fem = imod_xmit+1;
  while (imod_fem < imod_st){
    imod= imod_fem+1;
    ichip=4;
    buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_lst_on+(0x0<<16);    // set last module on
    i=1;
    k=1;
    i = pcie_send(hDev, i, k, px);
    printf(" set last modulen, module address -- alignment %d\n", imod);
    imod =imod_fem;
    printf(" reset the link for module %d \n", imod);
    ichip=4;
    buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_rxreset+(0x0<<16);    // reset LINKIN DPA
    i=1;
    k=1;
    i = pcie_send(hDev, i, k, px);
    
    ichip=4;
    buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_align+(0x0<<16);    // send alignment command
    i=1;
    k=1;
    i = pcie_send(hDev, i, k, px);
    usleep(1000);
    //
    //
    //       printf(" finish FEM module %d alignment \n", imod);
    //       scanf("%d",&ik);
    //
    imod=imod_fem+1;
    if(imod != imod_st) {
      ichip=4;
      buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_lst_off+(0x0<<16);    // set last module off
      i=1;
      k=1;
      i = pcie_send(hDev, i, k, px);
      printf(" set last module off, module address -- alignment%d\n", imod);
    }
    imod_fem=imod_fem+1;
  }
  
  
  
  
  
  //
  
  
  for (imod_fem = (imod_xmit+1); imod_fem< (imod_st+1); imod_fem++) {
    i = pcie_rec(hDev,0,1,nword,iprint,py);     // init the receiver
    imod=imod_fem;
    ichip=3;
    buf_send[0]=(imod<<11)+(ichip<<8)+20+(0x0<<16);  // read out status
    i=1;
    k=1;
    i = pcie_send(hDev, i, k, px);
    py = &read_array;
    usleep(100);
    i = pcie_rec(hDev,0,2,nword,iprint,py);     // read out 2 32 bits words
    if(iprint == 1) printf("FEM module %d status word = %x, %x \n", imod, read_array[0], read_array[1]);
  }
  return i;
  
}




/* -----------------------------------------------
    Read/write memory and I/O addresses -- TEST
   ----------------------------------------------- */
/* Read/write memory or I/O space address menu options */
static void Menujsebii_test(WDC_DEVICE_HANDLE hDev)
{
/*  pci express bar setting
bar 0,1 is for transceiver 1
bar 2,3 is for command
bar 4,5 is for transceiver 2
*/

#include "wdc_defs.h"

#define  t1_tr_bar 0
#define  t2_tr_bar 4
#define  cs_bar 2

/**  command register location **/
/** GKQ: are these specific to a pcie? **/

#define  tx_mode_reg 0x28
#define  t1_cs_reg 0x18
#define  r1_cs_reg 0x1c
#define  t2_cs_reg 0x20
#define  r2_cs_reg 0x24

#define  tx_md_reg 0x28

#define  cs_dma_add_low_reg 0x0
#define  cs_dma_add_high_reg  0x4
#define  cs_dma_by_cnt 0x8
#define  cs_dma_cntrl 0xc
#define  cs_dma_msi_abort 0x10

/** define status bits **/

#define  cs_init  0x20000000
#define  cs_start 0x40000000
#define  cs_done  0x80000000

#define  dma_tr1  0x100000
#define  dma_tr2  0x200000
#define  dma_tr12 0x300000
#define  dma_3dw_trans 0x0
#define  dma_3dw_rec   0x40
#define  dma_in_progress 0x80000000

#define  dma_abort 0x2

  /** bunch of variable initializations **/
  static DWORD dwAddrSpace;

  static UINT32 u32Data, u32Data_send;
  static unsigned long long u64Data;
  static DWORD dwOffset;
  static unsigned long long buff[10000];
/*    PVOID buff_p; */
  static UINT32 *buffp_send;
  static UINT32 *buffp_rec;
  static UINT64 *buffp_rec64;
/*
    WDC_ADDR_MODE mode;
    WDC_ADDR_RW_OPTIONS options;
*/
  static UINT32 i,j,k,ifr,jk,nwrite,iprint,nread;
  int newcmd,itr,tr_bar,icheck,istop,iloop,t_cs_reg,r_cs_reg;
  int idone,iseq,incomp,dma_tr,isweep,nsize_sw,irand,nwrite_max,nwrite_min;
  int kwrite;
  UINT32 write_array[100000],read_array[100000];
  int n_written;
  DWORD dwDMABufSize;
  PVOID pbuf_send;
  PVOID pbuf_rec;
  WD_DMA *pDma_send;
  WD_DMA *pDma_rec;
  DWORD dwStatus;
  DWORD dwOptions_send = DMA_TO_DEVICE | DMA_ALLOW_64BIT_ADDRESS;
  DWORD dwOptions_rec = DMA_FROM_DEVICE | DMA_ALLOW_64BIT_ADDRESS;

  iprint =1;
  ifr =0;
  istop =0;
  icheck =1;
  
    /** main menu (options) of routine **/
  printf(" PCIe board testing routing \n");
  printf(" type 1 to use random number \n");
  scanf("%d",&irand);
  printf(" which transceiver to test (1,2 ) \n");
  scanf("%d", &itr);
  printf(" input testing method \n");
  printf(" 1) for slave loop back test \n");
  printf(" 2) DMA loop back test \n");
  //  printf(" 3) combine optical DMA test \n");
  printf(" 3) write-to-file test \n");
  scanf("%d",&newcmd);
  switch(newcmd) {

  case 1:
    if(icheck == 1) printf(" data checking on \n");
    printf("enter number words per packet, -1 for sequence test \n");
    scanf("%d",&kwrite);
    if(kwrite == -1) {
      printf("enter min number of word \n");
      scanf("%d",&nwrite_min);
      printf("enter max number of word \n");
      scanf("%d",&nwrite_max);
      nwrite=nwrite_min;
    }
    else nwrite = kwrite;
    printf("enter number loops \n");
    scanf("%d",&iloop);
    
    tr_bar = t1_tr_bar;
    t_cs_reg = t1_cs_reg;
    r_cs_reg = r1_cs_reg;
    if(itr == 2) {
      tr_bar = t2_tr_bar;
      t_cs_reg = t2_cs_reg;
      r_cs_reg = r2_cs_reg;
    }
    
/* write this will abort previous DMA */
    dwAddrSpace =2;
    dwOffset = cs_dma_msi_abort;
    u32Data = dma_abort;
    WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);

/* clear DMA register after the abort */
    dwAddrSpace =2;
    dwOffset = cs_dma_msi_abort;
    u32Data = 0;
    WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);


      /** begin timer **/
    struct timeval starttest1, endtest1;
    gettimeofday(&starttest1,NULL);
    long mytime1, seconds1, useconds1;
    seconds1 = starttest1.tv_sec;
    useconds1 = starttest1.tv_usec;

    printf("\n\nStart time of test: %ld sec %ld usec\n",seconds1,useconds1);
      //get a fresh timestamp
    gettimeofday(&starttest1,NULL);


    for (j=0; j<iloop; j++) {
	//GSK
	//       printf("started loop = %d \n",j);
/* set tx mode register */
      u32Data = 0xf0000fff;
      dwOffset = tx_md_reg;
      dwAddrSpace =cs_bar;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
/** initialize the tranmission ***/
      u32Data = cs_init;
      dwOffset = t_cs_reg;
      dwAddrSpace =cs_bar;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
/** start the tranmitter **/
      dwAddrSpace = cs_bar;
      u32Data = cs_start+nwrite*4;   /* 32 bits mode == 4 bytes per word **/
      dwOffset = t_cs_reg;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
       //GSK
       //       if(iprint == 1 && j < 2) printf(" set up transmitter \n");

/** initialize the receiver ***/
      u32Data = cs_init;
      dwOffset = r_cs_reg;
      dwAddrSpace =cs_bar;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
      /** start the receiver **/
      dwAddrSpace = cs_bar;
      u32Data = cs_start+nwrite*4;   /* 32 bits mode == 4 bytes per word **/
      dwOffset = r_cs_reg;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
       //GSK
       //       if (iprint ==1 && j < 2) printf(" set up receiver \n");

       //GSK
       //       if(icheck == 1) {
       //         dwAddrSpace =cs_bar;
       //         u64Data =0;
       //         dwOffset = t_cs_reg;
       //         WDC_ReadAddr64(hDev, dwAddrSpace, dwOffset, &u64Data);
       //         if(iprint==1 && j < 2) {
       //          u32Data=u64Data;
       //          printf (" transmitter status before send  = %8X \n",u32Data);
       //          u32Data=u64Data>>32;
       //          printf (" receiver status before send  = %8X \n",u32Data);
       //         }
       //       }

       //GSK
      u32Data = 0x22211; 

      for (i=0; i< nwrite; i++) {
        dwAddrSpace = tr_bar;
	//GSK
	//        if(irand == 1) u32Data=rand();
	//        else u32Data = i;
/*        if(i%2 == 0) u32Data =~i;   */
        dwOffset = 0;
	//GSK
	//        write_array[i]=u32Data;
        WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
      }

       //GSK
       //       if(icheck ==1 ) {
       //        dwAddrSpace =cs_bar;
       //        u64Data =0;
       //        dwOffset = t_cs_reg;
       //        WDC_ReadAddr64(hDev, dwAddrSpace, dwOffset, &u64Data);
       //        if(iprint==1 && j < 2) {
       //         u32Data=u64Data;
       //         printf (" transmitter status after send  = %8X \n",u32Data);
       //         u32Data=u64Data>>32;
       //         printf (" receiver status after send  = %8X \n",u32Data);
       //        }
       //       }
       //       nread = nwrite/2;
       //       if(nwrite%2 !=0) nread= nwrite/2 +1;
       //       for (i=0; i< nread; i++) {
       //        dwAddrSpace = tr_bar;
       //        u32Data = 0;
       //        dwOffset = 0;
       //        WDC_ReadAddr64(hDev, dwAddrSpace, dwOffset, &u64Data);
       //        read_array[i*2] = u64Data;
       //        read_array[i*2+1] =u64Data>>32;
       //       }
       //       if(icheck == 1) {
       //        dwAddrSpace =cs_bar;
       //        u64Data =0;
       //        dwOffset = t_cs_reg;
       //        WDC_ReadAddr64(hDev, dwAddrSpace, dwOffset, &u64Data);
       //        if(iprint==1 && j < 2) {
       //         u32Data=u64Data;
       //         printf (" transmitter status after read  = %8X \n",u32Data);
       //         u32Data=u64Data>>32;
       //         printf (" receiver status after read  = %8X \n",u32Data);
       //        }
       //        for (i=0; i< nwrite; i++) {
       //           if(iprint == 1 && j < 2) {
       //             if(i%8 ==0) printf("%d",i);
       //             printf("%9X",read_array[i]);
       //             if((i+1)%8 ==0) printf("\n");
       //           }
       //           if(read_array[i] != write_array[i]) printf("data mismatch, loop = %d word =%d read= %9X write = %9X\n",j,i,read_array[i],write_array[i]);
       //        }
       //        if((iprint ==1) && (nwrite%8 !=0) && j < 2) printf("\n");
       //       }
       //       if(j%100 ==0) printf(" loop = %d, nwrite= %d \n",j, nwrite);
       //       if(kwrite == -1) {
       //         nwrite =nwrite+1;
       //         if(nwrite > nwrite_max) nwrite =nwrite_min;
       //       }
    }

     /** end timer **/
    gettimeofday(&endtest1,NULL);
    seconds1 = endtest1.tv_sec;
    useconds1 = endtest1.tv_usec;
    
    printf("\nEnd time of test:   %ld sec %ld usec\n",seconds1,useconds1);

    seconds1 = endtest1.tv_sec - starttest1.tv_sec;
    useconds1 = endtest1.tv_usec - starttest1.tv_usec;
    
    mytime1 = seconds1*1000000. + useconds1*1.; //elapsed time in usec

    printf("\nElapsed time:\t\t\t %ld usec\n\n", mytime1);

    break;

  case 2:
    icheck=0;
    iprint=0;
    if(icheck == 1) printf(" data checking on \n");
    printf(" enter number of 32bits word send (< 20000), -1 for sequence test\n");
    scanf("%d",&kwrite);
    if(kwrite == -1) {
      printf("enter min number of word \n");
      scanf("%d",&nwrite_min);
      printf("enter max number of word \n");
      scanf("%d",&nwrite_max);
      nwrite=nwrite_min;
    }
    else nwrite = kwrite;

    printf("enter number loops \n");
    scanf("%d",&iloop);
    
    printf(" DMA sequence -> 1 for DMA read after DMA write \n");
    printf("                 2 for Open DMA read and slave write \n");
    scanf("%d",&iseq);
    printf(" type 1 for incomplete DMA test \n");
    scanf("%d",&incomp);
    

/*** allocate the DMA buffer for send and receive **/
    dwDMABufSize = 1000000;
    if(ifr ==0) {
      ifr=1;
      dwStatus = WDC_DMAContigBufLock(hDev, &pbuf_send, dwOptions_send, dwDMABufSize, &pDma_send);
      if (WD_STATUS_SUCCESS != dwStatus) {
	printf("Failed locking a send Contiguous DMA buffer. Error 0x%lx - %s\n", dwStatus, Stat2Str(dwStatus));
      }
      dwStatus = WDC_DMAContigBufLock(hDev, &pbuf_rec, dwOptions_rec, dwDMABufSize, &pDma_rec);
      if (WD_STATUS_SUCCESS != dwStatus) {
	printf("Failed locking a rec Contiguous DMA buffer. Error 0x%lx - %s\n", dwStatus, Stat2Str(dwStatus));
      }
      else {
           u32Data = pDma_rec->Page->pPhysicalAddr & 0xffffffff;
           printf(" buffer allocation lower address = %x\n", u32Data);
           u32Data = (pDma_rec->Page->pPhysicalAddr >> 32) & 0xffffffff;
           printf(" buffer allocation higher address = %x\n", u32Data);
      }
    }
    printf(" type 1 to continue \n");
    scanf("%d",&i);
    tr_bar = t1_tr_bar;
    t_cs_reg = t1_cs_reg;
    r_cs_reg = r1_cs_reg;
    dma_tr = dma_tr1;
    if(itr == 2) {
      tr_bar = t2_tr_bar;
      t_cs_reg = t2_cs_reg;
      r_cs_reg = r2_cs_reg;
      dma_tr = dma_tr2;
    }

/* write this will abort previous DMA */
    dwAddrSpace =2;
    dwOffset = cs_dma_msi_abort;
    u32Data = dma_abort;
    WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
       /* clear DMA register after the abort */
    dwAddrSpace =2;
    dwOffset = cs_dma_msi_abort;
    u32Data = 0;
    WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);


       
       //GSK
       //rand() generation outside loop, for speed test

    buffp_send = pbuf_send;
    buffp_rec = pbuf_rec;
    //	 printf("%llX\n",buffp_send);
    //this is not actually necessary:
    int ig;
    for (ig=0; ig<nwrite; ig++) {
      if(irand == 1) *buffp_send++=rand();
      else *buffp_send++= ig;
      *buffp_rec++ =0x0;
    }
    //    }
    printf("\nGenerated data (words) for loop-back test\n");
    for (i=0; i<nwrite; i++) {
      k = i%8;
      if( k ==0) printf(" %3d", i);
      u32Data = *buffp_send++;
      printf(" %llX",u32Data);
      if(k == 7 ) printf("\n");
    }
    printf("\n");
    for (i=0; i<nwrite; i++) {
      k = i%8;
      if( k ==0) printf(" %3d", i);
      u32Data = *buffp_rec++;
      printf(" %llX",u32Data);
      if(k == 7 ) printf("\n");
    }


      /** begin timer **/
    struct timeval starttest, endtest;
    gettimeofday(&starttest,NULL);
    long mytime, seconds, useconds;
    seconds = starttest.tv_sec;
    useconds = starttest.tv_usec;
      
    printf("\n\nStart time of test: %ld sec %ld usec\n",seconds,useconds);
      //get a fresh timestamp
    gettimeofday(&starttest,NULL);


    for (j=0; j<iloop; j++) {
/* set tx mode register */
      u32Data = 0xf0000008;
      dwOffset = tx_md_reg;
      dwAddrSpace =cs_bar;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
      /** initialize the tranmission ***/
      u32Data = cs_init;
      dwOffset = t_cs_reg;
      dwAddrSpace =cs_bar;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
/** start the tranmitter **/
      dwAddrSpace = cs_bar;
      u32Data = cs_start+nwrite*4;   /* 32 bits mode == 4 bytes per word **/
      dwOffset = t_cs_reg;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
       //GSK
       //       if(iprint == 1 && j < 2) printf(" set up transmitter \n");
/** initialize the receiver ***/
      u32Data = cs_init;
      dwOffset = r_cs_reg;
      dwAddrSpace =cs_bar;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
/** start the receiver **/
      dwAddrSpace = cs_bar;
      u32Data = cs_start+nwrite*4;   /* 32 bits mode == 4 bytes per word **/
      //GSK
       //       if(incomp ==1) u32Data = cs_start+nwrite*4+16; /* set up 4 less words to receive */
      dwOffset = r_cs_reg;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
       //GSK
       //       if(iprint == 1 && j < 2) printf(" set up receiver \n");
       //       if(icheck == 1) {
       //         dwAddrSpace =cs_bar;
       //         u64Data =0;
       //         dwOffset = t_cs_reg;
       //         WDC_ReadAddr64(hDev, dwAddrSpace, dwOffset, &u64Data);
       //	 if(iprint==1 && j < 2) {
       //	   u32Data=u64Data;
       //	   printf (" transmitter status before send  = %8X \n",u32Data);
       //	   u32Data=u64Data>>32;
       //	   printf (" receiver status before send  = %8X \n",u32Data);
       //	 }
       //       }

      buffp_send = pbuf_send;
      buffp_rec = pbuf_rec;

       //GSK
       //do rand() generation outside the loop, and fill array(s) ahead of time
       //       for (i=0; i<nwrite+100; i++) {
       //	 if(irand == 1) *buffp_send++=rand();
       //	 else *buffp_send++= i;
       //	 *buffp_rec++ =0;
       //       }

/*
       buffp_rec = pbuf_rec;
       buffp_send = pbuf_send;

       for (i=0; i<nwrite; i++) {
	  k = i%8;
	  if(iprint ==1 && k ==0) printf(" %3d", i);
	  u32Data = *buffp_send++;
          if(iprint==1) printf(" %llX",u32Data);
	  if(k == 7 && iprint == 1) printf("\n");
       }
*/

//GSK iseq==1 by definition for this test
//       if(iseq == 1) {
/* set up transmitter DMA starting address */
      dwAddrSpace =cs_bar;
      dwOffset = cs_dma_add_low_reg;
      u32Data = pDma_send->Page->pPhysicalAddr & 0xffffffff;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
      
      dwAddrSpace =cs_bar;
      dwOffset = cs_dma_add_high_reg;
      u32Data = (pDma_send->Page->pPhysicalAddr >> 32) & 0xffffffff;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);

/* byte count */
      dwAddrSpace =cs_bar;
      dwOffset = cs_dma_by_cnt;
      u32Data = nwrite*4;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);

	/* synch cache */
      WDC_DMASyncCpu(pDma_send);

/* write this will start DMA */
      dwAddrSpace =cs_bar;
      dwOffset = cs_dma_cntrl;
      u32Data = dma_tr+dma_3dw_trans;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);

/***    check to see if DMA is done or not **/
      idone =0;
      for (i=0; i<200; i++) {;
	dwAddrSpace =cs_bar;
	u64Data =0;
	dwOffset = cs_dma_cntrl;
	WDC_ReadAddr32(hDev, dwAddrSpace, dwOffset, &u32Data);
	  //GSK
	  //	  if(iprint ==1 && j < 2) printf(" send DMA status word %d %X \n", i, u32Data);
	if((u32Data & dma_in_progress) == 0) {
	    //GSK
	    //	    if(iprint == 1 && j < 2) printf(" send DMA complete %d \n", i);
	  idone =1;
	}
	if((u32Data & dma_in_progress) == 0) break;
      }
      if(idone == 0) {
	  //gsk
	  //	  printf(" sending dma is not finished \n");
	  //	  printf(" send DMA status word %d %X \n", i, u32Data);
	break;
      }
	//GSK
	//        if(icheck == 1) {
	//         dwAddrSpace =cs_bar;
	//         u64Data =0;
	//         dwOffset = t_cs_reg;
	//         WDC_ReadAddr64(hDev, dwAddrSpace, dwOffset, &u64Data);
	//	 if(iprint==1 && j < 2) {
	//	   u32Data=u64Data;
	//	   printf (" transmitter status after send  = %8X \n",u32Data);
	//	   u32Data=u64Data>>32;
	//	   printf (" receiver status after send  = %8X \n",u32Data);
	//	 }
	//        }
	//GSK end if iseq==1
	//       }

 	/* synch DMA i/O cache **/
      WDC_DMASyncIo(pDma_send);

	//GSK iseq==1 for this test
	//       if (iseq != 1) {
	///** now write data to the transmiiter */
//        buffp_send = pbuf_send;
//        for (i=0; i< nwrite; i++) {
//         dwAddrSpace = tr_bar;
//         u32Data = *buffp_send++;
//         dwOffset = 0;
//         WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
//        }
//       }


 /** set up the receiver DMA and first  **/

      dwAddrSpace =cs_bar;
      dwOffset = cs_dma_add_low_reg;
      u32Data = pDma_rec->Page->pPhysicalAddr & 0xffffffff;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);

      dwAddrSpace =cs_bar;
      dwOffset = cs_dma_add_high_reg;
      u32Data = (pDma_rec->Page->pPhysicalAddr >> 32) & 0xffffffff;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);

/* byte count */
      dwAddrSpace =cs_bar;
      dwOffset = cs_dma_by_cnt;
      u32Data = nwrite*4;
      if(incomp ==1) u32Data = cs_start+nwrite*4+16; /* set up 4 more words to receive */
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);

/* write this will start DMA */
      dwAddrSpace =2;
      dwOffset = cs_dma_cntrl;
      u32Data = dma_tr+dma_3dw_rec;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);

	/* synch cache */
      WDC_DMASyncCpu(pDma_rec);



/***    check to see if DMA is done or not **/
      idone =0;
      for (i=0; i<200; i++) {;
	dwAddrSpace =cs_bar;
	u64Data =0;
	dwOffset = cs_dma_cntrl;
	WDC_ReadAddr32(hDev, dwAddrSpace, dwOffset, &u32Data);
	//GSK
	//	  if(iprint ==1 && j < 2) printf(" receive DMA status word %d %X \n", i, u32Data);
	if((u32Data & dma_in_progress) == 0) {
	  idone =1;
	  //GSK
	  //	    if(iprint == 1 && j < 2) printf(" receive DMA complete %d \n", i);
	}
	if((u32Data & dma_in_progress) == 0) break;
      }
      /* synch DMA i/O cache **/

      WDC_DMASyncIo(pDma_rec);

      if(idone == 0){
	 //gsk
	 //	 printf(" DMA is not done, %d, iloop = %d, nwrite= %d\n",i, j, nwrite);
	 //         if(incomp ==1) {
	 //           u32Data = dma_abort;
	 //           dwOffset = cs_dma_msi_abort;
	 //           dwAddrSpace =cs_bar;
	 //           WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
	 //           u32Data = 0;
	 //           dwOffset = cs_dma_msi_abort;
	 //           dwAddrSpace =cs_bar;
	 //           WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
	 //           dwAddrSpace =cs_bar;
	 //	   dwOffset = cs_dma_cntrl;
	 //           WDC_ReadAddr32(hDev, dwAddrSpace, dwOffset, &u32Data);
	 //	   if(iprint ==1 && j < 2) printf(" receive DMA status word after abort %d %X \n", i, u32Data);
	 //           dwAddrSpace =cs_bar;
	 //           dwOffset = t_cs_reg;
	 //           WDC_ReadAddr64(hDev, dwAddrSpace, dwOffset, &u64Data);
	 //	   if(iprint==1 && j < 2) {
	 //	     u32Data=u64Data;
	 //	     printf (" transmitter status after abort  = %8X \n",u32Data);
	 //	     u32Data=u64Data>>32;
	 //	     printf (" receiver status after abort  = %8X \n",u32Data);
	 //	   }
	 //         }
	 //         else 
	break;
      }

      if(idone == 1) {
	buffp_rec = pbuf_rec;
	buffp_send = pbuf_send;
	
	 //GSK
	 //	 for (i=0; i<nwrite; i++) {
	 //	   k = i%8;
	 //	  if(iprint ==1 && k ==0 && j < 2) printf(" %3d", i);
	 //	  u32Data = *buffp_rec++;
	 //	  u32Data_send = *buffp_send++;
	 //	  if((u32Data != u32Data_send) && (icheck ==1) ) printf(" %d, %d, %11x, %11x\n", j,i,u32Data_send,u32Data);
	 //	  if(iprint==1 && j < 2) printf(" %llX",u32Data);
	 //	  if(k == 7 && iprint == 1 && j < 2) printf("\n");
	 //	 }
	 //	 if(k !=7 && iprint ==1 && j < 2) printf("\n");
      }
       //       if(j%100 ==0) printf(" loop = %d, nwrite= %d \n",j, nwrite);

       //GSK
       //       if(kwrite == -1) {
       //        nwrite =nwrite+1;
       //        if(nwrite > nwrite_max) nwrite =nwrite_min;
       //       }
    }

      /** end timer **/
    gettimeofday(&endtest,NULL);
    seconds = endtest.tv_sec;
    useconds = endtest.tv_usec;
      
    printf("\nEnd time of test:   %ld sec %ld usec\n",seconds,useconds);

    seconds = endtest.tv_sec - starttest.tv_sec;
    useconds = endtest.tv_usec - starttest.tv_usec;

    mytime = seconds*1000000. + useconds*1.; //elapsed time in usec

    printf("\nElapsed time:\t\t\t %ld usec\n\n", mytime);

    break;
    
  case 3:
    printf("enter number words per packet \n");
    scanf("%d",&nwrite);
    printf("enter number loops \n");
    scanf("%d",&iloop);
    
    tr_bar = t1_tr_bar;
    t_cs_reg = t1_cs_reg;
    r_cs_reg = r1_cs_reg;
    if(itr == 2) {
      tr_bar = t2_tr_bar;
      t_cs_reg = t2_cs_reg;
      r_cs_reg = r2_cs_reg;
    }

/* write this will abort previous DMA */
    dwAddrSpace =2;
    dwOffset = cs_dma_msi_abort;
    u32Data = dma_abort;
    WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
/* clear DMA register after the abort */
    dwAddrSpace =2;
    dwOffset = cs_dma_msi_abort;
    u32Data = 0;
    WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);

    printf("\n\nWriting to file: -----------> test.bin\n");

    FILE * pFile;
    pFile = fopen("test.bin","w");
    if (pFile==NULL){
      printf("\nFile NOT open; Exiting.\n");
      break;
    }

    //first write some stuff

/* set tx mode register */
    u32Data = 0xf0000fff;
    dwOffset = tx_md_reg;
    dwAddrSpace =cs_bar;
    WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
/** initialize the tranmission ***/
    u32Data = cs_init;
    dwOffset = t_cs_reg;
    dwAddrSpace =cs_bar;
    WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
/** start the tranmitter **/
    dwAddrSpace = cs_bar;
    u32Data = cs_start+nwrite*4;   /* 32 bits mode == 4 bytes per word **/
    dwOffset = t_cs_reg;
    WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
       //GSK
       //       if(iprint == 1 && j < 2) printf(" set up transmitter \n");
/** initialize the receiver ***/
    u32Data = cs_init;
    dwOffset = r_cs_reg;
    dwAddrSpace =cs_bar;
    WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
      /** start the receiver **/
    dwAddrSpace = cs_bar;
    u32Data = cs_start+nwrite*4;   /* 32 bits mode == 4 bytes per word **/
    dwOffset = r_cs_reg;
    WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);


    //now write to transmitter ---> edit from this point on

    u32Data = 0x3333;
    for (i=0; i< nwrite; i++) {
      dwAddrSpace = tr_bar;
      dwOffset = 0;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
    }


    //receiver read and write to file

    //loop read



      /** begin timer **/
    struct timeval starttest2, endtest2;
    gettimeofday(&starttest2,NULL);
    long mytime2, seconds2, useconds2;
    seconds2 = starttest2.tv_sec;
    useconds2 = starttest2.tv_usec;
      
    printf("\n\nStart time of test: %ld sec %ld usec\n",seconds2,useconds2);
      //get a fresh timestamp
    gettimeofday(&starttest2,NULL);




      /** end timer **/
    gettimeofday(&endtest2,NULL);
    seconds2 = endtest2.tv_sec;
    useconds2 = endtest2.tv_usec;
      
    printf("\nEnd time of test:   %ld sec %ld usec\n",seconds2,useconds2);

    seconds2 = endtest2.tv_sec - starttest2.tv_sec;
    useconds2 = endtest2.tv_usec - starttest2.tv_usec;

    mytime2 = seconds2*1000000. + useconds2*1.; //elapsed time in usec

    printf("\nElapsed time:\t\t\t %ld usec\n\n", mytime2);
    

    fclose(pFile);

    break;

  }

}
  


static int pcie_send(WDC_DEVICE_HANDLE hDev, int mode, int nword, UINT32 *buff_send)
{
/* imode =0 single word transfer, imode =1 DMA */
#include "wdc_defs.h"
    static DWORD dwAddrSpace;
    static DWORD dwDMABufSize;

    static UINT32 *buf_send;
    static WD_DMA *pDma_send;
    static DWORD dwStatus;
    static DWORD dwOptions_send = DMA_TO_DEVICE;
    static DWORD dwOffset;
    static UINT32 u32Data;
    static PVOID pbuf_send;
    int nwrite,i,j, iprint;
    static int ifr=0;

    if (ifr == 0) {
      ifr=1;
      dwDMABufSize = 140000;
      dwStatus = WDC_DMAContigBufLock(hDev, &pbuf_send, dwOptions_send, dwDMABufSize, &pDma_send);
      if (WD_STATUS_SUCCESS != dwStatus) {
             printf("Failed locking a send Contiguous DMA buffer. Error 0x%lx - %s\n", dwStatus, Stat2Str(dwStatus));
      }
      buf_send = pbuf_send;
    }
    iprint =0;
    if(mode ==1 ) {
      for (i=0; i< nword; i++) {
        *(buf_send+i) = *buff_send++;
/*	printf("%d \n",*(buf_send+i));   */
      }
    }
    if(mode == 0) {
     nwrite = nword*4;
     /*setup transmiiter */
     dwAddrSpace =2;
     u32Data = 0x20000000;
     dwOffset = 0x18;
     WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
     dwAddrSpace =2;
     u32Data = 0x40000000+nwrite;
     dwOffset = 0x18;
     WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
     for (j=0; j< nword; j++) {
       dwAddrSpace =0;
       dwOffset = 0x0;
       u32Data = *buff_send++;
       WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
     }
     for (i=0; i<20000; i++) {
       dwAddrSpace =2;
       dwOffset = 0xC;
       WDC_ReadAddr32(hDev, dwAddrSpace, dwOffset, &u32Data);
       if(iprint ==1) printf(" status reed %d %X \n", i, u32Data);
       if(((u32Data & 0x80000000) == 0) && iprint == 1) printf(" Data Transfer complete %d \n", i);
       if((u32Data & 0x80000000) == 0) break;
     }
    }
    if( mode ==1 ){
      nwrite = nword*4;
      WDC_DMASyncCpu(pDma_send);
/*
      printf(" nwrite = %d \n", nwrite);
      printf(" pcie_send hDev = %d\n", hDev);
      printf(" buf_send = %X\n",*buf_send);
*/
     /*setup transmiiter */
      dwAddrSpace =2;
      u32Data = 0x20000000;
      dwOffset = 0x18;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
      dwAddrSpace =2;
      u32Data = 0x40000000+nwrite;
      dwOffset = 0x18;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);

/* set up sending DMA starting address */

      dwAddrSpace =2;
      u32Data = 0x20000000;
      dwOffset = 0x0;
      u32Data = pDma_send->Page->pPhysicalAddr & 0xffffffff;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);

      dwAddrSpace =2;
      u32Data = 0x20000000;
      dwOffset = 0x4;
      u32Data = (pDma_send->Page->pPhysicalAddr >> 32) & 0xffffffff;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);

/* byte count */
      dwAddrSpace =2;
      dwOffset = 0x8;
      u32Data = nwrite;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);

/* write this will start DMA */
      dwAddrSpace =2;
      dwOffset = 0xc;
      u32Data = 0x00100000;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);

      for (i=0; i<20000; i++) {
        dwAddrSpace =2;
	dwOffset = 0xC;
        WDC_ReadAddr32(hDev, dwAddrSpace, dwOffset, &u32Data);
	if(iprint ==1) printf(" DMA status reed %d %X \n", i, u32Data);
	if(((u32Data & 0x80000000) == 0) && iprint == 1) printf(" DMA complete %d \n", i);
	if((u32Data & 0x80000000) == 0) break;
      }
      WDC_DMASyncIo(pDma_send);
    }
    return i;
    }

static int pcie_rec(WDC_DEVICE_HANDLE hDev, int mode, int istart, int nword, int ipr_status, UINT32 *buff_rec)
{
/* imode =0 single word transfer, imode =1 DMA */
#include "wdc_defs.h"
    static DWORD dwAddrSpace;
    static DWORD dwDMABufSize;

    static UINT32 *buf_rec;
    static WD_DMA *pDma_rec;
    static DWORD dwStatus;
    static DWORD dwOptions_rec = DMA_FROM_DEVICE;
    static DWORD dwOffset;
    static UINT32 u32Data;
    static UINT64 u64Data;
    static PVOID pbuf_rec;
    int nread,i,j, iprint,icomp;
    static int ifr=0;

    if (ifr == 0) {
      ifr=1;
      dwDMABufSize = 140000;
      dwStatus = WDC_DMAContigBufLock(hDev, &pbuf_rec, dwOptions_rec, dwDMABufSize, &pDma_rec);
      if (WD_STATUS_SUCCESS != dwStatus) {
             printf("Failed locking a send Contiguous DMA buffer. Error 0x%lx - %s\n", dwStatus, Stat2Str(dwStatus));
      }
      buf_rec = pbuf_rec;
    }
    iprint =0;
//    printf(" istart = %d\n", istart);
//   printf(" mode   = %d\n", mode);
/** set up the receiver **/
    if((istart == 1) | (istart == 3)) {
// initalize transmitter mode register...
//     printf(" nword = %d \n",nword);
/*
     if(ipr_status ==1) {
      dwAddrSpace =2;
      u64Data =0;
      dwOffset = 0x18;
      WDC_ReadAddr64(hDev, dwAddrSpace, dwOffset, &u64Data);
      printf (" status word before set = %x, %x \n",(u64Data>>32), (u64Data &0xffff));
     }
*/
     dwAddrSpace =2;
     u32Data = 0xf0000008;
     dwOffset = 0x28;
     WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);

     /*initialize the receiver */
     dwAddrSpace =2;
     u32Data = 0x20000000;
     dwOffset = 0x1c;
     WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
     /* write byte count **/
     dwAddrSpace =2;
     u32Data = 0x40000000+nword*4;
     dwOffset = 0x1c;
     WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
     if(ipr_status ==1) {
      dwAddrSpace =2;
      u64Data =0;
      dwOffset = 0x18;
      WDC_ReadAddr64(hDev, dwAddrSpace, dwOffset, &u64Data);
      printf (" status word before read = %x, %x \n",(u64Data>>32), (u64Data &0xffff));
     }

     return 0;
    }
    if ((istart == 2) | (istart == 3)) {
//     if(ipr_status ==1) {
//      dwAddrSpace =2;
//      u64Data =0;
//      dwOffset = 0x18;
//      WDC_ReadAddr64(hDev, dwAddrSpace, dwOffset, &u64Data);
//      printf (" status word before read = %x, %x \n",(u64Data>>32), (u64Data &0xffff));
//     }
     if(mode == 0) {
      nread = nword/2+1;
      if(nword%2 == 0) nread = nword/2;
      for (j=0; j< nread; j++) {
       dwAddrSpace =0;
       dwOffset = 0x0;
       u64Data =0xbad;
       WDC_ReadAddr64(hDev,dwAddrSpace, dwOffset, &u64Data);
//       printf("u64Data = %16X\n",u64Data);
       *buff_rec++ = (u64Data &0xffffffff);
       *buff_rec++ = u64Data >>32;
//       printf("%x \n",(u64Data &0xffffffff));
//       printf("%x \n",(u64Data >>32 ));
//       if(j*2+1 > nword) *buff_rec++ = (u64Data)>>32;
//       *buff_rec++ = 0x0;
      }
      if(ipr_status ==1) {
       dwAddrSpace =2;
       u64Data =0;
       dwOffset = 0x18;
       WDC_ReadAddr64(hDev, dwAddrSpace, dwOffset, &u64Data);
       printf (" status word after read = %x, %x \n",(u64Data>>32), (u64Data &0xffff));
      }
      return 0;
     }
     if( mode ==1 ){
      nread = nword*4;
      WDC_DMASyncCpu(pDma_rec);
/*
      printf(" nwrite = %d \n", nwrite);
      printf(" pcie_send hDev = %d\n", hDev);
      printf(" buf_send = %X\n",*buf_send);
*/
/*setup receiver
      dwAddrSpace =2;
      u32Data = 0x20000000;
      dwOffset = 0x1c;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
      dwAddrSpace =2;
      u32Data = 0x40000000+nread;
      dwOffset = 0x1c;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
*/
/* set up sending DMA starting address */

      dwAddrSpace =2;
      u32Data = 0x20000000;
      dwOffset = 0x0;
      u32Data = pDma_rec->Page->pPhysicalAddr & 0xffffffff;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);

      dwAddrSpace =2;
      u32Data = 0x20000000;
      dwOffset = 0x4;
      u32Data = (pDma_rec->Page->pPhysicalAddr >> 32) & 0xffffffff;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);

/* byte count */
      dwAddrSpace =2;
      dwOffset = 0x8;
      u32Data = nread;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);

/* write this will start DMA */
      dwAddrSpace =2;
      dwOffset = 0xc;
      u32Data = 0x00100040;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
      icomp=0;
      for (i=0; i<20000; i++) {
        dwAddrSpace =2;
	dwOffset = 0xC;
        WDC_ReadAddr32(hDev, dwAddrSpace, dwOffset, &u32Data);
	if(iprint ==1) printf(" DMA status read %d %X \n", i, u32Data);
	if(((u32Data & 0x80000000) == 0)) {
          icomp=1;
          if(iprint == 1) printf(" DMA complete %d \n", i);
        }
	if((u32Data & 0x80000000) == 0) break;
      }
      if(icomp == 0) {
        printf("DMA timeout\n");
        return 1;
      }
      WDC_DMASyncIo(pDma_rec);
      for (i=0; i< nword; i++) {
        *buff_rec++ = *(buf_rec+i);
/*	printf("%d \n",*(buf_send+i));   */
      }
     }
    }
    return 0;
    }


static int xmit_boot(WDC_DEVICE_HANDLE hDev, int imod_xmit)
{
#include "wdc_defs.h"
#define  mb_xmit_conf_add 0x2

    FILE *inpf;
    int imod,ichip,count,counta,ichip_c,dummy1,ik,ij,i;
    unsigned char charchannel,carray[4000];
    int nsend,nword,k;
    UINT32 buf_send[10000],send_array[10000];
    UINT32 *px;
    struct timespec tim,tim2;
    tim.tv_sec=0;
    tim.tv_nsec = 128000;
//
//    boot up xmit module 1st
//
      nsend=500;
      px = &buf_send;
      printf(" boot xmit module \n");
      inpf = fopen("/home/ub/xmit_fpga","r");
      imod=imod_xmit;
      ichip=mb_xmit_conf_add;
      buf_send[0]=(imod<<11)+(ichip<<8)+0x0+(0x0<<16);  // turn conf to be on
      i=1;
      k=1;
      i = pcie_send(hDev, i, k, px);
//      for (i=0; i<100000; i++) {
//          ik= i%2;
//          dummy1= (ik+i)*(ik+i);
//      }


        /* read data as characters (28941) */
      usleep(1000);   // wait fior a while
      count = 0;
      counta= 0;
      ichip_c = 7; // set ichip_c to stay away from any other command in the
      dummy1 =0;
      while (fread(&charchannel,sizeof(char),1,inpf)==1) {
       carray[count] = charchannel;
       count++;
       counta++;
       if((count%(nsend*2)) == 0) {
//        printf(" loop = %d\n",dummy1);
        buf_send[0] = (imod <<11) +(ichip_c <<8)+ (carray[0]<<16);
        send_array[0] =buf_send[0];
        if(dummy1 <= 5 ) printf(" counta = %d, first word = %x, %x, %x %x %x \n",counta,buf_send[0], carray[0], carray[1]
        ,carray[2], carray[3]);
        for (ij=0; ij< nsend; ij++) {
         if(ij== (nsend-1)) buf_send[ij+1] = carray[2*ij+1]+(0x0<<16);
         else buf_send[ij+1] = carray[2*ij+1]+ (carray[2*ij+2]<<16);
//         buf_send[ij+1] = carray[2*ij+1]+ (carray[2*ij+2]<<16);
         send_array[ij+1] = buf_send[ij+1];
        }
        nword =nsend+1;
        i=1;
//       if(dummy1 == 0)
        ij = pcie_send(hDev, i, nword, px);
        nanosleep(&tim , &tim2);
        dummy1 = dummy1+1;
        count =0;
       }
      }
      if(feof(inpf)) {
       printf("You have reached the end-of-file word count= %d %d\n", counta, count);
       buf_send[0] = (imod <<11) +(ichip_c <<8)+ (carray[0]<<16);
       if ( count > 1) {
        if( ((count-1)%2) ==0) {
         ik =(count-1)/2;
        }
        else {
         ik =(count-1)/2+1;
        }
        ik=ik+2;   // add one more for safety
        printf("ik= %d\n",ik);
        for (ij=0; ij<ik; ij++){
         if(ij == (ik-1)) buf_send[ij+1] = carray[(2*ij)+1]+(((imod<<11)+(ichip<<8)+0x0)<<16);
         else buf_send[ij+1] = carray[(2*ij)+1]+ (carray[(2*ij)+2]<<16);
         send_array[ij+1] = buf_send[ij+1];
        }
       }
       else ik=1;

           for (ij=ik-10; ij< ik+1; ij++) {
            printf("Last data = %d, %x\n",ij,buf_send[ij]);
           }

       nword =ik+1;
       i=1;
       i = pcie_send(hDev, i, nword, px);
      }
      usleep(2000);    // wait for 2ms to cover the packet time plus fpga init time
      fclose(inpf);
      return i;
}


    static int fem_boot(WDC_DEVICE_HANDLE hDev, int imod_fem)
{
#include "wdc_defs.h"
#define  mb_feb_conf_add 0x2

    FILE *inpf;
    int imod,ichip,count,counta,ichip_c,dummy1,ik,ij,i;
    unsigned char charchannel,carray[4000];
    int nsend,nword,k;
    UINT32 buf_send[10000],send_array[10000];
    UINT32 *px;
    struct timespec tim,tim2;
    tim.tv_sec=0;
    tim.tv_nsec = 128000;
//
//    boot up xmit module 1st
//
      nsend=500;
      px = &buf_send;
//
//    Boot stratix after XMIT module
//
      inpf = fopen("/home/ub/feb_fpga_test","r");
      imod=imod_fem;
      ichip=mb_feb_conf_add;
      buf_send[0]=(imod<<11)+(ichip<<8)+0x0+(0x0<<16);  // turn conf to be on
      i=1;
      k=1;
      i = pcie_send(hDev, i, k, px);
//      for (i=0; i<100000; i++) {
//          ik= i%2;
//          dummy1= (ik+i)*(ik+i);
//      }


        /* read data as characters (28941) */
      usleep(1000);   // wait fior a while
      count = 0;
      counta= 0;
      ichip_c = 7; // set ichip_c to stay away from any other command in the
      dummy1 =0;
      while (fread(&charchannel,sizeof(char),1,inpf)==1) {
       carray[count] = charchannel;
       count++;
       counta++;
       if((count%(nsend*2)) == 0) {
//        printf(" loop = %d\n",dummy1);
        buf_send[0] = (imod <<11) +(ichip_c <<8)+ (carray[0]<<16);
        send_array[0] =buf_send[0];
        if(dummy1 <= 5 ) printf(" counta = %d, first word = %x, %x, %x %x %x \n",counta,buf_send[0], carray[0], carray[1]
        ,carray[2], carray[3]);
        for (ij=0; ij< nsend; ij++) {
         if(ij== (nsend-1)) buf_send[ij+1] = carray[2*ij+1]+(0x0<<16);
         else buf_send[ij+1] = carray[2*ij+1]+ (carray[2*ij+2]<<16);
//         buf_send[ij+1] = carray[2*ij+1]+ (carray[2*ij+2]<<16);
         send_array[ij+1] = buf_send[ij+1];
        }
        nword =nsend+1;
        i=1;
//       if(dummy1 == 0)
        ij = pcie_send(hDev, i, nword, px);
        nanosleep(&tim , &tim2);
        dummy1 = dummy1+1;
        count =0;
       }
      }
      if(feof(inpf)) {
       printf("You have reached the end-of-file word count= %d %d\n", counta, count);
       buf_send[0] = (imod <<11) +(ichip_c <<8)+ (carray[0]<<16);
       if ( count > 1) {
        if( ((count-1)%2) ==0) {
         ik =(count-1)/2;
        }
        else {
         ik =(count-1)/2+1;
        }
        ik=ik+2;   // add one more for safety
        printf("ik= %d\n",ik);
        for (ij=0; ij<ik; ij++){
         if(ij == (ik-1)) buf_send[ij+1] = carray[(2*ij)+1]+(((imod<<11)+(ichip<<8)+0x0)<<16);
         else buf_send[ij+1] = carray[(2*ij)+1]+ (carray[(2*ij)+2]<<16);
         send_array[ij+1] = buf_send[ij+1];
        }
       }
       else ik=1;

           for (ij=ik-10; ij< ik+1; ij++) {
            printf("Last data = %d, %x\n",ij,buf_send[ij]);
           }

       nword =ik+1;
       i=1;
       i = pcie_send(hDev, i, nword, px);
      }
       usleep(2000);    // wait for 2ms to cover the packet time plus fpga init time
       fclose(inpf);
      return i;
}




/* -----------------------------------------------
    Read/write memory and I/O addresses
   ----------------------------------------------- */
/* Read/write address menu options */
enum {
    MENU_RW_ADDR_SET_ADDR_SPACE = 1,
    MENU_RW_ADDR_SET_MODE,
    MENU_RW_ADDR_SET_TRANS_TYPE,
    MENU_RW_ADDR_READ,
    MENU_RW_ADDR_WRITE,
    MENU_RW_ADDR_EXIT = DIAG_EXIT_MENU,
};

#define ACTIVE_ADDR_SPACE_NEEDS_INIT 0xFF

/* Read/write memory or I/O space address menu */
static void MenuReadWriteAddr(WDC_DEVICE_HANDLE hDev)
{
    DWORD option;
    static DWORD dwAddrSpace = ACTIVE_ADDR_SPACE_NEEDS_INIT;
    static WDC_ADDR_MODE mode = WDC_MODE_32;
    static BOOL fBlock = FALSE;

    /* Initialize active address space */
    if (ACTIVE_ADDR_SPACE_NEEDS_INIT == dwAddrSpace)
    {
        DWORD dwNumAddrSpaces = PCIE_GetNumAddrSpaces(hDev);
        
        /* Find the first active address space */
        for (dwAddrSpace = 0; dwAddrSpace < dwNumAddrSpaces; dwAddrSpace++)
        {
            if (WDC_AddrSpaceIsActive(hDev, dwAddrSpace))
                break;
        }
        
        /* Sanity check */
        if (dwAddrSpace == dwNumAddrSpaces)
        {
            PCIE_ERR("MenuReadWriteAddr: Error - no active address spaces found\n");
            dwAddrSpace = ACTIVE_ADDR_SPACE_NEEDS_INIT;
            return;
        }
    }

    do
    {
        printf("\n");
        printf("Read/write the device's memory and IO ranges\n");
        printf("---------------------------------------------\n");
        printf("%d. Change active address space for read/write "
            "(currently: BAR %ld)\n", MENU_RW_ADDR_SET_ADDR_SPACE, dwAddrSpace);
        printf("%d. Change active read/write mode (currently: %s)\n",
            MENU_RW_ADDR_SET_MODE,
            (WDC_MODE_8 == mode) ? "8 bit" : (WDC_MODE_16 == mode) ? "16 bit" :
            (WDC_MODE_32 == mode) ? "32 bit" : "64 bit");
        printf("%d. Toggle active transfer type (currently: %s)\n",
            MENU_RW_ADDR_SET_TRANS_TYPE,
            (fBlock ? "block transfers" : "non-block transfers"));
        printf("%d. Read from active address space\n", MENU_RW_ADDR_READ);
        printf("%d. Write to active address space\n", MENU_RW_ADDR_WRITE);
        printf("%d. Exit menu\n", MENU_RW_ADDR_EXIT);
        printf("\n");
        
        if (DIAG_INPUT_FAIL == DIAG_GetMenuOption(&option,
            MENU_RW_ADDR_WRITE))
        {
            continue;
        }
        
        switch (option)
        {
        case MENU_RW_ADDR_EXIT: /* Exit menu */
            break;
        case MENU_RW_ADDR_SET_ADDR_SPACE: /* Set active address space for read/write address requests */
        {
            SetAddrSpace(hDev, &dwAddrSpace);
            break;
        }
        case MENU_RW_ADDR_SET_MODE: /* Set active mode for read/write address requests */
            WDC_DIAG_SetMode(&mode);
            break;
        case MENU_RW_ADDR_SET_TRANS_TYPE: /* Toggle active transfer type */
            fBlock = !fBlock;
            break;
        case MENU_RW_ADDR_READ:  /* Read from a memory or I/O address */
        case MENU_RW_ADDR_WRITE: /* Write to a memory or I/O address */
        {
            WDC_DIRECTION direction =
                (MENU_RW_ADDR_READ == option) ? WDC_READ : WDC_WRITE;

            if (fBlock)
                WDC_DIAG_ReadWriteBlock(hDev, direction, dwAddrSpace);
            else
                WDC_DIAG_ReadWriteAddr(hDev, direction, dwAddrSpace, mode);
            
            break;
        }
        }
    } while (MENU_RW_ADDR_EXIT != option);
}

static void SetAddrSpace(WDC_DEVICE_HANDLE hDev, PDWORD pdwAddrSpace)
{
    DWORD dwAddrSpace;
    DWORD dwNumAddrSpaces = PCIE_GetNumAddrSpaces(hDev);
    PCIE_ADDR_SPACE_INFO addrSpaceInfo;
    
    printf("\n");
    printf("Select an active address space:\n");
    printf("-------------------------------\n");

    for (dwAddrSpace = 0; dwAddrSpace < dwNumAddrSpaces; dwAddrSpace++)
    {
        BZERO(addrSpaceInfo);
        addrSpaceInfo.dwAddrSpace = dwAddrSpace;
        if (!PCIE_GetAddrSpaceInfo(hDev, &addrSpaceInfo))
        {
            PCIE_ERR("SetAddrSpace: Error - Failed to get address space information: %s",
                PCIE_GetLastErr());
            return;
        }

        printf("%ld. %-*s %-*s %s\n",
            dwAddrSpace + 1,
            MAX_NAME_DISPLAY, addrSpaceInfo.sName,
            MAX_TYPE - 1, addrSpaceInfo.sType,
            addrSpaceInfo.sDesc);
    }
    printf("\n");

    if (DIAG_INPUT_SUCCESS != DIAG_InputDWORD((PVOID)&dwAddrSpace,
        "Enter option", FALSE, 1, dwNumAddrSpaces))
    {
         return;
    }

    dwAddrSpace--;
    if (!WDC_AddrSpaceIsActive(hDev, dwAddrSpace))
    {
        printf("You have selected an inactive address space\n");
        return;
    }
            
    *pdwAddrSpace = dwAddrSpace;
}

/* -----------------------------------------------
    Read/write the configuration space
   ----------------------------------------------- */
/* Read/write the configuration space menu options */
enum {
    MENU_RW_CFG_SPACE_READ_OFFSET = 1,
    MENU_RW_CFG_SPACE_WRITE_OFFSET,
    MENU_RW_CFG_SPACE_READ_ALL_REGS,
    MENU_RW_CFG_SPACE_READ_REG,
    MENU_RW_CFG_SPACE_WRITE_REG,
    MENU_RW_CFG_SPACE_EXIT = DIAG_EXIT_MENU,
};

/* Display read/write configuration space menu */
static void MenuReadWriteCfgSpace(WDC_DEVICE_HANDLE hDev)
{
    DWORD option;
  
    do {
        /* Display pre-defined registers' information */
        if (PCIE_CFG_REGS_NUM)
        {
            printf("\n");
            printf("Configuration registers:\n");
            printf("------------------------\n");
            WDC_DIAG_RegsInfoPrint(gpPCIE_CfgRegs, PCIE_CFG_REGS_NUM,
                WDC_DIAG_REG_PRINT_ALL & ~WDC_DIAG_REG_PRINT_ADDR_SPACE);
        }

        printf("\n");
        printf("Read/write the device's configuration space\n");
        printf("--------------------------------------------\n");
        printf("%d. Read from an offset\n", MENU_RW_CFG_SPACE_READ_OFFSET);
        printf("%d. Write to an offset\n", MENU_RW_CFG_SPACE_WRITE_OFFSET);
        if (PCIE_CFG_REGS_NUM)
        {
            printf("%d. Read all configuration registers defined for the device (see list above)\n",
                MENU_RW_CFG_SPACE_READ_ALL_REGS);
            printf("%d. Read from a named register\n", MENU_RW_CFG_SPACE_READ_REG);
            printf("%d. Write to a named register\n", MENU_RW_CFG_SPACE_WRITE_REG);
        }
        printf("%d. Exit menu\n", MENU_RW_CFG_SPACE_EXIT);
        printf("\n");

        if (DIAG_INPUT_FAIL == DIAG_GetMenuOption(&option,
            PCIE_CFG_REGS_NUM ? MENU_RW_CFG_SPACE_WRITE_REG :
            MENU_RW_CFG_SPACE_WRITE_OFFSET))
        {
            continue;
        }

        switch (option)
        {
        case MENU_RW_CFG_SPACE_EXIT: /* Exit menu */
            break;
        case MENU_RW_CFG_SPACE_READ_OFFSET: /* Read from a configuration space offset */
            WDC_DIAG_ReadWriteBlock(hDev, WDC_READ, WDC_AD_CFG_SPACE);
            break;
        case MENU_RW_CFG_SPACE_WRITE_OFFSET: /* Write to a configuration space offset */
            WDC_DIAG_ReadWriteBlock(hDev, WDC_WRITE, WDC_AD_CFG_SPACE);
            break;
        case MENU_RW_CFG_SPACE_READ_ALL_REGS:
            WDC_DIAG_ReadRegsAll(hDev, gpPCIE_CfgRegs, PCIE_CFG_REGS_NUM, TRUE);
            break;
        case MENU_RW_CFG_SPACE_READ_REG:  /* Read from a configuration register */
            WDC_DIAG_ReadWriteReg(hDev, gpPCIE_CfgRegs, PCIE_CFG_REGS_NUM, WDC_READ, TRUE);
            break;
        case MENU_RW_CFG_SPACE_WRITE_REG: /* Write to a configuration register */
            WDC_DIAG_ReadWriteReg(hDev, gpPCIE_CfgRegs, PCIE_CFG_REGS_NUM, WDC_WRITE, TRUE);
            break;
        }
    } while (MENU_RW_CFG_SPACE_EXIT != option);
}

/* -----------------------------------------------
    Read/write the run-time registers
   ----------------------------------------------- */
/* Read/write the run-time registers menu options */
enum {
    MENU_RW_REGS_READ_ALL = 1,
    MENU_RW_REGS_READ_REG,
    MENU_RW_REGS_WRITE_REG,
    MENU_RW_REGS_EXIT = DIAG_EXIT_MENU,
};

/* Display read/write run-time registers menu */
static void MenuReadWriteRegs(WDC_DEVICE_HANDLE hDev)
{
    DWORD option;
    
    if (!PCIE_REGS_NUM)
    {
        printf("There are currently no pre-defined run-time registers\n");
        return;
    }
  
    do {
        /* Display pre-defined registers' information */
        printf("\n");
        printf("PCIE run-time registers:\n");
        printf("--------------------------\n");   
        WDC_DIAG_RegsInfoPrint(gpPCIE_Regs, PCIE_REGS_NUM, WDC_DIAG_REG_PRINT_ALL);

        printf("\n");
        printf("Read/write the PCIE run-time registers\n");
        printf("-----------------------------------------\n");
        printf("%d. Read all run-time registers defined for the device (see list above)\n",
            MENU_RW_REGS_READ_ALL);
        printf("%d. Read from a specific register\n", MENU_RW_REGS_READ_REG);
        printf("%d. Write to a specific register\n", MENU_RW_REGS_WRITE_REG);
        printf("%d. Exit menu\n", MENU_RW_REGS_EXIT);
        printf("\n");

        if (DIAG_INPUT_FAIL == DIAG_GetMenuOption(&option,
            MENU_RW_REGS_WRITE_REG))
        {
            continue;
        }

        switch (option)
        {
        case MENU_RW_REGS_EXIT: /* Exit menu */
            break;
        case MENU_RW_REGS_READ_ALL:
            WDC_DIAG_ReadRegsAll(hDev, gpPCIE_Regs, PCIE_REGS_NUM, FALSE);
            break;
        case MENU_RW_REGS_READ_REG:  /* Read from a register */
            WDC_DIAG_ReadWriteReg(hDev, gpPCIE_Regs, PCIE_REGS_NUM, WDC_READ, FALSE);
            break;
        case MENU_RW_REGS_WRITE_REG: /* Write to a register */
            WDC_DIAG_ReadWriteReg(hDev, gpPCIE_Regs, PCIE_REGS_NUM, WDC_WRITE, FALSE);
            break;
        }
    } while (MENU_RW_REGS_EXIT != option);
}

/* -----------------------------------------------
    Interrupt handling
   ----------------------------------------------- */
/* Interrupts menu options */
enum {
    MENU_INT_ENABLE_DISABLE = 1,
    MENU_INT_EXIT = DIAG_EXIT_MENU,
};

/* Enable/Disable interrupts menu */
static void MenuInterrupts(WDC_DEVICE_HANDLE hDev)
{
    DWORD option, dwIntOptions;
    BOOL fIntEnable, fIsMsi;

    dwIntOptions = WDC_GET_INT_OPTIONS(hDev);
    fIsMsi = WDC_INT_IS_MSI(dwIntOptions);
    if (dwIntOptions & INTERRUPT_LEVEL_SENSITIVE)
    {
        /* TODO: You can remove this message after you have modified the
           implementation of PCIE_IntEnable() in pcie_lib.c to 
           correctly acknowledge level-sensitive interrupts (see guidelines
           in PCIE_IntEnable()) */
        printf("\n");
        printf("WARNING!!!\n");
        printf("----------\n");
        printf("Your hardware has level sensitive interrupts.\n");
        printf("Before enabling the interrupts, %s first modify the source "
           "code of PCIE_IntEnable(), in the file pcie_lib.c, to "
           "correctly acknowledge\n%s interrupts when they occur (as dictated by "
           "the hardware's specifications)\n",
           fIsMsi ? "it's recommended that you" : "you must",
           fIsMsi ? "level sensitive" : "");    }

    do
    {
        fIntEnable = !PCIE_IntIsEnabled(hDev);

        printf("\n");
        printf("Interrupts\n");
        printf("-----------\n");
        printf("%d. %s interrupts\n", MENU_INT_ENABLE_DISABLE,
            fIntEnable ? "Enable" : "Disable");
        printf("%d. Exit menu\n", MENU_INT_EXIT);
        printf("\n");

        if (DIAG_INPUT_FAIL == DIAG_GetMenuOption(&option,
            MENU_RW_ADDR_WRITE))
        {
            continue;
        }

        switch (option)
        {
        case MENU_INT_EXIT: /* Exit menu */
            break;
        case MENU_INT_ENABLE_DISABLE: /* Enable/disable interrupts */
            if (fIntEnable)
            {
                DWORD dwStatus = PCIE_IntEnable(hDev, DiagIntHandler);

                if (WD_STATUS_SUCCESS == dwStatus)
                    printf("Interrupts enabled\n");
                else
                {
                    PCIE_ERR("Failed enabling interrupts. Error 0x%lx - %s\n",
                       dwStatus, Stat2Str(dwStatus));
                }
            }
            else
            {
                if (WD_STATUS_SUCCESS == PCIE_IntDisable(hDev))
                    printf("Interrupts disabled\n");
                else
                    PCIE_ERR("Failed disabling interrupts: %s", PCIE_GetLastErr());
            }
            break;
        }
    } while (MENU_INT_EXIT != option);
}

/* Diagnostics interrupt handler routine */
static void DiagIntHandler(WDC_DEVICE_HANDLE hDev, PCIE_INT_RESULT *pIntResult)
{
    /* TODO: You can modify this function in order to implement your own
             diagnostics interrupt handler routine */

    printf("Got interrupt number %ld\n", pIntResult->dwCounter);
    printf("Interrupt Type: %s\n",
        WDC_DIAG_IntTypeDescriptionGet(pIntResult->dwEnabledIntType));
    if (WDC_INT_IS_MSI(pIntResult->dwEnabledIntType))
        printf("Message Data: 0x%lx\n", pIntResult->dwLastMessage);
}

/* ----------------------------------------------------
    Plug-and-play and power management events handling
   ---------------------------------------------------- */
/* Events menu options */
enum {
    MENU_EVENTS_REGISTER_UNREGISTER = 1,
    MENU_EVENTS_EXIT = DIAG_EXIT_MENU,
};

/* Register/unregister Plug-and-play and power management events */
static void MenuEvents(WDC_DEVICE_HANDLE hDev)
{
    DWORD option;
    BOOL fRegister;

    do
    {
        fRegister = !PCIE_EventIsRegistered(hDev);
        
        printf("\n");
        printf("Plug-and-play and power management events\n");
        printf("------------------------------------------\n");
        printf("%d. %s events\n", MENU_EVENTS_REGISTER_UNREGISTER,
            fRegister ? "Register" : "Unregister");
        printf("%d. Exit menu\n", MENU_EVENTS_EXIT);
        printf("\n");
        
        if (DIAG_INPUT_FAIL == DIAG_GetMenuOption(&option,
            MENU_EVENTS_REGISTER_UNREGISTER))
        {
            continue;
        }

        switch (option)
        {
        case MENU_EVENTS_EXIT: /* Exit menu */
            break;
        case MENU_EVENTS_REGISTER_UNREGISTER: /* Register/unregister events */
            if (fRegister)
            {
                if (WD_STATUS_SUCCESS == PCIE_EventRegister(hDev, DiagEventHandler))
                    printf("Events registered\n");
                else
                    PCIE_ERR("Failed to register events. Last error:\n%s", PCIE_GetLastErr());
            }
            else
            {
                if (WD_STATUS_SUCCESS == PCIE_EventUnregister(hDev))
                    printf("Events unregistered\n");
                else
                    PCIE_ERR("Failed to unregister events. Last Error:\n%s", PCIE_GetLastErr());
            }
            break;
        }
    } while (MENU_EVENTS_EXIT != option);
}

/* Plug-and-play and power management events handler routine */
static void DiagEventHandler(WDC_DEVICE_HANDLE hDev, DWORD dwAction)
{
    /* TODO: You can modify this function in order to implement your own
             diagnostics events handler routine */

    printf("\nReceived event notification (device handle 0x%p): ", hDev);
    switch (dwAction)
    {
    case WD_INSERT:
        printf("WD_INSERT\n");
        break;
    case WD_REMOVE:
        printf("WD_REMOVE\n");
        break;
    case WD_POWER_CHANGED_D0:
        printf("WD_POWER_CHANGED_D0\n");
        break;
    case WD_POWER_CHANGED_D1:
        printf("WD_POWER_CHANGED_D1\n");
        break;
    case WD_POWER_CHANGED_D2:
        printf("WD_POWER_CHANGED_D2\n");
        break;
    case WD_POWER_CHANGED_D3:
        printf("WD_POWER_CHANGED_D3\n");
        break;
    case WD_POWER_SYSTEM_WORKING:
        printf("WD_POWER_SYSTEM_WORKING\n");
        break;
    case WD_POWER_SYSTEM_SLEEPING1:
        printf("WD_POWER_SYSTEM_SLEEPING1\n");
        break;
    case WD_POWER_SYSTEM_SLEEPING2:
        printf("WD_POWER_SYSTEM_SLEEPING2\n");
        break;
    case WD_POWER_SYSTEM_SLEEPING3:
        printf("WD_POWER_SYSTEM_SLEEPING3\n");
        break;
    case WD_POWER_SYSTEM_HIBERNATE:
        printf("WD_POWER_SYSTEM_HIBERNATE\n");
        break;
    case WD_POWER_SYSTEM_SHUTDOWN:
        printf("WD_POWER_SYSTEM_SHUTDOWN\n");
        break;
    default:
        printf("0x%lx\n", dwAction);
        break;
    }
}

